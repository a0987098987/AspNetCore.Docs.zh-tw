---
uid: single-page-application/overview/introduction/knockoutjs-template
title: 單一頁面應用程式： KnockoutJS 範本 |Microsoft Docs
author: MikeWasson
description: Knockout 範本
ms.author: aspnetcontent
ms.date: 01/30/2013
ms.assetid: f9c07af0-4b20-4b08-af8f-47fc3df169a2
msc.legacyurl: /single-page-application/overview/introduction/knockoutjs-template
msc.type: authoredcontent
ms.openlocfilehash: 9e48c7033cefe8b6e4c456577b7a6448f9815d0b
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/05/2018
ms.locfileid: "37832525"
---
<a name="single-page-application-knockoutjs-template"></a><span data-ttu-id="1fb94-103">單一頁面應用程式： KnockoutJS 範本</span><span class="sxs-lookup"><span data-stu-id="1fb94-103">Single Page Application: KnockoutJS template</span></span>
====================
<span data-ttu-id="1fb94-104">藉由[Mike Wasson](https://github.com/MikeWasson)</span><span class="sxs-lookup"><span data-stu-id="1fb94-104">by [Mike Wasson](https://github.com/MikeWasson)</span></span>

> <span data-ttu-id="1fb94-105">Knockout MVC 範本屬於 ASP.NET 和 Web 工具 2012.2</span><span class="sxs-lookup"><span data-stu-id="1fb94-105">The Knockout MVC Template is part of ASP.NET and Web Tools 2012.2</span></span>
> 
> [<span data-ttu-id="1fb94-106">下載 ASP.NET 和 Web 工具 2012.2</span><span class="sxs-lookup"><span data-stu-id="1fb94-106">Download ASP.NET and Web Tools 2012.2</span></span>](https://go.microsoft.com/fwlink/?LinkId=282650)


<span data-ttu-id="1fb94-107">ASP.NET 和 Web 工具 2012.2 更新包含 ASP.NET MVC 4 單一頁面應用程式 (SPA) 範本。</span><span class="sxs-lookup"><span data-stu-id="1fb94-107">The ASP.NET and Web Tools 2012.2 update includes a Single-Page Application (SPA) template for ASP.NET MVC 4.</span></span> <span data-ttu-id="1fb94-108">此範本被設計來協助您開始快速建置互動式用戶端 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="1fb94-108">This template is designed to get you started quickly building interactive client-side web apps.</span></span>

<span data-ttu-id="1fb94-109">「 單一頁面應用程式 」 (SPA) 是載入單一 HTML 頁面，並以動態方式，而不是載入新的頁面更新頁面的 web 應用程式的一般詞彙。</span><span class="sxs-lookup"><span data-stu-id="1fb94-109">"Single-page application" (SPA) is the general term for a web application that loads a single HTML page and then updates the page dynamically, instead of loading new pages.</span></span> <span data-ttu-id="1fb94-110">在初始網頁載入後，SPA 會與透過 AJAX 要求的伺服器。</span><span class="sxs-lookup"><span data-stu-id="1fb94-110">After the initial page load, the SPA talks with the server through AJAX requests.</span></span>

![](knockoutjs-template/_static/image1.png)

<span data-ttu-id="1fb94-111">AJAX 是新奇，但今天很輕鬆地建置及維護的大型複雜的 SPA 應用程式的 JavaScript 架構。</span><span class="sxs-lookup"><span data-stu-id="1fb94-111">AJAX is nothing new, but today there are JavaScript frameworks that make it easier to build and maintain a large sophisticated SPA application.</span></span> <span data-ttu-id="1fb94-112">此外，html5 和 css3 等讓您更輕鬆地建立豐富的 Ui。</span><span class="sxs-lookup"><span data-stu-id="1fb94-112">Also, HTML 5 and CSS3 are making it easier to create rich UIs.</span></span>

<span data-ttu-id="1fb94-113">若要開始，SPA 範本會建立 「 待辦事項清單 」 應用程式範例。</span><span class="sxs-lookup"><span data-stu-id="1fb94-113">To get you started, the SPA template creates a sample "To-do list" application.</span></span> <span data-ttu-id="1fb94-114">在本教學課程中，我們將帶導覽的範本。</span><span class="sxs-lookup"><span data-stu-id="1fb94-114">In this tutorial, we'll take a guided tour of the template.</span></span> <span data-ttu-id="1fb94-115">第一次我們將查看待辦事項清單應用程式本身，並檢查技術項目，讓它運作。</span><span class="sxs-lookup"><span data-stu-id="1fb94-115">First we'll look at the To-do list application itself, then examine the technology pieces that make it work.</span></span>

## <a name="create-a-new-spa-template-project"></a><span data-ttu-id="1fb94-116">建立新的 SPA 專案範本</span><span class="sxs-lookup"><span data-stu-id="1fb94-116">Create a New SPA Template Project</span></span>

<span data-ttu-id="1fb94-117">需求：</span><span class="sxs-lookup"><span data-stu-id="1fb94-117">Requirements:</span></span>

- <span data-ttu-id="1fb94-118">Visual Studio 2012 或 Visual Studio Express 2012 for Web</span><span class="sxs-lookup"><span data-stu-id="1fb94-118">Visual Studio 2012 or Visual Studio Express 2012 for Web</span></span>
- <span data-ttu-id="1fb94-119">ASP.NET Web 工具 2012.2 更新。</span><span class="sxs-lookup"><span data-stu-id="1fb94-119">ASP.NET Web Tools 2012.2 update.</span></span> <span data-ttu-id="1fb94-120">您可以安裝更新[此處](https://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=ASPDOTNETandWebTools2012_2)。</span><span class="sxs-lookup"><span data-stu-id="1fb94-120">You can install the update [here](https://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=ASPDOTNETandWebTools2012_2).</span></span>

<span data-ttu-id="1fb94-121">啟動 Visual Studio，然後選取**新的專案**從 [開始] 頁面。</span><span class="sxs-lookup"><span data-stu-id="1fb94-121">Start Visual Studio and select **New Project** from the Start page.</span></span> <span data-ttu-id="1fb94-122">或從**檔案**功能表上，選取**新增**，然後**專案**。</span><span class="sxs-lookup"><span data-stu-id="1fb94-122">Or, from the **File** menu, select **New** and then **Project**.</span></span>

<span data-ttu-id="1fb94-123">在 **範本**窗格中，選取**已安裝的範本**展開**Visual C#** 節點。</span><span class="sxs-lookup"><span data-stu-id="1fb94-123">In the **Templates** pane, select **Installed Templates** and expand the **Visual C#** node.</span></span> <span data-ttu-id="1fb94-124">底下**Visual C#**，選取**Web**。</span><span class="sxs-lookup"><span data-stu-id="1fb94-124">Under **Visual C#**, select **Web**.</span></span> <span data-ttu-id="1fb94-125">在專案範本清單中，選取**ASP.NET MVC 4 Web 應用程式**。</span><span class="sxs-lookup"><span data-stu-id="1fb94-125">In the list of project templates, select **ASP.NET MVC 4 Web Application**.</span></span> <span data-ttu-id="1fb94-126">將專案命名，然後按一下**確定**。</span><span class="sxs-lookup"><span data-stu-id="1fb94-126">Name the project and click **OK**.</span></span>

![](knockoutjs-template/_static/image2.png)

<span data-ttu-id="1fb94-127">在 **新的專案**精靈中，選取**單一頁面應用程式**。</span><span class="sxs-lookup"><span data-stu-id="1fb94-127">In the **New Project** wizard, select **Single Page Application**.</span></span>

![](knockoutjs-template/_static/image3.png)

<span data-ttu-id="1fb94-128">按 F5 鍵建置並執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="1fb94-128">Press F5 to build and run the application.</span></span> <span data-ttu-id="1fb94-129">當第一次執行應用程式時，它會顯示登入畫面。</span><span class="sxs-lookup"><span data-stu-id="1fb94-129">When the application first runs, it displays a login screen.</span></span>

![](knockoutjs-template/_static/image4.png)

<span data-ttu-id="1fb94-130">按一下 &quot;註冊&quot;連結，並建立新的使用者。</span><span class="sxs-lookup"><span data-stu-id="1fb94-130">Click the &quot;Sign up&quot; link and create a new user.</span></span>

![](knockoutjs-template/_static/image5.png)

<span data-ttu-id="1fb94-131">登入之後，應用程式會建立預設待辦事項清單與兩個項目。</span><span class="sxs-lookup"><span data-stu-id="1fb94-131">After you log in, the application creates a default Todo list with two items.</span></span> <span data-ttu-id="1fb94-132">您可以按一下 [新增待辦事項清單] 以新增新的清單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-132">You can click "Add Todo list" to add a new list.</span></span>

![](knockoutjs-template/_static/image6.png)

<span data-ttu-id="1fb94-133">重新命名清單、 將項目加入清單中，並取消選取這些工作。</span><span class="sxs-lookup"><span data-stu-id="1fb94-133">Rename the list, add items to the list, and check them off.</span></span> <span data-ttu-id="1fb94-134">您也可以刪除項目，或刪除整個清單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-134">You can also delete items or delete an entire list.</span></span> <span data-ttu-id="1fb94-135">所做的變更會自動保存至伺服器上的資料庫 (實際 LocalDB 到目前為止，因為您在本機執行應用程式)。</span><span class="sxs-lookup"><span data-stu-id="1fb94-135">The changes are automatically persisted to a database on the server (actually LocalDB at this point, because you are running the application locally).</span></span>

![](knockoutjs-template/_static/image7.png)

## <a name="architecture-of-the-spa-template"></a><span data-ttu-id="1fb94-136">SPA 範本的架構</span><span class="sxs-lookup"><span data-stu-id="1fb94-136">Architecture of the SPA Template</span></span>

<span data-ttu-id="1fb94-137">下圖顯示應用程式的主要建置組塊。</span><span class="sxs-lookup"><span data-stu-id="1fb94-137">This diagram shows the main building blocks for the application.</span></span>

![](knockoutjs-template/_static/image8.png)

<span data-ttu-id="1fb94-138">在伺服器端，ASP.NET MVC 提供 HTML，並也會處理表單型驗證。</span><span class="sxs-lookup"><span data-stu-id="1fb94-138">On the server side, ASP.NET MVC serves the HTML and also handles forms-based authentication.</span></span>

<span data-ttu-id="1fb94-139">ASP.NET Web API 會處理與 ToDoLists 和 ToDoItems，包括取得、 建立、 更新及刪除相關的所有要求。</span><span class="sxs-lookup"><span data-stu-id="1fb94-139">ASP.NET Web API handles all requests that relate to the ToDoLists and ToDoItems, including getting, creating, updating and deleting.</span></span> <span data-ttu-id="1fb94-140">用戶端會交換使用 Web API 以 JSON 格式的資料。</span><span class="sxs-lookup"><span data-stu-id="1fb94-140">The client exchanges data with Web API in JSON format.</span></span>

<span data-ttu-id="1fb94-141">Entity Framework (EF) 是 O/RM 層。</span><span class="sxs-lookup"><span data-stu-id="1fb94-141">Entity Framework (EF) is the O/RM layer.</span></span> <span data-ttu-id="1fb94-142">它會調解物件導向的世界的 ASP.NET 和基礎資料庫之間。</span><span class="sxs-lookup"><span data-stu-id="1fb94-142">It mediates between the object-oriented world of ASP.NET and the underlying database.</span></span> <span data-ttu-id="1fb94-143">資料庫使用 LocalDB，但您可以變更這個 Web.config 檔案中。</span><span class="sxs-lookup"><span data-stu-id="1fb94-143">The database uses LocalDB but you can change this in the Web.config file.</span></span> <span data-ttu-id="1fb94-144">通常您會使用 LocalDB，適用於本機開發，並接著部署至 SQL 資料庫的伺服器上，使用 EF code first 移轉。</span><span class="sxs-lookup"><span data-stu-id="1fb94-144">Typically you would use LocalDB for local development and then deploy to a SQL database on the server, using EF code-first migration.</span></span>

<span data-ttu-id="1fb94-145">在用戶端上，Knockout.js 程式庫會處理從 AJAX 要求的網頁更新。</span><span class="sxs-lookup"><span data-stu-id="1fb94-145">On the client side, the Knockout.js library handles page updates from AJAX requests.</span></span> <span data-ttu-id="1fb94-146">Knockout 與最新的資料同步處理頁面使用資料繫結。</span><span class="sxs-lookup"><span data-stu-id="1fb94-146">Knockout uses data binding to synchronize the page with the latest data.</span></span> <span data-ttu-id="1fb94-147">如此一來，您不需要撰寫任何程式碼，逐步解說的 JSON 資料，並更新 DOM</span><span class="sxs-lookup"><span data-stu-id="1fb94-147">That way, you don't have to write any of the code that walks through the JSON data and updates the DOM.</span></span> <span data-ttu-id="1fb94-148">相反地，您將宣告式屬性放在告訴 Knockout 如何將資料呈現的 HTML。</span><span class="sxs-lookup"><span data-stu-id="1fb94-148">Instead, you put declarative attributes in the HTML that tell Knockout how to present the data.</span></span>

<span data-ttu-id="1fb94-149">此架構中的一大優點是，它會區隔展示層與應用程式邏輯。</span><span class="sxs-lookup"><span data-stu-id="1fb94-149">A big advantage of this architecture is that it separates the presentation layer from the application logic.</span></span> <span data-ttu-id="1fb94-150">您可以建立的 Web API 的部分，而不需要知道任何關於您的網頁的外觀。</span><span class="sxs-lookup"><span data-stu-id="1fb94-150">You can create the Web API portion without knowing anything about how your web page will look.</span></span> <span data-ttu-id="1fb94-151">在用戶端，您必須建立 「 檢視模型 」 來表示該資料，並檢視模型使用 Knockout 繫結至 HTML。</span><span class="sxs-lookup"><span data-stu-id="1fb94-151">On the client side, you create a "view model" to represent that data, and the view model uses Knockout to bind to the HTML.</span></span> <span data-ttu-id="1fb94-152">可讓您輕鬆地變更 HTML，而不需要變更檢視模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-152">That lets you easily change the HTML without changing the view model.</span></span> <span data-ttu-id="1fb94-153">（我們將探討 Knockout 稍待片刻。）</span><span class="sxs-lookup"><span data-stu-id="1fb94-153">(We'll look at Knockout a bit later.)</span></span>

## <a name="models"></a><span data-ttu-id="1fb94-154">模型</span><span class="sxs-lookup"><span data-stu-id="1fb94-154">Models</span></span>

<span data-ttu-id="1fb94-155">在 Visual Studio 專案中，於 Models 資料夾會包含伺服器端所使用的模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-155">In the Visual Studio project, the Models folder contains the models that are used on the server side.</span></span> <span data-ttu-id="1fb94-156">（用戶端上還有模型，我們會）。</span><span class="sxs-lookup"><span data-stu-id="1fb94-156">(There are also models on the client side; we'll get to those.)</span></span>

![](knockoutjs-template/_static/image9.png)

<span data-ttu-id="1fb94-157">**TodoItem TodoList**</span><span class="sxs-lookup"><span data-stu-id="1fb94-157">**TodoItem, TodoList**</span></span>

<span data-ttu-id="1fb94-158">這些是 Entity Framework Code First 的資料庫模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-158">These are the database models for Entity Framework Code First.</span></span> <span data-ttu-id="1fb94-159">請注意，這些模型屬性，指向彼此。</span><span class="sxs-lookup"><span data-stu-id="1fb94-159">Notice that these models have properties that point to each other.</span></span> <span data-ttu-id="1fb94-160">`ToDoList` 包含的 ToDoItems，和每個集合`ToDoItem`ToDoList 其父代參考。</span><span class="sxs-lookup"><span data-stu-id="1fb94-160">`ToDoList` contains a collection of ToDoItems, and each `ToDoItem` has a reference back to its parent ToDoList.</span></span> <span data-ttu-id="1fb94-161">這些屬性稱為導覽屬性，以及它們在待辦事項清單，以及其待辦事項項目代表一個對多關聯性。</span><span class="sxs-lookup"><span data-stu-id="1fb94-161">These properties are called navigation properties, and they represent the one-to-many relation a to-do list and its to-do items.</span></span>

<span data-ttu-id="1fb94-162">`ToDoItem`類別也會使用 **[ForeignKey]** 屬性來指定`ToDoListId`為外部索引鍵到`ToDoList`資料表。</span><span class="sxs-lookup"><span data-stu-id="1fb94-162">The `ToDoItem` class also uses the **[ForeignKey]** attribute to specify that `ToDoListId` is a foreign key into the `ToDoList` table.</span></span> <span data-ttu-id="1fb94-163">這會告知 EF 來將外部索引鍵條件約束加入至資料庫。</span><span class="sxs-lookup"><span data-stu-id="1fb94-163">This tells EF to add a foreign-key constraint to the database.</span></span>

[!code-csharp[Main](knockoutjs-template/samples/sample1.cs)]

<span data-ttu-id="1fb94-164">**TodoItemDto TodoListDto**</span><span class="sxs-lookup"><span data-stu-id="1fb94-164">**TodoItemDto, TodoListDto**</span></span>

<span data-ttu-id="1fb94-165">這些類別會定義將會傳送至用戶端的資料。</span><span class="sxs-lookup"><span data-stu-id="1fb94-165">These classes define the data that will be sent to the client.</span></span> <span data-ttu-id="1fb94-166">"DTO"代表 「 資料傳輸物件 」。</span><span class="sxs-lookup"><span data-stu-id="1fb94-166">"DTO" stands for "data transfer object."</span></span> <span data-ttu-id="1fb94-167">DTO 會定義實體序列化為 JSON 的方式。</span><span class="sxs-lookup"><span data-stu-id="1fb94-167">The DTO defines how the entities will be serialized into JSON.</span></span> <span data-ttu-id="1fb94-168">一般情況下，有幾個原因會使用 Dto:</span><span class="sxs-lookup"><span data-stu-id="1fb94-168">In general, there are several reasons to use DTOs:</span></span>

- <span data-ttu-id="1fb94-169">若要控制序列化的屬性。</span><span class="sxs-lookup"><span data-stu-id="1fb94-169">To control which properties are serialized.</span></span> <span data-ttu-id="1fb94-170">DTO 可以包含從領域模型屬性的子集。</span><span class="sxs-lookup"><span data-stu-id="1fb94-170">The DTO can contain a subset of the properties from the domain model.</span></span> <span data-ttu-id="1fb94-171">您可能會基於安全性考量 （若要隱藏敏感資料），或只是執行這可減少您所傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="1fb94-171">You might do this for security reasons (to hide sensitive data) or simply to reduce the amount of data that you send.</span></span>
- <span data-ttu-id="1fb94-172">若要變更圖形的資料，例如壓平合併的更複雜的資料結構。</span><span class="sxs-lookup"><span data-stu-id="1fb94-172">To change the shape of the data – e.g. to flatten a more complex data structure.</span></span>
- <span data-ttu-id="1fb94-173">若要保留 DTO （關注點分離） 超出任何商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="1fb94-173">To keep any business logic out of the DTO (separation of concerns).</span></span>
- <span data-ttu-id="1fb94-174">如果基於某些原因，無法序列化您的網域模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-174">If your domain models cannot be serialized for some reason.</span></span> <span data-ttu-id="1fb94-175">比方說，循環參考可能會造成問題時您將有的物件的序列化方式來處理此問題，Web API 中的 (請參閱[處理循環物件參考](../../../web-api/overview/formats-and-model-binding/json-and-xml-serialization.md#handling_circular_object_references)); 但即可使用 DTO 完全避免此問題。</span><span class="sxs-lookup"><span data-stu-id="1fb94-175">For example, circular references can cause problems when you serialize an object There are ways to handle this problem in Web API (see [Handling Circular Object References](../../../web-api/overview/formats-and-model-binding/json-and-xml-serialization.md#handling_circular_object_references)); but using a DTO simply avoids the problem altogether.</span></span>

<span data-ttu-id="1fb94-176">SPA 範本，在 Dto 會包含與領域模型相同的資料。</span><span class="sxs-lookup"><span data-stu-id="1fb94-176">In the SPA template, the DTOs contains the same data as the domain models.</span></span> <span data-ttu-id="1fb94-177">不過，它們是仍然有用，因為它們避免循環參考導覽屬性，並示範一般的 DTO 模式。</span><span class="sxs-lookup"><span data-stu-id="1fb94-177">However, they are still useful because they avoid circular references from the navigation properties, and they demonstrate the general DTO pattern.</span></span>

<span data-ttu-id="1fb94-178">**AccountModels.cs**</span><span class="sxs-lookup"><span data-stu-id="1fb94-178">**AccountModels.cs**</span></span>

<span data-ttu-id="1fb94-179">此檔案包含模型的站台成員資格。</span><span class="sxs-lookup"><span data-stu-id="1fb94-179">This file contains models for site membership.</span></span> <span data-ttu-id="1fb94-180">`UserProfile`類別定義成員資格資料庫中的使用者設定檔的結構描述。</span><span class="sxs-lookup"><span data-stu-id="1fb94-180">The `UserProfile` class defines the schema for user profiles in the membership DB.</span></span> <span data-ttu-id="1fb94-181">（在此情況下，唯一的資訊是使用者識別碼和使用者名稱）。此檔案中的其他模型類別用來建立使用者註冊和登入表單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-181">(In this case, the only information is the user ID and the user name.) The other model classes in this file are used to create the user registration and login forms.</span></span>

## <a name="entity-framework"></a><span data-ttu-id="1fb94-182">Entity Framework</span><span class="sxs-lookup"><span data-stu-id="1fb94-182">Entity Framework</span></span>

<span data-ttu-id="1fb94-183">SPA 範本會使用 EF Code First。</span><span class="sxs-lookup"><span data-stu-id="1fb94-183">The SPA template uses EF Code First.</span></span> <span data-ttu-id="1fb94-184">在 Code First 開發中，您定義模型，第一次程式碼中，，然後 EF 使用模型來建立資料庫。</span><span class="sxs-lookup"><span data-stu-id="1fb94-184">In Code First development, you define the models first in code, and then EF uses the model to create the database.</span></span> <span data-ttu-id="1fb94-185">您也可以使用 EF 與現有的資料庫 ([Database First](https://msdn.microsoft.com/data/jj206878.aspx))。</span><span class="sxs-lookup"><span data-stu-id="1fb94-185">You can also use EF with an existing database ([Database First](https://msdn.microsoft.com/data/jj206878.aspx)).</span></span>

<span data-ttu-id="1fb94-186">`TodoItemContext` Models 資料夾中的類別衍生自**DbContext**。</span><span class="sxs-lookup"><span data-stu-id="1fb94-186">The `TodoItemContext` class in the Models folder derives from **DbContext**.</span></span> <span data-ttu-id="1fb94-187">這個類別會提供 「 黏附 」 模型與 EF 之間。</span><span class="sxs-lookup"><span data-stu-id="1fb94-187">This class provides the "glue" between the models and EF.</span></span> <span data-ttu-id="1fb94-188">`TodoItemContext`保存`ToDoItem`集合和`TodoList`集合。</span><span class="sxs-lookup"><span data-stu-id="1fb94-188">The `TodoItemContext` holds a `ToDoItem` collection and a `TodoList` collection.</span></span> <span data-ttu-id="1fb94-189">若要查詢資料庫，只要撰寫 LINQ 查詢，針對這些集合。</span><span class="sxs-lookup"><span data-stu-id="1fb94-189">To query the database, you simply write a LINQ query against these collections.</span></span> <span data-ttu-id="1fb94-190">例如，以下是選取所有的使用者"Alice"的待辦事項清單：</span><span class="sxs-lookup"><span data-stu-id="1fb94-190">For example, here is how you can select all of the to-do lists for user "Alice":</span></span>

[!code-csharp[Main](knockoutjs-template/samples/sample2.cs)]

<span data-ttu-id="1fb94-191">也可以將新的項目新增至集合、 更新項目，或從集合中，刪除項目和保存資料庫的變更。</span><span class="sxs-lookup"><span data-stu-id="1fb94-191">You can also add new items to the collection, update items, or delete items from the collection, and persist the changes to the database.</span></span>

## <a name="aspnet-web-api-controllers"></a><span data-ttu-id="1fb94-192">ASP.NET Web API 控制器</span><span class="sxs-lookup"><span data-stu-id="1fb94-192">ASP.NET Web API Controllers</span></span>

<span data-ttu-id="1fb94-193">在 ASP.NET Web API 中，控制器是處理 HTTP 要求的物件。</span><span class="sxs-lookup"><span data-stu-id="1fb94-193">In ASP.NET Web API, controllers are objects that handle HTTP requests.</span></span> <span data-ttu-id="1fb94-194">如前所述，SPA 範本就會使用 Web API，讓上的 CRUD 作業`ToDoList`和`ToDoItem`執行個體。</span><span class="sxs-lookup"><span data-stu-id="1fb94-194">As mentioned, the SPA template uses Web API to enable CRUD operations on `ToDoList` and `ToDoItem` instances.</span></span> <span data-ttu-id="1fb94-195">在 Controllers 資料夾中的方案位於控制器。</span><span class="sxs-lookup"><span data-stu-id="1fb94-195">The controllers are located in the Controllers folder of the solution.</span></span>

![](knockoutjs-template/_static/image10.png)

- <span data-ttu-id="1fb94-196">`TodoController`： 用來處理 HTTP 要求的待辦事項項目</span><span class="sxs-lookup"><span data-stu-id="1fb94-196">`TodoController`: Handles HTTP requests for to-do items</span></span>
- <span data-ttu-id="1fb94-197">`TodoListController`： 會處理 HTTP 要求的待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-197">`TodoListController`: Handles HTTP requests for to-do lists.</span></span>

<span data-ttu-id="1fb94-198">因為 Web API 符合控制器名稱的 URI 路徑，是有意義的這些名稱。</span><span class="sxs-lookup"><span data-stu-id="1fb94-198">These names are significant, because Web API matches the URI path to the controller name.</span></span> <span data-ttu-id="1fb94-199">(若要深入了解 Web API 將 HTTP 要求路由至控制器的方式，請參閱[ASP.NET Web API 中的路由](../../../web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api.md)。)</span><span class="sxs-lookup"><span data-stu-id="1fb94-199">(To learn how Web API routes HTTP requests to controllers, see [Routing in ASP.NET Web API](../../../web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api.md).)</span></span>

<span data-ttu-id="1fb94-200">讓我們看看`ToDoListController`類別。</span><span class="sxs-lookup"><span data-stu-id="1fb94-200">Let's look at the `ToDoListController` class.</span></span> <span data-ttu-id="1fb94-201">它包含一個單一的資料成員：</span><span class="sxs-lookup"><span data-stu-id="1fb94-201">It contains a single data member:</span></span>

[!code-csharp[Main](knockoutjs-template/samples/sample3.cs)]

<span data-ttu-id="1fb94-202">`TodoItemContext`用來與 EF，通訊中，如先前所述。</span><span class="sxs-lookup"><span data-stu-id="1fb94-202">The `TodoItemContext` is used to communicate with EF, as described earlier.</span></span> <span data-ttu-id="1fb94-203">在控制器上的方法實作的 CRUD 作業。</span><span class="sxs-lookup"><span data-stu-id="1fb94-203">The methods on the controller implement the CRUD operations.</span></span> <span data-ttu-id="1fb94-204">Web API 會對應至控制器方法，從用戶端的 HTTP 要求，如下所示：</span><span class="sxs-lookup"><span data-stu-id="1fb94-204">Web API maps HTTP requests from the client to controller methods, as follows:</span></span>

| <span data-ttu-id="1fb94-205">HTTP 要求</span><span class="sxs-lookup"><span data-stu-id="1fb94-205">HTTP Request</span></span> | <span data-ttu-id="1fb94-206">控制器方法</span><span class="sxs-lookup"><span data-stu-id="1fb94-206">Controller Method</span></span> | <span data-ttu-id="1fb94-207">描述</span><span class="sxs-lookup"><span data-stu-id="1fb94-207">Description</span></span> |
| --- | --- | --- |
| <span data-ttu-id="1fb94-208">GET /api/todo</span><span class="sxs-lookup"><span data-stu-id="1fb94-208">GET /api/todo</span></span> | `GetTodoLists` | <span data-ttu-id="1fb94-209">取得待辦事項清單的集合。</span><span class="sxs-lookup"><span data-stu-id="1fb94-209">Gets a collection of to-do lists.</span></span> |
| <span data-ttu-id="1fb94-210">取得/api/todo/*識別碼*</span><span class="sxs-lookup"><span data-stu-id="1fb94-210">GET /api/todo/*id*</span></span> | `GetTodoList` | <span data-ttu-id="1fb94-211">取得待辦事項清單識別碼</span><span class="sxs-lookup"><span data-stu-id="1fb94-211">Gets a to-do list by ID</span></span> |
| <span data-ttu-id="1fb94-212">PUT/api/todo/*識別碼*</span><span class="sxs-lookup"><span data-stu-id="1fb94-212">PUT /api/todo/*id*</span></span> | `PutTodoList` | <span data-ttu-id="1fb94-213">更新待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-213">Updates a to-do list.</span></span> |
| <span data-ttu-id="1fb94-214">POST /api/todo</span><span class="sxs-lookup"><span data-stu-id="1fb94-214">POST /api/todo</span></span> | `PostTodoList` | <span data-ttu-id="1fb94-215">建立新的待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-215">Creates a new to-do list.</span></span> |
| <span data-ttu-id="1fb94-216">刪除/api/todo/*識別碼*</span><span class="sxs-lookup"><span data-stu-id="1fb94-216">DELETE /api/todo/*id*</span></span> | `DeleteTodoList` | <span data-ttu-id="1fb94-217">刪除待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-217">Deletes a TODO list.</span></span> |

<span data-ttu-id="1fb94-218">請注意，某些作業的 Uri 包含的識別碼值的預留位置。</span><span class="sxs-lookup"><span data-stu-id="1fb94-218">Notice that the URIs for some operations contain placeholders for the ID value.</span></span> <span data-ttu-id="1fb94-219">例如，若要刪除以清單識別碼為 42，URI 是`/api/todo/42`。</span><span class="sxs-lookup"><span data-stu-id="1fb94-219">For example, to delete a to-list with an ID of 42, the URI is `/api/todo/42`.</span></span>

<span data-ttu-id="1fb94-220">若要深入了解使用 Web API 的 CRUD 作業，請參閱[建立 Web API 的支援 CRUD 作業](../../../web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="1fb94-220">To learn more about using Web API for CRUD operations, see [Creating a Web API that Supports CRUD Operations](../../../web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations.md).</span></span> <span data-ttu-id="1fb94-221">此控制器的程式碼就相當簡單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-221">The code for this controller is fairly straightforward.</span></span> <span data-ttu-id="1fb94-222">以下是一些有趣的要點：</span><span class="sxs-lookup"><span data-stu-id="1fb94-222">Here are some interesting points:</span></span>

- <span data-ttu-id="1fb94-223">`GetTodoLists`方法使用 LINQ 查詢來篩選結果的識別碼的登入的使用者。</span><span class="sxs-lookup"><span data-stu-id="1fb94-223">The `GetTodoLists` method uses a LINQ query to filter the results by the ID of the logged-in user.</span></span> <span data-ttu-id="1fb94-224">如此一來，使用者只能看到屬於他或她的資料。</span><span class="sxs-lookup"><span data-stu-id="1fb94-224">That way, a user only sees the data that belongs to him or her.</span></span> <span data-ttu-id="1fb94-225">另外，請注意，Select 陳述式用來轉換`ToDoList`執行個體到`TodoListDto`執行個體。</span><span class="sxs-lookup"><span data-stu-id="1fb94-225">Also, notice that a Select statement is used to convert the `ToDoList` instances into `TodoListDto` instances.</span></span>
- <span data-ttu-id="1fb94-226">PUT 和 POST 方法會檢查之前修改資料庫的模型狀態。</span><span class="sxs-lookup"><span data-stu-id="1fb94-226">The PUT and POST methods check the model state before modifying the database.</span></span> <span data-ttu-id="1fb94-227">如果**ModelState.IsValid**為 false，這些方法會傳回 HTTP 400 不正確的要求。</span><span class="sxs-lookup"><span data-stu-id="1fb94-227">If **ModelState.IsValid** is false, these methods return HTTP 400, Bad Request.</span></span> <span data-ttu-id="1fb94-228">深入了解在 Web API 中的模型驗證[模型驗證](../../../web-api/overview/formats-and-model-binding/model-validation-in-aspnet-web-api.md)。</span><span class="sxs-lookup"><span data-stu-id="1fb94-228">Read more about model validation in Web API at [Model Validation](../../../web-api/overview/formats-and-model-binding/model-validation-in-aspnet-web-api.md).</span></span>
- <span data-ttu-id="1fb94-229">控制器類別也附有 **[Authorize]** 屬性。</span><span class="sxs-lookup"><span data-stu-id="1fb94-229">The controller class is also decorated with the **[Authorize]** attribute.</span></span> <span data-ttu-id="1fb94-230">這個屬性會檢查是否已驗證的 HTTP 要求。</span><span class="sxs-lookup"><span data-stu-id="1fb94-230">This attribute checks whether the HTTP request is authenticated.</span></span> <span data-ttu-id="1fb94-231">如果要求未經過驗證，用戶端收到 HTTP 401 未經授權。</span><span class="sxs-lookup"><span data-stu-id="1fb94-231">If the request is not authenticated, the client receives HTTP 401, Unauthorized.</span></span> <span data-ttu-id="1fb94-232">深入了解在驗證[ASP.NET Web API 中驗證和授權](../../../web-api/overview/security/authentication-and-authorization-in-aspnet-web-api.md)。</span><span class="sxs-lookup"><span data-stu-id="1fb94-232">Read more about authentication at [Authentication and Authorization in ASP.NET Web API](../../../web-api/overview/security/authentication-and-authorization-in-aspnet-web-api.md).</span></span>

<span data-ttu-id="1fb94-233">`TodoController`類別是非常類似於`TodoListController`。</span><span class="sxs-lookup"><span data-stu-id="1fb94-233">The `TodoController` class is very similar to `TodoListController`.</span></span> <span data-ttu-id="1fb94-234">最大的差異是，它並未定義任何的 GET 方法，因為用戶端會取得待辦事項項目，以及每個待辦事項清單。</span><span class="sxs-lookup"><span data-stu-id="1fb94-234">The biggest difference is that it does not define any GET methods, because the client will get the to-do items along with each to-do list.</span></span>

## <a name="mvc-controllers-and-views"></a><span data-ttu-id="1fb94-235">MVC 控制器和檢視</span><span class="sxs-lookup"><span data-stu-id="1fb94-235">MVC Controllers and Views</span></span>

<span data-ttu-id="1fb94-236">MVC 控制站也位於 [控制器] 資料夾的解決方案。</span><span class="sxs-lookup"><span data-stu-id="1fb94-236">The MVC controllers are also located in the Controllers folder of the solution.</span></span> <span data-ttu-id="1fb94-237">`HomeController` 應用程式的主要 HTML 呈現。</span><span class="sxs-lookup"><span data-stu-id="1fb94-237">`HomeController` renders the main HTML for the application.</span></span> <span data-ttu-id="1fb94-238">主控制器的檢視被定義在 Views/Home/Index.cshtml。</span><span class="sxs-lookup"><span data-stu-id="1fb94-238">The view for the Home controller is defined in Views/Home/Index.cshtml.</span></span> <span data-ttu-id="1fb94-239">[首頁] 檢視會呈現不同的內容，根據使用者是否登入：</span><span class="sxs-lookup"><span data-stu-id="1fb94-239">The Home view renders different content depending on whether the user is logged in:</span></span>

[!code-cshtml[Main](knockoutjs-template/samples/sample4.cshtml)]

<span data-ttu-id="1fb94-240">當使用者登入時，他們會看到主要的 UI。</span><span class="sxs-lookup"><span data-stu-id="1fb94-240">When users are logged in, they see the main UI.</span></span> <span data-ttu-id="1fb94-241">否則，他們會看到登入面板。</span><span class="sxs-lookup"><span data-stu-id="1fb94-241">Otherwise, they see the login panel.</span></span> <span data-ttu-id="1fb94-242">請注意，此條件式呈現的作業會在伺服器端。</span><span class="sxs-lookup"><span data-stu-id="1fb94-242">Note that this conditional rendering happens on the server side.</span></span> <span data-ttu-id="1fb94-243">永遠不會嘗試隱藏用戶端上的機密內容 & #8212anything 您傳送 HTTP 回應中會顯示為監看的未經處理的 HTTP 訊息的任何人。</span><span class="sxs-lookup"><span data-stu-id="1fb94-243">Never try to hide sensitive content on the client side&#8212anything that you send in an HTTP response is visible to someone who is watching the raw HTTP messages.</span></span>

## <a name="client-side-javascript-and-knockoutjs"></a><span data-ttu-id="1fb94-244">用戶端 JavaScript 和 Knockout.js</span><span class="sxs-lookup"><span data-stu-id="1fb94-244">Client-Side JavaScript and Knockout.js</span></span>

<span data-ttu-id="1fb94-245">現在讓我們將從用戶端應用程式的伺服器端。</span><span class="sxs-lookup"><span data-stu-id="1fb94-245">Now let's turn from the server side of the application to the client.</span></span> <span data-ttu-id="1fb94-246">SPA 範本會使用 jQuery 和 Knockout.js 的組合，來建立平滑的互動式 UI。</span><span class="sxs-lookup"><span data-stu-id="1fb94-246">The SPA template uses a combination of jQuery and Knockout.js to create a smooth, interactive UI.</span></span> <span data-ttu-id="1fb94-247">Knockout.js 是 JavaScript 程式庫，可讓您輕鬆地繫結至資料的 HTML。</span><span class="sxs-lookup"><span data-stu-id="1fb94-247">Knockout.js is a JavaScript library that makes it easy to bind HTML to data.</span></span> <span data-ttu-id="1fb94-248">Knockout.js 使用模式，稱為 「 模型-檢視-ViewModel。 」</span><span class="sxs-lookup"><span data-stu-id="1fb94-248">Knockout.js uses a pattern called "Model-View-ViewModel."</span></span>

- <span data-ttu-id="1fb94-249">此模型是網域有更多的資料 （「 待辦事項清單 」 和 「 待辦事項項目 」）。</span><span class="sxs-lookup"><span data-stu-id="1fb94-249">The model is the domain data (ToDo lists and ToDo items).</span></span>
- <span data-ttu-id="1fb94-250">HTML 文件的檢視。</span><span class="sxs-lookup"><span data-stu-id="1fb94-250">The view is the HTML document.</span></span>
- <span data-ttu-id="1fb94-251">檢視模型是可儲存模型資料的 JavaScript 物件。</span><span class="sxs-lookup"><span data-stu-id="1fb94-251">The view-model is a JavaScript object that holds the model data.</span></span> <span data-ttu-id="1fb94-252">檢視模型是程式碼的抽象概念的 UI。</span><span class="sxs-lookup"><span data-stu-id="1fb94-252">The view-model is a code abstraction of the UI.</span></span> <span data-ttu-id="1fb94-253">它並不知道 HTML 的表示法。</span><span class="sxs-lookup"><span data-stu-id="1fb94-253">It has no knowledge of the HTML representation.</span></span> <span data-ttu-id="1fb94-254">相反地，它代表檢視，例如 「 的待辦事項清單 」 的抽象功能。</span><span class="sxs-lookup"><span data-stu-id="1fb94-254">Instead, it represents abstract features of the view, such as "a list of ToDo items".</span></span>

<span data-ttu-id="1fb94-255">檢視是資料繫結至檢視模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-255">The view is data-bound to the view-model.</span></span> <span data-ttu-id="1fb94-256">檢視模型的更新會自動反映在檢視中。</span><span class="sxs-lookup"><span data-stu-id="1fb94-256">Updates to the view-model are automatically reflected in the view.</span></span> <span data-ttu-id="1fb94-257">繫結的另一種方式運作。</span><span class="sxs-lookup"><span data-stu-id="1fb94-257">Bindings work the other direction as well.</span></span> <span data-ttu-id="1fb94-258">（例如按一下） 在 DOM 中的事件是資料繫結至函式檢視模型中，在觸發 AJAX 呼叫。</span><span class="sxs-lookup"><span data-stu-id="1fb94-258">Events in the DOM (such as clicks) are data-bound to functions on the view model, which trigger AJAX calls.</span></span>

<span data-ttu-id="1fb94-259">SPA 範本會將用戶端 JavaScript 組織成三個層級：</span><span class="sxs-lookup"><span data-stu-id="1fb94-259">The SPA template organizes the client-side JavaScript into three layers:</span></span>

- <span data-ttu-id="1fb94-260">todo.datacontext.js： 傳送 AJAX 要求。</span><span class="sxs-lookup"><span data-stu-id="1fb94-260">todo.datacontext.js: Sends AJAX requests.</span></span>
- <span data-ttu-id="1fb94-261">todo.model.js： 定義模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-261">todo.model.js: Defines the models.</span></span>
- <span data-ttu-id="1fb94-262">todo.viewmodel.js： 定義檢視模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-262">todo.viewmodel.js: Defines the view model.</span></span>

![](knockoutjs-template/_static/image11.png)

<span data-ttu-id="1fb94-263">這些指令碼檔案位於方案的指令碼/應用程式資料夾中。</span><span class="sxs-lookup"><span data-stu-id="1fb94-263">These script files are located in the Scripts/app folder of the solution.</span></span>

![](knockoutjs-template/_static/image12.png)

<span data-ttu-id="1fb94-264">**todo.datacontext**會處理所有的 AJAX 呼叫至 Web API 控制器。</span><span class="sxs-lookup"><span data-stu-id="1fb94-264">**todo.datacontext** handles all AJAX calls to the Web API controllers.</span></span> <span data-ttu-id="1fb94-265">（登入的 AJAX 呼叫會定義其他地方，ajaxlogin.js 中）。</span><span class="sxs-lookup"><span data-stu-id="1fb94-265">(The AJAX calls for logging in are defined elsewhere, in ajaxlogin.js.)</span></span>

<span data-ttu-id="1fb94-266">**todo.model.js**定義待辦事項清單的用戶端 （瀏覽器） 模型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-266">**todo.model.js** defines the client-side (browser) models for the to-do lists.</span></span> <span data-ttu-id="1fb94-267">有兩個模型類別： todoItem 和 todoList。</span><span class="sxs-lookup"><span data-stu-id="1fb94-267">There are two model classes: todoItem and todoList.</span></span>

<span data-ttu-id="1fb94-268">許多模型類別中的屬性都屬於類型"ko.observable 」。</span><span class="sxs-lookup"><span data-stu-id="1fb94-268">Many of the properties in the model classes are of type "ko.observable".</span></span> <span data-ttu-id="1fb94-269">可預見值都是 Knockout 發揮它的運作方式。</span><span class="sxs-lookup"><span data-stu-id="1fb94-269">Observables are how Knockout does its magic.</span></span> <span data-ttu-id="1fb94-270">從[Knockout 文件](http://knockoutjs.com/documentation/introduction.html)： 可預見值會是 「 JavaScript 物件，可通知有關變更的訂閱者 」。</span><span class="sxs-lookup"><span data-stu-id="1fb94-270">From the [Knockout documentation](http://knockoutjs.com/documentation/introduction.html): An observable is a "JavaScript object that can notify subscribers about changes."</span></span> <span data-ttu-id="1fb94-271">當可預見值的值變更時，Knockout 會更新繫結至這些可預見值的任何 HTML 項目。</span><span class="sxs-lookup"><span data-stu-id="1fb94-271">When the value of an observable changes, Knockout updates any HTML elements that are bound to those observables.</span></span> <span data-ttu-id="1fb94-272">比方說，todoItem 具有可預見值的標題] 和 [作業屬性：</span><span class="sxs-lookup"><span data-stu-id="1fb94-272">For example, todoItem has observables for the title and isDone properties:</span></span>

[!code-javascript[Main](knockoutjs-template/samples/sample5.js)]

<span data-ttu-id="1fb94-273">您也可以訂閱程式碼中的可預見值。</span><span class="sxs-lookup"><span data-stu-id="1fb94-273">You can also subscribe to an observable in code.</span></span> <span data-ttu-id="1fb94-274">比方說，todoItem 類別訂閱中的 「 作業 」 和 「 title 」 屬性的變更：</span><span class="sxs-lookup"><span data-stu-id="1fb94-274">For example, the todoItem class subscribes to changes in the "isDone" and "title" properties:</span></span>

[!code-javascript[Main](knockoutjs-template/samples/sample6.js)]

<span data-ttu-id="1fb94-275">**檢視模型**</span><span class="sxs-lookup"><span data-stu-id="1fb94-275">**View Model**</span></span>

<span data-ttu-id="1fb94-276">檢視模型被定義在 todo.viewmodel.js。</span><span class="sxs-lookup"><span data-stu-id="1fb94-276">The view model is defined in todo.viewmodel.js.</span></span> <span data-ttu-id="1fb94-277">檢視模型是其中的應用程式會將繫結的 HTML 網頁項目網域資料的中央點。</span><span class="sxs-lookup"><span data-stu-id="1fb94-277">The view model is the central point where the application binds the HTML page elements to the domain data.</span></span> <span data-ttu-id="1fb94-278">SPA 範本，在檢視模型會包含可觀察的 todoLists 陣列。</span><span class="sxs-lookup"><span data-stu-id="1fb94-278">In the SPA template, the view model contains an observable array of todoLists.</span></span> <span data-ttu-id="1fb94-279">檢視模型中的下列程式碼會告訴 Knockout 套用繫結：</span><span class="sxs-lookup"><span data-stu-id="1fb94-279">The following code in the view model tells Knockout to apply the bindings:</span></span>

[!code-javascript[Main](knockoutjs-template/samples/sample7.js)]

## <a name="html-and-data-binding"></a><span data-ttu-id="1fb94-280">HTML 和資料繫結</span><span class="sxs-lookup"><span data-stu-id="1fb94-280">HTML and Data Binding</span></span>

<span data-ttu-id="1fb94-281">主要的 HTML 頁面被定義在 Views/Home/Index.cshtml。</span><span class="sxs-lookup"><span data-stu-id="1fb94-281">The main HTML for the page is defined in Views/Home/Index.cshtml.</span></span> <span data-ttu-id="1fb94-282">因為我們使用資料繫結，HTML 只是一個樣板的項目實際呈現。</span><span class="sxs-lookup"><span data-stu-id="1fb94-282">Because we are using data-binding, the HTML is only a template for what actually gets rendered.</span></span> <span data-ttu-id="1fb94-283">使用 knockout*宣告式*繫結。</span><span class="sxs-lookup"><span data-stu-id="1fb94-283">Knockout uses *declarative* bindings.</span></span> <span data-ttu-id="1fb94-284">藉由將項目中的 「 資料繫結 」 屬性，將頁面項目的資料繫結。</span><span class="sxs-lookup"><span data-stu-id="1fb94-284">You bind page elements to data by adding a "data-bind" attribute to the element.</span></span> <span data-ttu-id="1fb94-285">以下是一個非常簡單的範例，取自 Knockout 文件：</span><span class="sxs-lookup"><span data-stu-id="1fb94-285">Here is a very simple example, taken from the Knockout documentation:</span></span>

[!code-html[Main](knockoutjs-template/samples/sample8.html)]

<span data-ttu-id="1fb94-286">在此範例中，Knockout 更新的內容**&lt;跨越&gt;** 的值的項目`myItems.count()`。</span><span class="sxs-lookup"><span data-stu-id="1fb94-286">In this example, Knockout updates the contents of the **&lt;span&gt;** element with the value of `myItems.count()`.</span></span> <span data-ttu-id="1fb94-287">此值變更時，每當 Knockout 更新的文件。</span><span class="sxs-lookup"><span data-stu-id="1fb94-287">Whenever this value changes, Knockout updates the document.</span></span>

<span data-ttu-id="1fb94-288">油墨廓清提供數種不同的繫結類型。</span><span class="sxs-lookup"><span data-stu-id="1fb94-288">Knockout provides a number of different binding types.</span></span> <span data-ttu-id="1fb94-289">以下是一些使用 SPA 範本中的繫結：</span><span class="sxs-lookup"><span data-stu-id="1fb94-289">Here are some of the bindings used in the SPA template:</span></span>

- <span data-ttu-id="1fb94-290">**foreach**： 可讓您透過迴圈逐一查看並套用相同的標記清單中的每個項目。</span><span class="sxs-lookup"><span data-stu-id="1fb94-290">**foreach**: Lets you iterate through a loop and apply the same markup to each item in the list.</span></span> <span data-ttu-id="1fb94-291">這用來呈現的待辦事項清單 」 和 「 待辦事項項目。</span><span class="sxs-lookup"><span data-stu-id="1fb94-291">This is used to render the to-do lists and to-do items.</span></span> <span data-ttu-id="1fb94-292">內**foreach**，繫結會套用至清單的項目。</span><span class="sxs-lookup"><span data-stu-id="1fb94-292">Within the **foreach**, the bindings are applied to the elements of the list.</span></span>
- <span data-ttu-id="1fb94-293">**可見**： 用來切換可見性。</span><span class="sxs-lookup"><span data-stu-id="1fb94-293">**visible**: Used to toggle visibility.</span></span> <span data-ttu-id="1fb94-294">當集合是空的、 隱藏的標記，或顯示錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="1fb94-294">Hide markup when a collection is empty, or make the error message visible.</span></span>
- <span data-ttu-id="1fb94-295">**值**： 用來填入表單值。</span><span class="sxs-lookup"><span data-stu-id="1fb94-295">**value**: Used to populate form values.</span></span>
- <span data-ttu-id="1fb94-296">**按一下 **： 將 click 事件繫結至檢視模型中的函式。</span><span class="sxs-lookup"><span data-stu-id="1fb94-296">**click**: Binds a click event to a function on the view model.</span></span>

## <a name="anti-csrf-protection"></a><span data-ttu-id="1fb94-297">防 CSRF 防護</span><span class="sxs-lookup"><span data-stu-id="1fb94-297">Anti-CSRF Protection</span></span>

<span data-ttu-id="1fb94-298">跨站台要求偽造 (CSRF) 攻擊會將惡意網站傳送要求給使用者目前登入的有弱點網站的位置。</span><span class="sxs-lookup"><span data-stu-id="1fb94-298">Cross-Site Request Forgery (CSRF) is an attack where a malicious site sends a request to a vulnerable site where the user is currently logged in.</span></span> <span data-ttu-id="1fb94-299">為了協助防止 CSRF 攻擊，使用 ASP.NET MVC*防偽語彙基元*，也稱為要求驗證權杖。</span><span class="sxs-lookup"><span data-stu-id="1fb94-299">To help prevent CSRF attacks, ASP.NET MVC uses *anti-forgery tokens*, also called request verification tokens.</span></span> <span data-ttu-id="1fb94-300">其概念是，伺服器會將隨機產生的語彙基元放入網頁。</span><span class="sxs-lookup"><span data-stu-id="1fb94-300">The idea is that the server puts a randomly generated token into a web page.</span></span> <span data-ttu-id="1fb94-301">當用戶端提交資料給伺服器時，必須在要求訊息中包含此值。</span><span class="sxs-lookup"><span data-stu-id="1fb94-301">When the client submits data to the server, it must include this value in the request message.</span></span>

<span data-ttu-id="1fb94-302">防偽語彙基元運作，因為惡意的頁面無法讀取使用者的權杖，因為同源原則。</span><span class="sxs-lookup"><span data-stu-id="1fb94-302">Anti-forgery tokens work because the malicious page cannot read the user's tokens, due to same-origin policies.</span></span> <span data-ttu-id="1fb94-303">（同源原則會防止存取彼此的內容的兩個不同站台上裝載的文件）。</span><span class="sxs-lookup"><span data-stu-id="1fb94-303">(Same-origin policies prevent documents hosted on two different sites from accessing each other's content.)</span></span>

<span data-ttu-id="1fb94-304">ASP.NET MVC 提供防偽語彙基元，內建支援，透過[AntiForgery](https://msdn.microsoft.com/library/system.web.helpers.antiforgery.aspx)類別和[[ValidateAntiForgeryToken]](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute.aspx)屬性。</span><span class="sxs-lookup"><span data-stu-id="1fb94-304">ASP.NET MVC provides built-in support for anti-forgery tokens, through the [AntiForgery](https://msdn.microsoft.com/library/system.web.helpers.antiforgery.aspx) class and the [[ValidateAntiForgeryToken]](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute.aspx) attribute.</span></span> <span data-ttu-id="1fb94-305">目前，這項功能不會建置到 Web API。</span><span class="sxs-lookup"><span data-stu-id="1fb94-305">Currently, this functionality is not built into Web API.</span></span> <span data-ttu-id="1fb94-306">不過，SPA 範本包含 Web API 的自訂實作。</span><span class="sxs-lookup"><span data-stu-id="1fb94-306">However, the SPA template includes a custom implementation for Web API.</span></span> <span data-ttu-id="1fb94-307">此程式碼定義於`ValidateHttpAntiForgeryTokenAttribute`解決方案的 [篩選器] 資料夾中的類別。</span><span class="sxs-lookup"><span data-stu-id="1fb94-307">This code is defined in the `ValidateHttpAntiForgeryTokenAttribute` class, which is located in the Filters folder of the solution.</span></span> <span data-ttu-id="1fb94-308">若要深入了解防 CSRF Web API 中，請參閱[防止跨網站要求偽造 （csrf） 等攻擊的攻擊](../../../web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks.md)。</span><span class="sxs-lookup"><span data-stu-id="1fb94-308">To learn more about anti-CSRF in Web API, see [Preventing Cross-Site Request Forgery (CSRF) Attacks](../../../web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks.md).</span></span>

## <a name="conclusion"></a><span data-ttu-id="1fb94-309">結論</span><span class="sxs-lookup"><span data-stu-id="1fb94-309">Conclusion</span></span>

<span data-ttu-id="1fb94-310">SPA 範本可協助您開始快速地撰寫現代化、 互動式 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="1fb94-310">The SPA template is designed to get you started quickly writing modern, interactive web applications.</span></span> <span data-ttu-id="1fb94-311">它會使用 Knockout.js 文件庫不同的簡報 （HTML 標記） 的資料和應用程式邏輯。</span><span class="sxs-lookup"><span data-stu-id="1fb94-311">It uses the Knockout.js library to separate presentation (HTML markup) from the data and application logic.</span></span> <span data-ttu-id="1fb94-312">但 Knockout 不是唯一可用來建立 SPA 的 JavaScript 程式庫。</span><span class="sxs-lookup"><span data-stu-id="1fb94-312">But Knockout is not the only JavaScript library you can use to create a SPA.</span></span> <span data-ttu-id="1fb94-313">如果您想要探索一些其他選項，看看[社群建立 SPA 範本](../templates/index.md)。</span><span class="sxs-lookup"><span data-stu-id="1fb94-313">If you want to explore some other options, take a look at the [community-created SPA templates](../templates/index.md).</span></span>
