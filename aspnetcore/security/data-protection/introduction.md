---
title: ASP.NET Core 資料保護
author: rick-anderson
description: 了解資料保護的概念和 ASP.NET Core 資料保護 Api 的設計原則。
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
uid: security/data-protection/introduction
ms.openlocfilehash: 37f170a3e8a46ef2215b0999358d46dd402636df
ms.sourcegitcommit: 5b0eca8c21550f95de3bb21096bd4fd4d9098026
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/27/2019
ms.locfileid: "64897985"
---
# <a name="aspnet-core-data-protection"></a><span data-ttu-id="80b47-103">ASP.NET Core 資料保護</span><span class="sxs-lookup"><span data-stu-id="80b47-103">ASP.NET Core Data Protection</span></span>

<span data-ttu-id="80b47-104">Web 應用程式通常需要將機密資料。</span><span class="sxs-lookup"><span data-stu-id="80b47-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="80b47-105">Windows 桌面應用程式提供 DPAPI，但這並不適用於 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="80b47-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="80b47-106">ASP.NET Core 資料保護堆疊提供開發人員可用來保護資料，包括金鑰管理與輪替簡單、 容易使用的密碼編譯 API。</span><span class="sxs-lookup"><span data-stu-id="80b47-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="80b47-107">ASP.NET Core 資料保護堆疊旨在做為長期取代&lt;machineKey&gt;項目在 ASP.NET 1.x-4.x。</span><span class="sxs-lookup"><span data-stu-id="80b47-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the &lt;machineKey&gt; element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="80b47-108">它的設計目標包括許多舊的密碼編譯堆疊的缺點時用於大部分的現代應用程式可能會遇到的使用案例中提供的立即可用的解決方案。</span><span class="sxs-lookup"><span data-stu-id="80b47-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="80b47-109">問題陳述</span><span class="sxs-lookup"><span data-stu-id="80b47-109">Problem statement</span></span>

<span data-ttu-id="80b47-110">可以在中的單一句子簡潔所述的整體問題陳述式：我需要保存值得信賴的資訊供日後擷取，但我並不信任的持續性機制。</span><span class="sxs-lookup"><span data-stu-id="80b47-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I don't trust the persistence mechanism.</span></span> <span data-ttu-id="80b47-111">Web 而言，這可能會寫入 「 我需要反覆存取受信任的狀態，透過不受信任的用戶端 」。</span><span class="sxs-lookup"><span data-stu-id="80b47-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="80b47-112">標準範例就是驗證 cookie 或持有人權杖。</span><span class="sxs-lookup"><span data-stu-id="80b47-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="80b47-113">伺服器會產生 「 我是 Groot 和 xyz 使用權限 」 權杖，並將它交付給用戶端。</span><span class="sxs-lookup"><span data-stu-id="80b47-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="80b47-114">在未來的某個日期，用戶端會出示該權杖至伺服器，但伺服器需要某種形式的用戶端尚未偽造語彙基元的保證。</span><span class="sxs-lookup"><span data-stu-id="80b47-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="80b47-115">因此第一項需求： 真確性 （也稱為</span><span class="sxs-lookup"><span data-stu-id="80b47-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="80b47-116">完整性、 竄改）。</span><span class="sxs-lookup"><span data-stu-id="80b47-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="80b47-117">伺服器信任保存的狀態，因為我們預期這個狀態可能包含作業系統的環境特有的資訊。</span><span class="sxs-lookup"><span data-stu-id="80b47-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that's specific to the operating environment.</span></span> <span data-ttu-id="80b47-118">這可能是在表單的檔案路徑、 權限，控制代碼或其他的間接參考或某些其他伺服器特定資料片段。</span><span class="sxs-lookup"><span data-stu-id="80b47-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="80b47-119">這類資訊通常不應公開至不受信任的用戶端。</span><span class="sxs-lookup"><span data-stu-id="80b47-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="80b47-120">因此第二個需求： 機密性。</span><span class="sxs-lookup"><span data-stu-id="80b47-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="80b47-121">最後，由於元件化的現代化應用程式，我們已了解是個別的元件會想要利用此系統，而不考慮其他元件的系統中。</span><span class="sxs-lookup"><span data-stu-id="80b47-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="80b47-122">比方說，如果持有人權杖的元件會使用這個堆疊，它應該運作不受干擾，從一種防 CSRF 機制，也可能會使用相同的堆疊。</span><span class="sxs-lookup"><span data-stu-id="80b47-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="80b47-123">因此最終的需求： 隔離。</span><span class="sxs-lookup"><span data-stu-id="80b47-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="80b47-124">我們可以提供進一步的條件約束以我們的需求的範圍縮小。</span><span class="sxs-lookup"><span data-stu-id="80b47-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="80b47-125">我們假設加密系統內操作的所有服務都皆為同樣信任，而且資料不需要產生或取用外部我們直接控制下的服務。</span><span class="sxs-lookup"><span data-stu-id="80b47-125">We assume that all services operating within the cryptosystem are equally trusted and that the data doesn't need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="80b47-126">此外，我們需要的作業是盡量快速，因為每個 web 服務的要求可能會經過加密系統一次以上。</span><span class="sxs-lookup"><span data-stu-id="80b47-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="80b47-127">這使得對稱密碼編譯非常適合我們的案例中，和我們可以將非對稱密碼編譯折扣之前如有需要請將它的時間。</span><span class="sxs-lookup"><span data-stu-id="80b47-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it's needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="80b47-128">設計原理</span><span class="sxs-lookup"><span data-stu-id="80b47-128">Design philosophy</span></span>

<span data-ttu-id="80b47-129">我們已開始所識別的現有堆疊的問題。</span><span class="sxs-lookup"><span data-stu-id="80b47-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="80b47-130">一旦我們有的我們會接受問卷調查現有解決方案的全貌，並結束任何現有的方案會相當有我們要搜尋的功能。</span><span class="sxs-lookup"><span data-stu-id="80b47-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="80b47-131">然後，我們會設計數個指導原則為基礎的解決方案。</span><span class="sxs-lookup"><span data-stu-id="80b47-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="80b47-132">系統應該提供簡單的組態。</span><span class="sxs-lookup"><span data-stu-id="80b47-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="80b47-133">在理想情況下，系統會是零設定，而且開發人員可以快速展開工作。</span><span class="sxs-lookup"><span data-stu-id="80b47-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="80b47-134">在開發人員必須設定的特定層面 （例如金鑰的儲存機制） 的情況下，應該提供考量進行簡單的這些特定的設定。</span><span class="sxs-lookup"><span data-stu-id="80b47-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="80b47-135">提供簡單的消費者端 API。</span><span class="sxs-lookup"><span data-stu-id="80b47-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="80b47-136">Api 應該是容易使用的正確和不正確地使用。</span><span class="sxs-lookup"><span data-stu-id="80b47-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="80b47-137">開發人員不應該了解金鑰管理的原則。</span><span class="sxs-lookup"><span data-stu-id="80b47-137">Developers shouldn't learn key management principles.</span></span> <span data-ttu-id="80b47-138">可供選取演算法和金鑰的存留期，代替開發人員，應該處理系統。</span><span class="sxs-lookup"><span data-stu-id="80b47-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="80b47-139">在理想情況下，開發人員從未應有的未經處理的重要資料的存取。</span><span class="sxs-lookup"><span data-stu-id="80b47-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="80b47-140">索引鍵應在待用時可能受到保護。</span><span class="sxs-lookup"><span data-stu-id="80b47-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="80b47-141">系統應該找出適當的預設保護機制，並將它自動套用。</span><span class="sxs-lookup"><span data-stu-id="80b47-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="80b47-142">記住這些原則中，我們開發的簡單[易用](xref:security/data-protection/using-data-protection)資料保護堆疊。</span><span class="sxs-lookup"><span data-stu-id="80b47-142">With these principles in mind we developed a simple, [easy to use](xref:security/data-protection/using-data-protection) data protection stack.</span></span>

<span data-ttu-id="80b47-143">無限期的持續性的機密承載不主要是 ASP.NET Core 資料保護 Api。</span><span class="sxs-lookup"><span data-stu-id="80b47-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="80b47-144">等其他技術[Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx)並[Azure Rights Management](/rights-management/)更適合的案例是無限制的儲存體，而且必須跟著強式金鑰管理功能。</span><span class="sxs-lookup"><span data-stu-id="80b47-144">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="80b47-145">話雖如此，沒有任何禁止開發人員使用 ASP.NET Core 資料保護 Api 進行長期保護的機密資料。</span><span class="sxs-lookup"><span data-stu-id="80b47-145">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="80b47-146">適用對象</span><span class="sxs-lookup"><span data-stu-id="80b47-146">Audience</span></span>

<span data-ttu-id="80b47-147">資料保護系統分為五個主要的套件。</span><span class="sxs-lookup"><span data-stu-id="80b47-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="80b47-148">這些 Api 的各個層面目標三個主要的對象;</span><span class="sxs-lookup"><span data-stu-id="80b47-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="80b47-149">[取用者 Api 概觀](xref:security/data-protection/consumer-apis/overview)目標應用程式和架構開發人員。</span><span class="sxs-lookup"><span data-stu-id="80b47-149">The [Consumer APIs Overview](xref:security/data-protection/consumer-apis/overview) target application and framework developers.</span></span>

   <span data-ttu-id="80b47-150">「 我不想了解有關堆疊的運作方式或在設定的方式。</span><span class="sxs-lookup"><span data-stu-id="80b47-150">"I don't want to learn about how the stack operates or about how it's configured.</span></span> <span data-ttu-id="80b47-151">我只想要執行中一樣簡單的某些作業的方式盡可能使用機率很高的成功地使用 Api。 」</span><span class="sxs-lookup"><span data-stu-id="80b47-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="80b47-152">[組態 Api](xref:security/data-protection/configuration/overview)目標應用程式開發人員和系統管理員。</span><span class="sxs-lookup"><span data-stu-id="80b47-152">The [configuration APIs](xref:security/data-protection/configuration/overview) target application developers and system administrators.</span></span>

   <span data-ttu-id="80b47-153">「 我需要告訴我的環境需要非預設路徑或設定值的資料保護系統 」。</span><span class="sxs-lookup"><span data-stu-id="80b47-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="80b47-154">擴充性 Api 目標開發人員負責執行自訂的原則。</span><span class="sxs-lookup"><span data-stu-id="80b47-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="80b47-155">這些 api 的使用方式可能會限制為罕見的情況下，而且發生，安全性感知的開發人員。</span><span class="sxs-lookup"><span data-stu-id="80b47-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="80b47-156">「 我需要更換系統內整個元件，因為我有真正獨一無二的行為需求。</span><span class="sxs-lookup"><span data-stu-id="80b47-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="80b47-157">我想學習不常用使用的 API 介面的組件，才能建立外掛程式，可滿足我的需求。 」</span><span class="sxs-lookup"><span data-stu-id="80b47-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="80b47-158">套件配置</span><span class="sxs-lookup"><span data-stu-id="80b47-158">Package layout</span></span>

<span data-ttu-id="80b47-159">資料保護堆疊是由五個套件所組成。</span><span class="sxs-lookup"><span data-stu-id="80b47-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="80b47-160">[Microsoft.AspNetCore.DataProtection.Abstractions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/)包含<xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider>和<xref:Microsoft.AspNetCore.DataProtection.IDataProtector>来建立的資料保護服務介面。</span><span class="sxs-lookup"><span data-stu-id="80b47-160">[Microsoft.AspNetCore.DataProtection.Abstractions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) contains the <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> and <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> interfaces to create data protection services.</span></span> <span data-ttu-id="80b47-161">它也包含實用的擴充方法使用這些型別 (例如[IDataProtector.Protect](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*))。</span><span class="sxs-lookup"><span data-stu-id="80b47-161">It also contains useful extension methods for working with these types (for example, [IDataProtector.Protect](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*)).</span></span> <span data-ttu-id="80b47-162">如果資料保護系統具現化在其他地方，而且您正在使用的 API，參考`Microsoft.AspNetCore.DataProtection.Abstractions`。</span><span class="sxs-lookup"><span data-stu-id="80b47-162">If the data protection system is instantiated elsewhere and you're consuming the API, reference `Microsoft.AspNetCore.DataProtection.Abstractions`.</span></span>

* <span data-ttu-id="80b47-163">[Microsoft.AspNetCore.DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/)包含資料保護系統，包括核心密碼編譯作業、 金鑰管理、 組態和擴充性的核心實作。</span><span class="sxs-lookup"><span data-stu-id="80b47-163">[Microsoft.AspNetCore.DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/) contains the core implementation of the data protection system, including core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="80b47-164">具現化的資料保護系統 (例如，將它加入至<xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>)，或是修改或擴充其行為，參考`Microsoft.AspNetCore.DataProtection`。</span><span class="sxs-lookup"><span data-stu-id="80b47-164">To instantiate the data protection system (for example, adding it to an <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>) or modifying or extending its behavior, reference `Microsoft.AspNetCore.DataProtection`.</span></span>

* <span data-ttu-id="80b47-165">[Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/)包含開發人員認為非常有用，但它們不屬於核心封裝中的其他 Api。</span><span class="sxs-lookup"><span data-stu-id="80b47-165">[Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="80b47-166">比方說，此套件包含 factory 方法，來具現化的資料保護系統上沒有相依性插入的檔案系統儲存位置的索引鍵 (請參閱<xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider>)。</span><span class="sxs-lookup"><span data-stu-id="80b47-166">For instance, this package contains factory methods to instantiate the data protection system to store keys at a location on the file system without dependency injection (see <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider>).</span></span> <span data-ttu-id="80b47-167">它也包含擴充方法，來限制受保護承載的存留期 (請參閱<xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector>)。</span><span class="sxs-lookup"><span data-stu-id="80b47-167">It also contains extension methods for limiting the lifetime of protected payloads (see <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector>).</span></span>

* <span data-ttu-id="80b47-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/)可以安裝到現有的 ASP.NET 4.x 應用程式重新導向其`<machineKey>`作業，以使用新的 ASP.NET Core 資料保護堆疊。</span><span class="sxs-lookup"><span data-stu-id="80b47-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/) can be installed into an existing ASP.NET 4.x app to redirect its `<machineKey>` operations to use the new ASP.NET Core data protection stack.</span></span> <span data-ttu-id="80b47-169">如需詳細資訊，請參閱 <xref:security/data-protection/compatibility/replacing-machinekey>。</span><span class="sxs-lookup"><span data-stu-id="80b47-169">For more information, see <xref:security/data-protection/compatibility/replacing-machinekey>.</span></span>

* <span data-ttu-id="80b47-170">[Microsoft.AspNetCore.Cryptography.KeyDerivation](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/)提供 PBKDF2 密碼雜湊常式的實作，而且可供必須安全地處理使用者密碼的系統。</span><span class="sxs-lookup"><span data-stu-id="80b47-170">[Microsoft.AspNetCore.Cryptography.KeyDerivation](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/) provides an implementation of the PBKDF2 password hashing routine and can be used by systems that must handle user passwords securely.</span></span> <span data-ttu-id="80b47-171">如需詳細資訊，請參閱 <xref:security/data-protection/consumer-apis/password-hashing>。</span><span class="sxs-lookup"><span data-stu-id="80b47-171">For more information, see <xref:security/data-protection/consumer-apis/password-hashing>.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="80b47-172">其他資源</span><span class="sxs-lookup"><span data-stu-id="80b47-172">Additional resources</span></span>

<xref:host-and-deploy/web-farm>
