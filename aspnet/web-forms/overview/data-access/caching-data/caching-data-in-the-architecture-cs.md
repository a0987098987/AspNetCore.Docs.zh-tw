---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
title: 快取資料的架構 (C#) |Microsoft Docs
author: rick-anderson
description: 在上一個教學課程中，我們學到如何適用於展示層的快取的內容。 在本教學課程中，我們了解如何善用我們的多層式 architectu 的內容...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: d29a7c41-0628-4a23-9dfc-bfea9c6c1054
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
msc.type: authoredcontent
ms.openlocfilehash: 3971140aa7a6c829287e74df804694c19e34adcf
ms.sourcegitcommit: 45ac74e400f9f2b7dbded66297730f6f14a4eb25
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/16/2018
ms.locfileid: "41825763"
---
<a name="caching-data-in-the-architecture-c"></a><span data-ttu-id="ed511-104">快取資料的架構 (C#)</span><span class="sxs-lookup"><span data-stu-id="ed511-104">Caching Data in the Architecture (C#)</span></span>
====================
<span data-ttu-id="ed511-105">藉由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="ed511-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="ed511-106">[下載範例應用程式](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe)或[下載 PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="ed511-106">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) or [Download PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span></span>

> <span data-ttu-id="ed511-107">在上一個教學課程中，我們學到如何適用於展示層的快取的內容。</span><span class="sxs-lookup"><span data-stu-id="ed511-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="ed511-108">在本教學課程中，我們了解如何利用我們的多層式架構商務邏輯層的快取資料的內容。</span><span class="sxs-lookup"><span data-stu-id="ed511-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="ed511-109">我們這樣做，藉由擴充的架構，若要加入的快取層。</span><span class="sxs-lookup"><span data-stu-id="ed511-109">We do this by extending the architecture to include a Caching Layer.</span></span>


## <a name="introduction"></a><span data-ttu-id="ed511-110">簡介</span><span class="sxs-lookup"><span data-stu-id="ed511-110">Introduction</span></span>

<span data-ttu-id="ed511-111">如我們所見在先前的教學課程中，快取的 ObjectDataSource 的資料是簡單，只要設定幾個屬性。</span><span class="sxs-lookup"><span data-stu-id="ed511-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="ed511-112">不幸的是，ObjectDataSource 適用於展示層緊密結合與 ASP.NET 頁面的 快取原則快取。</span><span class="sxs-lookup"><span data-stu-id="ed511-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="ed511-113">建立多層式的架構的原因之一是允許這類中斷的聯繫。</span><span class="sxs-lookup"><span data-stu-id="ed511-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="ed511-114">商業邏輯層，比方說，減少商務邏輯，從 ASP.NET 頁面，而資料存取層，以減少資料存取的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="ed511-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="ed511-115">這種商務邏輯和資料存取的詳細資料，最好，部分，因為它可讓系統更容易閱讀，更容易維護，且更有彈性變更。</span><span class="sxs-lookup"><span data-stu-id="ed511-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="ed511-116">它也可讓網域知識和人力資源展示層不 t 上工作的開發人員必須熟悉資料庫 s 的詳細資訊，才能執行其工作所需要的。</span><span class="sxs-lookup"><span data-stu-id="ed511-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="ed511-117">減少從展示層的快取原則，可提供類似的優點。</span><span class="sxs-lookup"><span data-stu-id="ed511-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="ed511-118">在本教學課程中，我們將增強我們架構進化為包含*快取層*（或簡稱 CL），使其利用我們的快取原則。</span><span class="sxs-lookup"><span data-stu-id="ed511-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="ed511-119">快取的圖層會包含`ProductsCL`類別，提供類似的方法中的產品資訊的存取權`GetProducts()`， `GetProductsByCategoryID(categoryID)`，依此類推，，叫用時，會從快取中擷取資料的第一次嘗試。</span><span class="sxs-lookup"><span data-stu-id="ed511-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="ed511-120">如果快取是空的這些方法會叫用適當`ProductsBLL`BLL，bll 從 DAL 接著會取得資料中的方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="ed511-121">`ProductsCL`方法快取從 BLL 擷取之前將它傳回的資料。</span><span class="sxs-lookup"><span data-stu-id="ed511-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="ed511-122">如 [圖 1] 所示，CL 會位於展示層和商務邏輯層之間。</span><span class="sxs-lookup"><span data-stu-id="ed511-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>


![快取層 (CL) 是我們的架構中的另一個圖層](caching-data-in-the-architecture-cs/_static/image1.png)

<span data-ttu-id="ed511-124">**圖 1**: 快取層 」 (CL) 是我們的架構中的另一個圖層</span><span class="sxs-lookup"><span data-stu-id="ed511-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>


## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="ed511-125">步驟 1： 建立快取層類別</span><span class="sxs-lookup"><span data-stu-id="ed511-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="ed511-126">在本教學課程我們會使用單一類別建立非常簡單的 CL`ProductsCL`有只有少數幾個方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="ed511-127">針對整個應用程式需要建立建置完整的快取層`CategoriesCL`， `EmployeesCL`，和`SuppliersCL`類別，以及提供這些快取層類別中的方法，到 BLL 中每個資料存取或修改方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="ed511-128">與 BLL 和 DAL 中，快取層應該在理想情況下會實作為個別的類別庫專案;不過，我們會做為類別中實作它`App_Code`資料夾。</span><span class="sxs-lookup"><span data-stu-id="ed511-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="ed511-129">從 DAL 和 BLL 類別的多個完全不同 CL 類別，可讓 s 會建立新的子資料夾中`App_Code`資料夾。</span><span class="sxs-lookup"><span data-stu-id="ed511-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="ed511-130">以滑鼠右鍵按一下`App_Code`資料夾，在 [方案總管] 中，選擇新的資料夾和新資料夾命名為`CL`。</span><span class="sxs-lookup"><span data-stu-id="ed511-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="ed511-131">建立此資料夾之後, 加入新的類別，名為`ProductsCL.cs`。</span><span class="sxs-lookup"><span data-stu-id="ed511-131">After creating this folder, add to it a new class named `ProductsCL.cs`.</span></span>


![加入新的資料夾，名為 CL 和名為 ProductsCL.cs 類別](caching-data-in-the-architecture-cs/_static/image2.png)

<span data-ttu-id="ed511-133">**圖 2**： 加入新的資料夾，名為`CL`和類別，名為 `ProductsCL.cs`</span><span class="sxs-lookup"><span data-stu-id="ed511-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.cs`</span></span>


<span data-ttu-id="ed511-134">`ProductsCL`類別應該包含相同一組在其對應的商務邏輯層類別中找到的資料存取和修改方法之 (`ProductsBLL`)。</span><span class="sxs-lookup"><span data-stu-id="ed511-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="ed511-135">而非建立所有這些方法，讓的 s 建構 CL 幾個這裡的模式使用。</span><span class="sxs-lookup"><span data-stu-id="ed511-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="ed511-136">特別的是，我們會新增`GetProducts()`並`GetProductsByCategoryID(categoryID)`在步驟 3 中的方法和`UpdateProduct`在步驟 4 中的多載。</span><span class="sxs-lookup"><span data-stu-id="ed511-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="ed511-137">您可以將其餘`ProductsCL`方法和`CategoriesCL`， `EmployeesCL`，和`SuppliersCL`暇地的類別。</span><span class="sxs-lookup"><span data-stu-id="ed511-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="ed511-138">步驟 2： 讀取和寫入的資料快取</span><span class="sxs-lookup"><span data-stu-id="ed511-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="ed511-139">ObjectDataSource 快取內部前述教學課程中探索的功能會使用 ASP.NET 資料快取來儲存從 BLL 擷取的資料。</span><span class="sxs-lookup"><span data-stu-id="ed511-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="ed511-140">資料快取也可以存取以程式設計方式從 ASP.NET 頁面程式碼後置類別或 web 應用程式的架構中的類別。</span><span class="sxs-lookup"><span data-stu-id="ed511-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="ed511-141">若要讀取及寫入資料的快取，從 ASP.NET 頁面 s 程式碼後置類別，請使用下列模式：</span><span class="sxs-lookup"><span data-stu-id="ed511-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample1.cs)]

<span data-ttu-id="ed511-142">[ `Cache`類別](https://msdn.microsoft.com/library/system.web.caching.cache.aspx)s [ `Insert`方法](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx)有多種多載。</span><span class="sxs-lookup"><span data-stu-id="ed511-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="ed511-143">`Cache["key"] = value` 和`Cache.Insert(key, value)`同義，兩者都新增至使用指定的索引鍵，而不需要定義到期的快取的項目。</span><span class="sxs-lookup"><span data-stu-id="ed511-143">`Cache["key"] = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="ed511-144">一般而言，我們要做為相依性、 以時間為基礎的到期，或同時快取中，加入一個項目時，請指定有效期限。</span><span class="sxs-lookup"><span data-stu-id="ed511-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="ed511-145">使用其中一個其他`Insert`的方法多載，來提供相依性或時間為基礎的到期資訊。</span><span class="sxs-lookup"><span data-stu-id="ed511-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="ed511-146">需要先檢查 如果要求的資料位於快取，若是如此，s 方法快取層會從該處將它傳回。</span><span class="sxs-lookup"><span data-stu-id="ed511-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="ed511-147">如果要求的資料不在快取中，適當的 BLL 方法需要叫用。</span><span class="sxs-lookup"><span data-stu-id="ed511-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="ed511-148">它的傳回值應該快取，並將傳回，如下列順序圖表所示。</span><span class="sxs-lookup"><span data-stu-id="ed511-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>


![快取層的方法傳回的資料從快取它 s 可用](caching-data-in-the-architecture-cs/_static/image3.png)

<span data-ttu-id="ed511-150">**圖 3**: 快取層的方法傳回的資料從快取它 s 可用</span><span class="sxs-lookup"><span data-stu-id="ed511-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>


<span data-ttu-id="ed511-151">圖 3 所述的順序是在 CL 類別中，使用下列模式來完成：</span><span class="sxs-lookup"><span data-stu-id="ed511-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample2.cs)]

<span data-ttu-id="ed511-152">在這裡，*型別*是儲存在快取中的資料類型`Northwind.ProductsDataTable`，例如時*金鑰*是可唯一識別快取項目索引鍵。</span><span class="sxs-lookup"><span data-stu-id="ed511-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="ed511-153">如果具有指定的項目*金鑰*不是快取中，則*執行個體*會`null`會從適當的 BLL 方法擷取資料，並且新增至快取。</span><span class="sxs-lookup"><span data-stu-id="ed511-153">If the item with the specified *key* is not in the cache, then *instance* will be `null` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="ed511-154">依時間`return instance`達到*執行個體*包含資料，從快取的參考，或取自 BLL。</span><span class="sxs-lookup"><span data-stu-id="ed511-154">By the time `return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="ed511-155">請務必從快取存取資料時，請使用上述的模式。</span><span class="sxs-lookup"><span data-stu-id="ed511-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="ed511-156">下列模式，其中第一眼，看起來相同，包含些微的差異，將會介紹競爭條件。</span><span class="sxs-lookup"><span data-stu-id="ed511-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="ed511-157">競爭情形很難進行偵錯，因為它們偶而會顯示本身並不容易重現。</span><span class="sxs-lookup"><span data-stu-id="ed511-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample3.cs)]

<span data-ttu-id="ed511-158">一秒的差異，不正確的程式碼片段是，而不是將快取項目的參考儲存在區域變數中，資料存取快取是直接在條件陳述式中*並*在`return`。</span><span class="sxs-lookup"><span data-stu-id="ed511-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `return`.</span></span> <span data-ttu-id="ed511-159">想像一下，當到達這個程式碼時，`Cache["key"]`是非`null`，但尚未`return`到達陳述式時，系統收回*金鑰*從快取。</span><span class="sxs-lookup"><span data-stu-id="ed511-159">Imagine that when this code is reached, `Cache["key"]` is non-`null`, but before the `return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="ed511-160">在此罕見的情況下，程式碼會傳回`null`值而不是預期類型的物件。</span><span class="sxs-lookup"><span data-stu-id="ed511-160">In this rare case, the code will return a `null` value rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="ed511-161">資料快取是安全執行緒，所以您不必 t 需要簡單的讀取或寫入的同步處理執行緒存取。</span><span class="sxs-lookup"><span data-stu-id="ed511-161">The data cache is thread-safe, so you don t need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="ed511-162">不過，如果您需要多個對資料執行作業的需要是不可部分完成的快取中，您必須負責實作鎖定或其他一些機制以確保執行緒安全性。</span><span class="sxs-lookup"><span data-stu-id="ed511-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="ed511-163">請參閱[ASP.NET 快取的同步處理存取](http://www.ddj.com/184406369)如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="ed511-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>


<span data-ttu-id="ed511-164">項目可以以程式設計方式從資料快取使用收回[`Remove`方法](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx)就像這樣：</span><span class="sxs-lookup"><span data-stu-id="ed511-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample4.cs)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="ed511-165">步驟 3： 傳回產品資訊`ProductsCL`類別</span><span class="sxs-lookup"><span data-stu-id="ed511-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="ed511-166">本教學課程可讓實作兩種方法來傳回產品資訊的 s`ProductsCL`類別：`GetProducts()`和`GetProductsByCategoryID(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="ed511-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="ed511-167">如同`ProductsBL`商業邏輯層中的類別`GetProducts()`CL 中的方法會傳回所有產品的相關資訊`Northwind.ProductsDataTable`物件，而`GetProductsByCategoryID(categoryID)`從指定的類別會傳回所有產品。</span><span class="sxs-lookup"><span data-stu-id="ed511-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="ed511-168">下列程式碼顯示中的方法的部分`ProductsCL`類別：</span><span class="sxs-lookup"><span data-stu-id="ed511-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-cs/samples/sample5.vb)]

<span data-ttu-id="ed511-169">首先，請記下`DataObject`和`DataObjectMethodAttribute`屬性套用至類別和方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="ed511-170">這些屬性會提供資訊給 ObjectDataSource 的精靈中，指出哪些類別和方法應該會出現在精靈中的 s 步驟。</span><span class="sxs-lookup"><span data-stu-id="ed511-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="ed511-171">因為從展示層內的 ObjectDataSource 會存取的 CL 類別和方法，我加入了這些屬性，以增強的設計階段經驗。</span><span class="sxs-lookup"><span data-stu-id="ed511-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="ed511-172">回頭[建立商業邏輯層](../introduction/creating-a-business-logic-layer-cs.md)教學課程，如需更完整的描述，這些屬性和其效果。</span><span class="sxs-lookup"><span data-stu-id="ed511-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-cs.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="ed511-173">在 `GetProducts()`並`GetProductsByCategoryID(categoryID)`方法、 從傳回的資料`GetCacheItem(key)`方法指派給區域變數。</span><span class="sxs-lookup"><span data-stu-id="ed511-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="ed511-174">`GetCacheItem(key)`方法，我們將檢驗，根據指定的快取從傳回的特定項目*金鑰*。</span><span class="sxs-lookup"><span data-stu-id="ed511-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="ed511-175">如果沒有這類資料會快取中找到，它會從對應`ProductsBLL`類別方法，然後再新增至快取使用`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="ed511-176">`GetCacheItem(key)`和`AddCacheItem(key, value)`方法分別介面使用的資料快取、 讀取和寫入值。</span><span class="sxs-lookup"><span data-stu-id="ed511-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="ed511-177">`GetCacheItem(key)`方法較簡單的兩個。</span><span class="sxs-lookup"><span data-stu-id="ed511-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="ed511-178">它只會從快取類別使用傳入的傳回值*金鑰*:</span><span class="sxs-lookup"><span data-stu-id="ed511-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample6.cs)]

<span data-ttu-id="ed511-179">`GetCacheItem(key)` 不會使用*金鑰*值，提供，而是呼叫`GetCacheKey(key)`方法，以傳回*金鑰*ProductsCache-前面加上。</span><span class="sxs-lookup"><span data-stu-id="ed511-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="ed511-180">`MasterCacheKeyArray`，其會保存字串 ProductsCache，也會使用`AddCacheItem(key, value)`方法，暫時如稍後所示。</span><span class="sxs-lookup"><span data-stu-id="ed511-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="ed511-181">從 ASP.NET 頁面 s 程式碼後置類別，資料快取可以使用來存取`Page`類別 s [ `Cache`屬性](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)，並允許以類似下面的語法`Cache["key"] = value`，步驟 2 中所述。</span><span class="sxs-lookup"><span data-stu-id="ed511-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache["key"] = value`, as discussed in Step 2.</span></span> <span data-ttu-id="ed511-182">架構中的類別，從資料快取可使用`HttpRuntime.Cache`或`HttpContext.Current.Cache`。</span><span class="sxs-lookup"><span data-stu-id="ed511-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="ed511-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)的部落格項目[HttpRuntime.Cache vs。HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache)資訊使用的效能優點`HttpRuntime`而不是`HttpContext.Current`; 因此，`ProductsCL`使用`HttpRuntime`。</span><span class="sxs-lookup"><span data-stu-id="ed511-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="ed511-184">如果您的架構使用實作的類別庫專案，則您必須將參考加入`System.Web`若要使用的組件[HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx)並[HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)類別。</span><span class="sxs-lookup"><span data-stu-id="ed511-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>


<span data-ttu-id="ed511-185">如果快取中，找不到項目`ProductsCL`s 類別方法從 BLL 中取得資料，並將它新增至快取使用`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="ed511-186">若要新增*值*至快取中，我們可以使用下列程式碼，使用 60 秒的時間到期：</span><span class="sxs-lookup"><span data-stu-id="ed511-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample7.cs)]

<span data-ttu-id="ed511-187">`DateTime.Now.AddSeconds(CacheDuration)` 在未來的時間中指定以時間為基礎的到期 60 秒[ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx)表示 s，就沒有滑動期限。</span><span class="sxs-lookup"><span data-stu-id="ed511-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="ed511-188">雖然這`Insert`方法多載具有輸入參數的兩個絕對和滑動過期，您可以只提供兩個的其中一個。</span><span class="sxs-lookup"><span data-stu-id="ed511-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="ed511-189">如果您嘗試將指定的絕對時間和時間範圍內，`Insert`方法會擲回`ArgumentException`例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ed511-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="ed511-190">這個實作`AddCacheItem(key, value)`方法目前有一些缺點。</span><span class="sxs-lookup"><span data-stu-id="ed511-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="ed511-191">我們將位址，並解決這些問題，在步驟 4。</span><span class="sxs-lookup"><span data-stu-id="ed511-191">We'll address and overcome these issues in Step 4.</span></span>


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="ed511-192">步驟 4： 失效快取資料時是架構中修改</span><span class="sxs-lookup"><span data-stu-id="ed511-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="ed511-193">資料擷取方法，以及快取的圖層必須提供相同的方法，BLL 的插入、 更新和刪除資料。</span><span class="sxs-lookup"><span data-stu-id="ed511-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="ed511-194">CL 的資料修改方法不會修改快取的資料，但而不是呼叫 BLL s 對應的資料修改的方法，然後確認 快取。</span><span class="sxs-lookup"><span data-stu-id="ed511-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="ed511-195">如我們在先前的教學課程中所見的這會是相同的 ObjectDataSource 適用於其快取的功能啟用時的行為及其`Insert`， `Update`，或`Delete`叫用方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="ed511-196">下列`UpdateProduct`多載會說明如何實作 CL 中的資料修改方法：</span><span class="sxs-lookup"><span data-stu-id="ed511-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample8.cs)]

<span data-ttu-id="ed511-197">適當的資料修改商務邏輯層方法會叫用，但它的回應會傳回我們需要先確認快取。</span><span class="sxs-lookup"><span data-stu-id="ed511-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="ed511-198">不幸的是，快取無效並不直接了當因為`ProductsCL`類別 s`GetProducts()`並`GetProductsByCategoryID(categoryID)`方法每個項目加入快取具有不同的索引鍵，而`GetProductsByCategoryID(categoryID)`方法會將不同的快取項目加入每個唯一*categoryID*。</span><span class="sxs-lookup"><span data-stu-id="ed511-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="ed511-199">當快取無效，我們需要移除*所有*可能藉由加入的項目`ProductsCL`類別。</span><span class="sxs-lookup"><span data-stu-id="ed511-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="ed511-200">這可藉由建立關聯*快取相依性*每個項目新增至快取中`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="ed511-201">一般情況下，快取相依性可以是另一個項目在快取中，檔案系統或將資料從 Microsoft SQL Server 資料庫上的檔案。</span><span class="sxs-lookup"><span data-stu-id="ed511-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="ed511-202">當相依性變更，或已從快取中移除，與其相關聯的快取項目會自動從快取收回。</span><span class="sxs-lookup"><span data-stu-id="ed511-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="ed511-203">本教學課程中，我們想要在快取，可透過新增快取相依性的所有項目建立額外的項目`ProductsCL`類別。</span><span class="sxs-lookup"><span data-stu-id="ed511-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="ed511-204">如此一來，所有這些項目可以是從快取移除只要移除快取相依性。</span><span class="sxs-lookup"><span data-stu-id="ed511-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="ed511-205">讓的 s update`AddCacheItem(key, value)`方法以便將每個項目新增至快取，透過這個方法是與單一快取相依性相關聯：</span><span class="sxs-lookup"><span data-stu-id="ed511-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample9.cs)]

<span data-ttu-id="ed511-206">`MasterCacheKeyArray` 是字串陣列，保留的 ProductsCache 的值。</span><span class="sxs-lookup"><span data-stu-id="ed511-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="ed511-207">首先，快取項目新增至快取，且指派的目前日期和時間。</span><span class="sxs-lookup"><span data-stu-id="ed511-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="ed511-208">如果快取項目已經存在，就會更新。</span><span class="sxs-lookup"><span data-stu-id="ed511-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="ed511-209">接下來，會建立快取相依性。</span><span class="sxs-lookup"><span data-stu-id="ed511-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="ed511-210">[ `CacheDependency`類別](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx)s 建構函式有幾個多載，但在這裡使用的一個必須要有兩個`string`陣列的輸入。</span><span class="sxs-lookup"><span data-stu-id="ed511-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `string` array inputs.</span></span> <span data-ttu-id="ed511-211">第一個指定檔案，可做為相依性的集合。</span><span class="sxs-lookup"><span data-stu-id="ed511-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="ed511-212">因為我們不想要使用任何檔案為基礎的相依性，值為`null`適用於第一個輸入參數。</span><span class="sxs-lookup"><span data-stu-id="ed511-212">Since we don t want to use any file-based dependencies, a value of `null` is used for the first input parameter.</span></span> <span data-ttu-id="ed511-213">第二個輸入的參數會指定將作為相依性的快取索引鍵的集合。</span><span class="sxs-lookup"><span data-stu-id="ed511-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="ed511-214">我們在這裡指定單一的相依性， `MasterCacheKeyArray`。</span><span class="sxs-lookup"><span data-stu-id="ed511-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="ed511-215">`CacheDependency`接著會傳遞至`Insert`方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="ed511-216">若要進行此項修改`AddCacheItem(key, value)`invaliding、 快取很簡單，只要移除的相依性。</span><span class="sxs-lookup"><span data-stu-id="ed511-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample10.cs)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="ed511-217">步驟 5： 從展示層呼叫快取層</span><span class="sxs-lookup"><span data-stu-id="ed511-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="ed511-218">快取層的類別和方法可用來處理資料的技術我們 ve 檢查在這些教學課程。</span><span class="sxs-lookup"><span data-stu-id="ed511-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="ed511-219">為了說明使用快取的資料，您將變更儲存到`ProductsCL`類別，然後開啟`FromTheArchitecture.aspx`頁面中`Caching`資料夾，並新增 GridView。</span><span class="sxs-lookup"><span data-stu-id="ed511-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="ed511-220">從 GridView s 智慧標籤，建立新的 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="ed511-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="ed511-221">在精靈的 s 第一個步驟應該會看到`ProductsCL`類別做為其中一個選項，從下拉式清單。</span><span class="sxs-lookup"><span data-stu-id="ed511-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>


<span data-ttu-id="ed511-222">[![在 [商務物件] 下拉式清單中包含 ProductsCL 類別](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="ed511-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span></span>

<span data-ttu-id="ed511-223">**[圖 4**:`ProductsCL`類別會包含商務物件] 下拉式清單中 ([按一下以檢視完整大小的影像](caching-data-in-the-architecture-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="ed511-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image6.png))</span></span>


<span data-ttu-id="ed511-224">選取之後`ProductsCL`，按一下 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="ed511-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="ed511-225">下拉式清單中的選取索引標籤中有兩個項目-`GetProducts()`並`GetProductsByCategoryID(categoryID)`和 [更新] 索引標籤具有唯一`UpdateProduct`多載。</span><span class="sxs-lookup"><span data-stu-id="ed511-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="ed511-226">選擇`GetProducts()`從 [選取] 索引標籤的方法和`UpdateProducts`方法，從 [更新] 索引標籤，然後按一下 [完成]。</span><span class="sxs-lookup"><span data-stu-id="ed511-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>


<span data-ttu-id="ed511-227">[![ProductsCL 類別的方法詳列於下拉式清單](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="ed511-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span></span>

<span data-ttu-id="ed511-228">**圖 5**:`ProductsCL`下拉式清單中列出類別的方法 ([按一下以檢視完整大小的影像](caching-data-in-the-architecture-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="ed511-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image9.png))</span></span>


<span data-ttu-id="ed511-229">完成精靈之後，Visual Studio 將會設定 ObjectDataSource s`OldValuesParameterFormatString`屬性設`original_{0}`並將適當的欄位新增至 GridView。</span><span class="sxs-lookup"><span data-stu-id="ed511-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="ed511-230">變更`OldValuesParameterFormatString`回其預設值的屬性`{0}`，及設定 GridView，以支援分頁、 排序和編輯。</span><span class="sxs-lookup"><span data-stu-id="ed511-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="ed511-231">因為`UploadProducts`CL 所使用的多載接受只編輯的產品的名稱和價格，限制 GridView，因此只有這些欄位是可編輯。</span><span class="sxs-lookup"><span data-stu-id="ed511-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="ed511-232">在先前的教學課程中，我們定義 GridView，以包含如欄位`ProductName`， `CategoryName`，和`UnitPrice`欄位。</span><span class="sxs-lookup"><span data-stu-id="ed511-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="ed511-233">歡迎複寫此格式和結構，在此情況下您 GridView 和 ObjectDataSource 的 s 宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="ed511-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-in-the-architecture-cs/samples/sample11.aspx)]

<span data-ttu-id="ed511-234">現在我們已使用快取層級的頁面。</span><span class="sxs-lookup"><span data-stu-id="ed511-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="ed511-235">若要查看動作中的快取，請在中設定中斷點`ProductsCL`類別 s`GetProducts()`和`UpdateProduct`方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="ed511-236">排序和分頁才能看到資料提取從快取時，請造訪網頁瀏覽器，並逐步執行程式碼中。</span><span class="sxs-lookup"><span data-stu-id="ed511-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="ed511-237">然後更新記錄，並請注意，快取失效，因此，它從 BLL 時擷取資料會重新繫結至 GridView。</span><span class="sxs-lookup"><span data-stu-id="ed511-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="ed511-238">本文所附的下載中提供的快取層會完成。</span><span class="sxs-lookup"><span data-stu-id="ed511-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="ed511-239">它包含一個類別， `ProductsCL`，這僅支援少數幾個方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="ed511-240">此外，在單一 ASP.NET 頁面使用 CL (`~/Caching/FromTheArchitecture.aspx`) 所有其他人仍 BLL 直接參考。</span><span class="sxs-lookup"><span data-stu-id="ed511-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="ed511-241">如果您計劃使用 CL 應用程式中，從展示層的所有呼叫應該都前往 CL，這會要求 CL 的類別，方法會涵蓋這些類別和方法在目前由展示層 BLL。</span><span class="sxs-lookup"><span data-stu-id="ed511-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>


## <a name="summary"></a><span data-ttu-id="ed511-242">總結</span><span class="sxs-lookup"><span data-stu-id="ed511-242">Summary</span></span>

<span data-ttu-id="ed511-243">雖然可以套用快取，在展示層與 ASP.NET 2.0 的 SqlDataSource 和 ObjectDataSource 控制項，在理想情況下快取責任會委派給獨立的圖層架構中。</span><span class="sxs-lookup"><span data-stu-id="ed511-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="ed511-244">在本教學課程中，我們建立一個快取的層級可位於展示層和商務邏輯層之間。</span><span class="sxs-lookup"><span data-stu-id="ed511-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="ed511-245">在快取層，就必須提供相同一組類別和存在於 BLL，以及從展示層呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="ed511-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="ed511-246">我們已探索這和先前的教學課程中的快取層範例展現*反應式載入*。</span><span class="sxs-lookup"><span data-stu-id="ed511-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="ed511-247">回應式載入，資料到快取時才會載入資料要求，而該資料遺漏從快取。</span><span class="sxs-lookup"><span data-stu-id="ed511-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="ed511-248">資料也可以*主動載入*到快取中，一種技術，將資料載入快取之前有實際需要的。</span><span class="sxs-lookup"><span data-stu-id="ed511-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="ed511-249">在下一個教學課程中我們會看到我們看看如何將靜態的值儲存至快取在應用程式啟動時主動載入範例。</span><span class="sxs-lookup"><span data-stu-id="ed511-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="ed511-250">快樂地寫程式 ！</span><span class="sxs-lookup"><span data-stu-id="ed511-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="ed511-251">關於作者</span><span class="sxs-lookup"><span data-stu-id="ed511-251">About the Author</span></span>

<span data-ttu-id="ed511-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七個 ASP 書籍和的創辦人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年從事 Microsoft Web 技術工作。</span><span class="sxs-lookup"><span data-stu-id="ed511-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="ed511-253">Scott 會擔任獨立的顧問、 培訓講師和作家。</span><span class="sxs-lookup"><span data-stu-id="ed511-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="ed511-254">他最新的著作是[ *Sams 教導您自己 ASP.NET 2.0 在 24 小時內*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="ed511-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="ed511-255">他可以在觸達[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="ed511-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="ed511-256">或透過他的部落格，這位於 [http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="ed511-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="ed511-257">特別感謝</span><span class="sxs-lookup"><span data-stu-id="ed511-257">Special Thanks To</span></span>

<span data-ttu-id="ed511-258">本教學課程系列是由許多實用的檢閱者檢閱。</span><span class="sxs-lookup"><span data-stu-id="ed511-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="ed511-259">本教學課程中的潛在客戶檢閱者已 Teresa Murph。</span><span class="sxs-lookup"><span data-stu-id="ed511-259">Lead reviewer for this tutorial was Teresa Murph.</span></span> <span data-ttu-id="ed511-260">有興趣檢閱我即將推出的 MSDN 文章嗎？</span><span class="sxs-lookup"><span data-stu-id="ed511-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="ed511-261">如果是這樣，psychic 在[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="ed511-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="ed511-262">[上一頁](caching-data-with-the-objectdatasource-cs.md)
> [下一頁](caching-data-at-application-startup-cs.md)</span><span class="sxs-lookup"><span data-stu-id="ed511-262">[Previous](caching-data-with-the-objectdatasource-cs.md)
[Next](caching-data-at-application-startup-cs.md)</span></span>
