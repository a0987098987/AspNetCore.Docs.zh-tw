---
uid: web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-vb
title: "實作開放式並行存取使用 SqlDataSource (VB) |Microsoft 文件"
author: rick-anderson
description: "在本教學課程，我們檢閱必要的開放式並行存取控制，然後瀏覽如何實作使用 SqlDataSource 控制項。"
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2007
ms.topic: article
ms.assetid: a8fa72ee-8328-4854-a419-c1b271772303
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/accessing-the-database-directly-from-an-aspnet-page/implementing-optimistic-concurrency-with-the-sqldatasource-vb
msc.type: authoredcontent
ms.openlocfilehash: 974ea50a0d12aae09107470815214b20068ea553
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/24/2018
---
<a name="implementing-optimistic-concurrency-with-the-sqldatasource-vb"></a><span data-ttu-id="e64d5-103">使用 SqlDataSource (VB) 實作開放式並行存取</span><span class="sxs-lookup"><span data-stu-id="e64d5-103">Implementing Optimistic Concurrency with the SqlDataSource (VB)</span></span>
====================
<span data-ttu-id="e64d5-104">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="e64d5-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="e64d5-105">[下載範例應用程式](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_VB.exe)或[下載 PDF](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/datatutorial50vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="e64d5-105">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_50_VB.exe) or [Download PDF](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/datatutorial50vb1.pdf)</span></span>

> <span data-ttu-id="e64d5-106">在本教學課程，我們檢閱必要的開放式並行存取控制，然後瀏覽如何實作使用 SqlDataSource 控制項。</span><span class="sxs-lookup"><span data-stu-id="e64d5-106">In this tutorial we review the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource control.</span></span>


## <a name="introduction"></a><span data-ttu-id="e64d5-107">簡介</span><span class="sxs-lookup"><span data-stu-id="e64d5-107">Introduction</span></span>

<span data-ttu-id="e64d5-108">在前述教學課程中我們會檢查如何新增插入、 更新和刪除 SqlDataSource 控制項的功能。</span><span class="sxs-lookup"><span data-stu-id="e64d5-108">In the preceding tutorial we examined how to add inserting, updating, and deleting capabilities to the SqlDataSource control.</span></span> <span data-ttu-id="e64d5-109">簡單地說，提供這些功能，我們需要指定對應`INSERT`， `UPDATE`，或`DELETE`控制項 s 中的 SQL 陳述式`InsertCommand`， `UpdateCommand`，或`DeleteCommand`搭配適當的屬性中的參數`InsertParameters`， `UpdateParameters`，和`DeleteParameters`集合。</span><span class="sxs-lookup"><span data-stu-id="e64d5-109">In short, to provide these features we needed to specify the corresponding `INSERT`, `UPDATE`, or `DELETE` SQL statement in the control s `InsertCommand`, `UpdateCommand`, or `DeleteCommand` properties, along with the appropriate parameters in the `InsertParameters`, `UpdateParameters`, and `DeleteParameters` collections.</span></span> <span data-ttu-id="e64d5-110">[設定資料來源精靈 s 進階] 按鈕時可以手動指定這些屬性和集合，提供產生`INSERT`， `UPDATE`，和`DELETE`陳述式核取方塊會自動建立這些陳述式為基礎`SELECT`陳述式。</span><span class="sxs-lookup"><span data-stu-id="e64d5-110">While these properties and collections can be specified manually, the Configure Data Source wizard s Advanced button offers a Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox that will auto-create these statements based on the `SELECT` statement.</span></span>

<span data-ttu-id="e64d5-111">產生以及`INSERT`， `UPDATE`，和`DELETE`陳述式核取方塊，進階 SQL 產生選項 對話方塊包含使用開放式並行存取選項 （請參閱圖 1）。</span><span class="sxs-lookup"><span data-stu-id="e64d5-111">Along with the Generate `INSERT`, `UPDATE`, and `DELETE` statements checkbox, the Advanced SQL Generation Options dialog box includes a Use optimistic concurrency option (see Figure 1).</span></span> <span data-ttu-id="e64d5-112">有選取時，`WHERE`中自動產生的子句`UPDATE`和`DELETE`陳述式會修改為僅執行更新或刪除如果因為使用者修改基礎資料庫資料的項目 t 上次載入資料到方格內。</span><span class="sxs-lookup"><span data-stu-id="e64d5-112">When checked, the `WHERE` clauses in the autogenerated `UPDATE` and `DELETE` statements are modified to only perform the update or delete if the underlying database data hasn t been modified since the user last loaded the data into the grid.</span></span>


![您可以加入的開放式並行存取支援從進階 SQL 產生選項對話方塊](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.gif)

<span data-ttu-id="e64d5-114">**圖 1**： 您可以加入的開放式並行存取支援從進階 SQL 產生選項對話方塊</span><span class="sxs-lookup"><span data-stu-id="e64d5-114">**Figure 1**: You Can Add Optimistic Concurrency Support from the Advanced SQL Generation Options Dialog Box</span></span>


<span data-ttu-id="e64d5-115">回到[實作開放式並行存取](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md)我們檢查的開放式並行存取控制，以及如何將它加入至 ObjectDataSource 基本概念的教學課程。</span><span class="sxs-lookup"><span data-stu-id="e64d5-115">Back in the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial we examined the fundamentals of optimistic concurrency control and how to add it to the ObjectDataSource.</span></span> <span data-ttu-id="e64d5-116">在本教學課程中，我們將潤飾上必要的開放式並行存取控制，然後瀏覽如何實作使用 SqlDataSource。</span><span class="sxs-lookup"><span data-stu-id="e64d5-116">In this tutorial we'll retouch on the essentials of optimistic concurrency control and then explore how to implement it using the SqlDataSource.</span></span>

## <a name="a-recap-of-optimistic-concurrency"></a><span data-ttu-id="e64d5-117">複習一下開放式並行存取</span><span class="sxs-lookup"><span data-stu-id="e64d5-117">A Recap of Optimistic Concurrency</span></span>

<span data-ttu-id="e64d5-118">Web 應用程式允許多個使用者同時編輯或刪除相同的資料，有一位使用者可能會不小心覆寫另一個 s 變更的可能性。</span><span class="sxs-lookup"><span data-stu-id="e64d5-118">For web applications that allow multiple, simultaneous users to edit or delete the same data, there exists a possibility that one user may accidentally overwrite another s changes.</span></span> <span data-ttu-id="e64d5-119">在[實作開放式並行存取](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md)教學課程，我會提供下列的範例：</span><span class="sxs-lookup"><span data-stu-id="e64d5-119">In the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial I provided the following example:</span></span>

<span data-ttu-id="e64d5-120">想像一下，Jisun 與 Sam，兩位使用者已同時瀏覽允許訪客更新及刪除產品透過 GridView 控制項的應用程式中的頁面。</span><span class="sxs-lookup"><span data-stu-id="e64d5-120">Imagine that two users, Jisun and Sam, were both visiting a page in an application that allowed visitors to update and delete products through a GridView control.</span></span> <span data-ttu-id="e64d5-121">兩者的 Chai 中按一下 [編輯] 按鈕，大約在同一時間。</span><span class="sxs-lookup"><span data-stu-id="e64d5-121">Both click the Edit button for Chai around the same time.</span></span> <span data-ttu-id="e64d5-122">Jisun 變為 Chai 茶杯的產品名稱，然後按一下 [更新] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="e64d5-122">Jisun changes the product name to Chai Tea and clicks the Update button.</span></span> <span data-ttu-id="e64d5-123">最後結果就是`UPDATE`陳述式傳送到資料庫，設定*所有*的產品 s 可更新的欄位 (即使 Jisun 只能更新一個欄位， `ProductName`)。</span><span class="sxs-lookup"><span data-stu-id="e64d5-123">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product s updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="e64d5-124">在此時間點，該資料庫必須 Chai 茶杯，類別飲料，供應商山，對此特定產品值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-124">At this point in time, the database has the values Chai Tea, the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="e64d5-125">不過，Sam 的螢幕上 GridView 仍會顯示產品名稱的可編輯的 GridView 資料列中為 Chai。</span><span class="sxs-lookup"><span data-stu-id="e64d5-125">However, the GridView on Sam s screen still shows the product name in the editable GridView row as Chai.</span></span> <span data-ttu-id="e64d5-126">幾秒後 Jisun 的變更已認可，Sam 更新 「 調味品 」 類別目錄，然後按一下 更新。</span><span class="sxs-lookup"><span data-stu-id="e64d5-126">A few seconds after Jisun s changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="e64d5-127">這會導致`UPDATE`陳述式傳送至資料庫所設定的產品名稱 Chai，`CategoryID`到對應 「 調味品 」 類別目錄識別碼，等等。</span><span class="sxs-lookup"><span data-stu-id="e64d5-127">This results in an `UPDATE` statement sent to the database that sets the product name to Chai, the `CategoryID` to the corresponding Condiments category ID, and so on.</span></span> <span data-ttu-id="e64d5-128">已覆寫 Jisun 的變更為 產品名稱。</span><span class="sxs-lookup"><span data-stu-id="e64d5-128">Jisun s changes to the product name have been overwritten.</span></span>

<span data-ttu-id="e64d5-129">圖 2 說明這種互動。</span><span class="sxs-lookup"><span data-stu-id="e64d5-129">Figure 2 illustrates this interaction.</span></span>


<span data-ttu-id="e64d5-130">[![當兩個使用者同時更新資料錄那里一位使用者 s s 可能會變更為覆寫其他](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-130">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image1.png)</span></span>

<span data-ttu-id="e64d5-131">**圖 2**： 當兩個使用者同時更新覆寫其他變更的記錄那里 s 可能一位使用者 s ([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-131">**Figure 2**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image2.png))</span></span>


<span data-ttu-id="e64d5-132">若要避免這種情況下 unfolding，一種[並行控制](http://en.wikipedia.org/wiki/Concurrency_control)必須實作。</span><span class="sxs-lookup"><span data-stu-id="e64d5-132">To prevent this scenario from unfolding, a form of [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) must be implemented.</span></span> <span data-ttu-id="e64d5-133">[開放式並行存取](http://en.wikipedia.org/wiki/Optimistic_concurrency_control)本教學課程的焦點運作時可能會有並行衝突不時，大部分的這類衝突贏了 t 的時間發生的假設。</span><span class="sxs-lookup"><span data-stu-id="e64d5-133">[Optimistic concurrency](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) the focus of this tutorial works on the assumption that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won t arise.</span></span> <span data-ttu-id="e64d5-134">因此，如果沒有發生衝突，開放式並行存取控制項只會通知使用者，其變更無法儲存，因為其他使用者已修改相同的資料。</span><span class="sxs-lookup"><span data-stu-id="e64d5-134">Therefore, if a conflict does arise, optimistic concurrency control simply informs the user that their changes can t be saved because another user has modified the same data.</span></span>

> [!NOTE]
> <span data-ttu-id="e64d5-135">它會假設會有許多並行衝突，或如果此類衝突不容忍範圍內的應用程式，然後封閉式並行存取控制可以改用。</span><span class="sxs-lookup"><span data-stu-id="e64d5-135">For applications where it is assumed that there will be many concurrency conflicts or if such conflicts are not tolerable, then pessimistic concurrency control can be used instead.</span></span> <span data-ttu-id="e64d5-136">若要回頭參考[實作開放式並行存取](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md)封閉式並行控制的更完整討論的教學課程。</span><span class="sxs-lookup"><span data-stu-id="e64d5-136">Refer back to the [Implementing Optimistic Concurrency](../editing-inserting-and-deleting-data/implementing-optimistic-concurrency-vb.md) tutorial for a more thorough discussion on pessimistic concurrency control.</span></span>


<span data-ttu-id="e64d5-137">開放式並行存取控制的運作方式是確保更新或刪除的記錄具有相同的值，更新或刪除處理程序啟動時一樣。</span><span class="sxs-lookup"><span data-stu-id="e64d5-137">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="e64d5-138">比方說，可編輯的 GridView 中的 [編輯] 按鈕時記錄的值是從資料庫讀取和文字方塊和其他 Web 控制項中顯示。</span><span class="sxs-lookup"><span data-stu-id="e64d5-138">For example, when clicking the Edit button in an editable GridView, the record s values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="e64d5-139">在 GridView 會儲存這些原始值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-139">These original values are saved by the GridView.</span></span> <span data-ttu-id="e64d5-140">更新的版本，使用者可讓她變更，並按一下 [更新] 按鈕之後`UPDATE`用陳述式必須納入考量的原始值加上新的值，並只更新基礎的資料庫記錄，如果原始值的使用者開始編輯是仍在資料庫中的值相同。</span><span class="sxs-lookup"><span data-stu-id="e64d5-140">Later, after the user makes her changes and clicks the Update button, the `UPDATE` statement used must take into account the original values plus the new values and only update the underlying database record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="e64d5-141">圖 3 描寫此順序的事件。</span><span class="sxs-lookup"><span data-stu-id="e64d5-141">Figure 3 depicts this sequence of events.</span></span>


<span data-ttu-id="e64d5-142">[![Update 或 Delete 才會成功，原始的值必須等於目前的資料庫值](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-142">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image3.png)</span></span>

<span data-ttu-id="e64d5-143">**圖 3**: For Update 或 Delete succeed，原始的值必須是等於目前的資料庫值 ([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-143">**Figure 3**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.png))</span></span>


<span data-ttu-id="e64d5-144">有各種方法可以實作開放式並行存取 (請參閱[Peter A.Bromberg](http://peterbromberg.net/) s [Optmistic 並行更新邏輯](http://www.eggheadcafe.com/articles/20050719.asp)，有多種選項簡短查看)。</span><span class="sxs-lookup"><span data-stu-id="e64d5-144">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/) s [Optmistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="e64d5-145">使用 SqlDataSource （以及 ADO.NET 型別資料集在我們的資料存取層中使用） 的技術擴大`WHERE`子句，以包含所有原始值的比較。</span><span class="sxs-lookup"><span data-stu-id="e64d5-145">The technique used by the SqlDataSource (as well as by the ADO.NET Typed DataSets used in our Data Access Layer) augments the `WHERE` clause to include a comparison of all of the original values.</span></span> <span data-ttu-id="e64d5-146">下列`UPDATE`陳述式，例如，更新的名稱和產品的價格只有當目前的資料庫值不等於更新 GridView 中的記錄時所擷取的值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-146">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="e64d5-147">`@ProductName`和`@UnitPrice`參數包含由使用者所輸入的新值，而`@original_ProductName`和`@original_UnitPrice`包含了原本 GridView 時載入 [編輯] 按鈕已按下的值：</span><span class="sxs-lookup"><span data-stu-id="e64d5-147">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample1.sql)]

<span data-ttu-id="e64d5-148">我們會看到此教學課程中，啟用開放式並行存取控制與 SqlDataSource 很簡單，只選取核取方塊。</span><span class="sxs-lookup"><span data-stu-id="e64d5-148">As we'll see in this tutorial, enabling optimistic concurrency control with the SqlDataSource is as simple as checking a checkbox.</span></span>

## <a name="step-1-creating-a-sqldatasource-that-supports-optimistic-concurrency"></a><span data-ttu-id="e64d5-149">步驟 1： 建立 SqlDataSource 支援開放式並行存取</span><span class="sxs-lookup"><span data-stu-id="e64d5-149">Step 1: Creating a SqlDataSource that Supports Optimistic Concurrency</span></span>

<span data-ttu-id="e64d5-150">先開啟`OptimisticConcurrency.aspx`頁面`SqlDataSource`資料夾。</span><span class="sxs-lookup"><span data-stu-id="e64d5-150">Start by opening the `OptimisticConcurrency.aspx` page from the `SqlDataSource` folder.</span></span> <span data-ttu-id="e64d5-151">將 SqlDataSource 控制項從工具箱拖曳至設計工具中，設定其`ID`屬性`ProductsDataSourceWithOptimisticConcurrency`。</span><span class="sxs-lookup"><span data-stu-id="e64d5-151">Drag a SqlDataSource control from the Toolbox onto the Designer, settings its `ID` property to `ProductsDataSourceWithOptimisticConcurrency`.</span></span> <span data-ttu-id="e64d5-152">接下來，也可以按一下 設定資料來源中的連結控制項 s 智慧標籤。</span><span class="sxs-lookup"><span data-stu-id="e64d5-152">Next, click on the Configure Data Source link from the control s smart tag.</span></span> <span data-ttu-id="e64d5-153">在精靈中第一個畫面中，選擇使用`NORTHWINDConnectionString`，按一下 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="e64d5-153">From the first screen in the wizard, choose to work with the `NORTHWINDConnectionString` and click Next.</span></span>


<span data-ttu-id="e64d5-154">[![選擇以 NORTHWINDConnectionString 搭配運作](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-154">[![Choose to Work with the NORTHWINDConnectionString](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image4.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.png)</span></span>

<span data-ttu-id="e64d5-155">**圖 4**： 選擇使用`NORTHWINDConnectionString`([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-155">**Figure 4**: Choose to Work with the `NORTHWINDConnectionString` ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.png))</span></span>


<span data-ttu-id="e64d5-156">此範例中我們將加入可讓使用者編輯的 GridView`Products`資料表。</span><span class="sxs-lookup"><span data-stu-id="e64d5-156">For this example we'll be adding a GridView that enables users to edit the `Products` table.</span></span> <span data-ttu-id="e64d5-157">因此，從 設定 Select 陳述式畫面中，選擇 `Products`資料表從下拉式清單，然後選取`ProductID`， `ProductName`， `UnitPrice`，和`Discontinued`資料行，如圖 5 所示。</span><span class="sxs-lookup"><span data-stu-id="e64d5-157">Therefore, from the Configure the Select Statement screen, choose the `Products` table from the drop-down list and select the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` columns, as shown in Figure 5.</span></span>


<span data-ttu-id="e64d5-158">[![從 [產品] 資料表傳回 ProductID、 ProductName、 UnitPrice 和已停止的資料行](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-158">[![From the Products Table, Return the ProductID, ProductName, UnitPrice, and Discontinued Columns](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image5.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.png)</span></span>

<span data-ttu-id="e64d5-159">**圖 5**： 從`Products`資料表中，傳回`ProductID`， `ProductName`， `UnitPrice`，和`Discontinued`資料行 ([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-159">**Figure 5**: From the `Products` Table, Return the `ProductID`, `ProductName`, `UnitPrice`, and `Discontinued` Columns ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.png))</span></span>


<span data-ttu-id="e64d5-160">挑選之後資料行中，按一下 [進階] 按鈕以顯示 [進階 SQL 產生選項] 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="e64d5-160">After picking the columns, click the Advanced button to bring up the Advanced SQL Generation Options dialog box.</span></span> <span data-ttu-id="e64d5-161">檢查 產生`INSERT`， `UPDATE`，和`DELETE`陳述式並使用開放式並行存取核取方塊，然後按一下 確定 （請參閱上一步圖 1 螢幕擷取畫面）。</span><span class="sxs-lookup"><span data-stu-id="e64d5-161">Check the Generate `INSERT`, `UPDATE`, and `DELETE` statements and Use optimistic concurrency checkboxes and click OK (refer back to Figure 1 for a screenshot).</span></span> <span data-ttu-id="e64d5-162">完成精靈，依序按一下 [下一步]，然後完成。</span><span class="sxs-lookup"><span data-stu-id="e64d5-162">Complete the wizard by clicking Next, then Finish.</span></span>

<span data-ttu-id="e64d5-163">完成設定資料來源精靈之後，請花一點時間來檢查所產生的`DeleteCommand`和`UpdateCommand`屬性和`DeleteParameters`和`UpdateParameters`集合。</span><span class="sxs-lookup"><span data-stu-id="e64d5-163">After completing the Configure Data Source wizard, take a moment to examine the resulting `DeleteCommand` and `UpdateCommand` properties and the `DeleteParameters` and `UpdateParameters` collections.</span></span> <span data-ttu-id="e64d5-164">若要這樣做最簡單的方式是按一下以查看頁面 s 宣告式語法左下角的 [來源] 索引標籤上。</span><span class="sxs-lookup"><span data-stu-id="e64d5-164">The easiest way to do this is to click on the Source tab in the lower left corner to see the page s declarative syntax.</span></span> <span data-ttu-id="e64d5-165">您會發現那里`UpdateCommand`的值：</span><span class="sxs-lookup"><span data-stu-id="e64d5-165">There you will find an `UpdateCommand` value of:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample2.sql)]

<span data-ttu-id="e64d5-166">中的七個參數`UpdateParameters`集合：</span><span class="sxs-lookup"><span data-stu-id="e64d5-166">With seven parameters in the `UpdateParameters` collection:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample3.aspx)]

<span data-ttu-id="e64d5-167">同樣地，`DeleteCommand`屬性和`DeleteParameters`集合應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="e64d5-167">Similarly, the `DeleteCommand` property and `DeleteParameters` collection should look like the following:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample4.sql)]


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample5.aspx)]

<span data-ttu-id="e64d5-168">除了加強`WHERE`子句`UpdateCommand`和`DeleteCommand`屬性 （和個別的參數集合中加入額外的參數），選取 使用樂觀並行選項會調整其他兩個屬性：</span><span class="sxs-lookup"><span data-stu-id="e64d5-168">In addition to augmenting the `WHERE` clauses of the `UpdateCommand` and `DeleteCommand` properties (and adding the additional parameters to the respective parameter collections), selecting the Use optimistic concurrency option adjusts two other properties:</span></span>

- <span data-ttu-id="e64d5-169">變更[`ConflictDetection`屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx)從`OverwriteChanges`（預設） 至`CompareAllValues`</span><span class="sxs-lookup"><span data-stu-id="e64d5-169">Changes the [`ConflictDetection` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.conflictdetection.aspx) from `OverwriteChanges` (the default) to `CompareAllValues`</span></span>
- <span data-ttu-id="e64d5-170">變更[`OldValuesParameterFormatString`屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx)從 {0} （預設值） 的原始\_{0}。</span><span class="sxs-lookup"><span data-stu-id="e64d5-170">Changes the [`OldValuesParameterFormatString` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.sqldatasource.oldvaluesparameterformatstring.aspx) from {0} (the default) to original\_{0} .</span></span>

<span data-ttu-id="e64d5-171">當資料 Web 控制項叫用 SqlDataSource s`Update()`或`Delete()`方法，它會將傳遞的原始值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-171">When the data Web control invokes the SqlDataSource s `Update()` or `Delete()` method, it passes in the original values.</span></span> <span data-ttu-id="e64d5-172">如果 SqlDataSource s`ConflictDetection`屬性設定為`CompareAllValues`，這些原始值都會加入至命令。</span><span class="sxs-lookup"><span data-stu-id="e64d5-172">If the SqlDataSource s `ConflictDetection` property is set to `CompareAllValues`, these original values are added to the command.</span></span> <span data-ttu-id="e64d5-173">`OldValuesParameterFormatString`屬性提供對這些原始值參數所使用的命名模式。</span><span class="sxs-lookup"><span data-stu-id="e64d5-173">The `OldValuesParameterFormatString` property provides the naming pattern used for these original value parameters.</span></span> <span data-ttu-id="e64d5-174">設定資料來源精靈會使用原始\_{0} 與名稱中的每個原始參數`UpdateCommand`和`DeleteCommand`屬性和`UpdateParameters`和`DeleteParameters`集合據此。</span><span class="sxs-lookup"><span data-stu-id="e64d5-174">The Configure Data Source wizard uses original\_{0} and names each original parameter in the `UpdateCommand` and `DeleteCommand` properties and `UpdateParameters` and `DeleteParameters` collections accordingly.</span></span>

> [!NOTE]
> <span data-ttu-id="e64d5-175">因為我們重新未使用插入功能，SqlDataSource 控制項 s 隨意移除`InsertCommand`屬性和其`InsertParameters`集合。</span><span class="sxs-lookup"><span data-stu-id="e64d5-175">Since we re not using the SqlDataSource control s inserting capabilities, feel free to remove the `InsertCommand` property and its `InsertParameters` collection.</span></span>


## <a name="correctly-handlingnullvalues"></a><span data-ttu-id="e64d5-176">正確地處理`NULL`值</span><span class="sxs-lookup"><span data-stu-id="e64d5-176">Correctly Handling`NULL`Values</span></span>

<span data-ttu-id="e64d5-177">不幸的是，增強型`UPDATE`和`DELETE`自動設定資料來源精靈使用開放式並行存取時的陳述式產生執行*不*工作包含的記錄與`NULL`值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-177">Unfortunately, the augmented `UPDATE` and `DELETE` statements autogenerated by the Configure Data Source wizard when using optimistic concurrency do *not* work with records that contain `NULL` values.</span></span> <span data-ttu-id="e64d5-178">若要查看原因，請考慮我們 SqlDataSource 的`UpdateCommand`:</span><span class="sxs-lookup"><span data-stu-id="e64d5-178">To see why, consider our SqlDataSource s `UpdateCommand`:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample6.sql)]

<span data-ttu-id="e64d5-179">`UnitPrice`中的資料行`Products`資料表可以有`NULL`值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-179">The `UnitPrice` column in the `Products` table can have `NULL` values.</span></span> <span data-ttu-id="e64d5-180">如果特定資料錄有`NULL`值`UnitPrice`、`WHERE`子句部分`[UnitPrice] = @original_UnitPrice`將*一律*評估為 False，因為`NULL = NULL`一律會傳回 False。</span><span class="sxs-lookup"><span data-stu-id="e64d5-180">If a particular record has a `NULL` value for `UnitPrice`, the `WHERE` clause portion `[UnitPrice] = @original_UnitPrice` will *always* evaluate to False because `NULL = NULL` always returns False.</span></span> <span data-ttu-id="e64d5-181">因此，記錄包含`NULL`值不能編輯或刪除，做為`UPDATE`和`DELETE`陳述式`WHERE`子句贏了 t 傳回来更新或刪除任何資料列。</span><span class="sxs-lookup"><span data-stu-id="e64d5-181">Therefore, records that contain `NULL` values cannot be edited or deleted, as the `UPDATE` and `DELETE` statements `WHERE` clauses won t return any rows to update or delete.</span></span>

> [!NOTE]
> <span data-ttu-id="e64d5-182">此第一次報告錯誤給 Microsoft 年 6 月的 2004 中[SqlDataSource 會產生不正確的 SQL 陳述式](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937)並 stage 預計在下一版的 ASP.NET 中修正。</span><span class="sxs-lookup"><span data-stu-id="e64d5-182">This bug was first reported to Microsoft in June of 2004 in [SqlDataSource Generates Incorrect SQL Statements](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93937) and is reportedly scheduled to be fixed in the next version of ASP.NET.</span></span>


<span data-ttu-id="e64d5-183">若要修正此問題，我們必須手動更新`WHERE`子句中同時`UpdateCommand`和`DeleteCommand`屬性**所有**可以具有的資料行`NULL`值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-183">To fix this, we have to manually update the `WHERE` clauses in both the `UpdateCommand` and `DeleteCommand` properties for **all** columns that can have `NULL` values.</span></span> <span data-ttu-id="e64d5-184">一般情況下，變更`[ColumnName] = @original_ColumnName`至：</span><span class="sxs-lookup"><span data-stu-id="e64d5-184">In general, change `[ColumnName] = @original_ColumnName` to:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample7.sql)]

<span data-ttu-id="e64d5-185">這項修改可直接透過宣告式標記，透過從 屬性 視窗的 UpdateQuery 或 DeleteQuery 選項或透過更新和刪除索引標籤的 指定自訂 SQL 陳述式或預存程序選項的設定資料來源精靈。</span><span class="sxs-lookup"><span data-stu-id="e64d5-185">This modification can be made directly through the declarative markup, via the UpdateQuery or DeleteQuery options from the Properties window, or through the UPDATE and DELETE tabs in the Specify a custom SQL statement or stored procedure option in the Configure Data Source wizard.</span></span> <span data-ttu-id="e64d5-186">同樣地，這項修改必須要有所*每*中的資料行`UpdateCommand`和`DeleteCommand`s`WHERE`子句可以包含`NULL`值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-186">Again, this modification must be made for *every* column in the `UpdateCommand` and `DeleteCommand` s `WHERE` clause that can contain `NULL` values.</span></span>

<span data-ttu-id="e64d5-187">將此套用到我們的範例會產生下列修改`UpdateCommand`和`DeleteCommand`值：</span><span class="sxs-lookup"><span data-stu-id="e64d5-187">Applying this to our example results in the following modified `UpdateCommand` and `DeleteCommand` values:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample8.sql)]

## <a name="step-2-adding-a-gridview-with-edit-and-delete-options"></a><span data-ttu-id="e64d5-188">步驟 2： 新增與編輯和刪除選項的 GridView</span><span class="sxs-lookup"><span data-stu-id="e64d5-188">Step 2: Adding a GridView with Edit and Delete Options</span></span>

<span data-ttu-id="e64d5-189">使用 SqlDataSource，設定為支援開放式並行存取，所有剩下的都只有將資料 Web 控制項加入至頁面，它會利用此並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="e64d5-189">With the SqlDataSource configured to support optimistic concurrency, all that remains is to add a data Web control to the page that utilizes this concurrency control.</span></span> <span data-ttu-id="e64d5-190">本教學課程，可讓 s 新增的 GridView 會提供這兩個編輯和刪除功能。</span><span class="sxs-lookup"><span data-stu-id="e64d5-190">For this tutorial, let s add a GridView that provides both edit and delete functionality.</span></span> <span data-ttu-id="e64d5-191">若要達成此目的，將 GridView 拖曳從工具箱拖曳至設計工具和設定其`ID`至`Products`。</span><span class="sxs-lookup"><span data-stu-id="e64d5-191">To accomplish this, drag a GridView from the Toolbox onto the Designer and set its `ID` to `Products`.</span></span> <span data-ttu-id="e64d5-192">從 GridView s 智慧標籤，將它繫結`ProductsDataSourceWithOptimisticConcurrency`SqlDataSource 控制項加入在步驟 1 中。</span><span class="sxs-lookup"><span data-stu-id="e64d5-192">From the GridView s smart tag, bind it to the `ProductsDataSourceWithOptimisticConcurrency` SqlDataSource control added in Step 1.</span></span> <span data-ttu-id="e64d5-193">最後，請檢查從智慧標籤的 [啟用編輯和啟用刪除] 選項。</span><span class="sxs-lookup"><span data-stu-id="e64d5-193">Finally, check the Enable Editing and Enable Deleting options from the smart tag.</span></span>


<span data-ttu-id="e64d5-194">[![將 GridView 繫結至 SqlDataSource 並啟用編輯和刪除](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-194">[![Bind the GridView to the SqlDataSource and Enable Editing and Deleting](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image6.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.png)</span></span>

<span data-ttu-id="e64d5-195">**圖 6**： 繫結的 GridView 的 SqlDataSource 和啟用編輯和刪除 ([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-195">**Figure 6**: Bind the GridView to the SqlDataSource and Enable Editing and Deleting ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image10.png))</span></span>


<span data-ttu-id="e64d5-196">加入後 GridView，設定其外觀藉由移除`ProductID`BoundField，變更`ProductName`BoundField s`HeaderText`屬性設為產品，並更新`UnitPrice`BoundField 使其`HeaderText`屬性只要價格。</span><span class="sxs-lookup"><span data-stu-id="e64d5-196">After adding the GridView, configure its appearance by removing the `ProductID` BoundField, changing the `ProductName` BoundField s `HeaderText` property to Product, and updating the `UnitPrice` BoundField so that its `HeaderText` property is simply Price.</span></span> <span data-ttu-id="e64d5-197">在理想情況下，我們 d 增強編輯介面，以包含如 RequiredFieldValidator`ProductName`值及針對 CompareValidator `UnitPrice` （以確保 s 已正確格式化的數值） 的值。</span><span class="sxs-lookup"><span data-stu-id="e64d5-197">Ideally, we d enhance the editing interface to include a RequiredFieldValidator for the `ProductName` value and a CompareValidator for the `UnitPrice` value (to ensure it s a properly formatted numeric value).</span></span> <span data-ttu-id="e64d5-198">請參閱[自訂的資料修改介面](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md)教學課程，更深入查看自訂 GridView s 中的編輯介面。</span><span class="sxs-lookup"><span data-stu-id="e64d5-198">Refer to the [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorial for a more in-depth look at customizing the GridView s editing interface.</span></span>

> [!NOTE]
> <span data-ttu-id="e64d5-199">必須啟用 s 檢視狀態，因為原始的值從 GridView 傳遞至 SqlDataSource GridView 儲存在檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="e64d5-199">The GridView s view state must be enabled since the original values passed from the GridView to the SqlDataSource are stored in view state.</span></span>


<span data-ttu-id="e64d5-200">進行這些修改以 GridView 後, GridView 和 SqlDataSource 宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="e64d5-200">After making these modifications to the GridView, the GridView and SqlDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample9.aspx)]

<span data-ttu-id="e64d5-201">若要查看開放式並行存取控制，在動作中的，開啟兩個瀏覽器視窗，並載入`OptimisticConcurrency.aspx`頁面中的。</span><span class="sxs-lookup"><span data-stu-id="e64d5-201">To see the optimistic concurrency control in action, open two browser windows and load the `OptimisticConcurrency.aspx` page in both.</span></span> <span data-ttu-id="e64d5-202">按一下編輯按鈕，在這兩個瀏覽器中的第一個產品。</span><span class="sxs-lookup"><span data-stu-id="e64d5-202">Click on the Edit buttons for the first product in both browsers.</span></span> <span data-ttu-id="e64d5-203">在瀏覽器，變更產品名稱，按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="e64d5-203">In one browser, change the product name and click Update.</span></span> <span data-ttu-id="e64d5-204">瀏覽器會回傳和 GridView 會傳回其預先編輯模式，以顯示新的產品名稱，剛建立的記錄。</span><span class="sxs-lookup"><span data-stu-id="e64d5-204">The browser will postback and the GridView will return to its pre-editing mode, showing the new product name for the record just edited.</span></span>

<span data-ttu-id="e64d5-205">在第二個瀏覽器視窗中，變更的價格 （但保留做為其原始值的產品名稱），按一下 [更新]。</span><span class="sxs-lookup"><span data-stu-id="e64d5-205">In the second browser window, change the price (but leave the product name as its original value) and click Update.</span></span> <span data-ttu-id="e64d5-206">在回傳時，方格會設定為其預先編輯模式，但是價格的變更不會記錄。</span><span class="sxs-lookup"><span data-stu-id="e64d5-206">On postback, the grid returns to its pre-editing mode, but the change to the price is not recorded.</span></span> <span data-ttu-id="e64d5-207">第二個瀏覽器會顯示相同的值與第一個新的產品名稱，舊價格。</span><span class="sxs-lookup"><span data-stu-id="e64d5-207">The second browser shows the same value as the first one the new product name with the old price.</span></span> <span data-ttu-id="e64d5-208">在第二個瀏覽器視窗中所做的變更將會遺失。</span><span class="sxs-lookup"><span data-stu-id="e64d5-208">The changes made in the second browser window were lost.</span></span> <span data-ttu-id="e64d5-209">此外，變更將會遺失而不是無訊息模式，因為發生任何例外狀況或訊息，指出並行違規只發生。</span><span class="sxs-lookup"><span data-stu-id="e64d5-209">Moreover, the changes were lost rather quietly, as there was no exception or message indicating that a concurrency violation just occurred.</span></span>


<span data-ttu-id="e64d5-210">[![第二個瀏覽器視窗中的變更已無訊息方式中斷](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-210">[![The Changes in the Second Browser Window Were Silently Lost](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image7.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image11.png)</span></span>

<span data-ttu-id="e64d5-211">**圖 7**： 在第二個瀏覽器視窗以無訊息模式遺失的變更 ([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-211">**Figure 7**: The Changes in the Second Browser Window Were Silently Lost ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image12.png))</span></span>


<span data-ttu-id="e64d5-212">第二個瀏覽器的變更原因未認可的原因，是因為`UPDATE`陳述式的`WHERE`子句篩選掉所有記錄，因此不會影響任何資料列。</span><span class="sxs-lookup"><span data-stu-id="e64d5-212">The reason why the second browser s changes were not committed was because the `UPDATE` statement s `WHERE` clause filtered out all records and therefore did not affect any rows.</span></span> <span data-ttu-id="e64d5-213">可讓查看 s`UPDATE`一次陳述式：</span><span class="sxs-lookup"><span data-stu-id="e64d5-213">Let s look at the `UPDATE` statement again:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample10.sql)]

<span data-ttu-id="e64d5-214">當第二個瀏覽器視窗更新記錄時，原始的產品名稱中指定`WHERE`子句規定 t 相符項目上現有的產品名稱 （因為它已變更第一個瀏覽器）。</span><span class="sxs-lookup"><span data-stu-id="e64d5-214">When the second browser window updates the record, the original product name specified in the `WHERE` clause doesn t match up with the existing product name (since it was changed by the first browser).</span></span> <span data-ttu-id="e64d5-215">因此，在陳述式`[ProductName] = @original_ProductName`會傳回 False，而`UPDATE`不會影響任何記錄。</span><span class="sxs-lookup"><span data-stu-id="e64d5-215">Therefore, the statement `[ProductName] = @original_ProductName` returns False, and the `UPDATE` does not affect any records.</span></span>

> [!NOTE]
> <span data-ttu-id="e64d5-216">Delete 運作方式相同。</span><span class="sxs-lookup"><span data-stu-id="e64d5-216">Delete works in the same manner.</span></span> <span data-ttu-id="e64d5-217">開啟兩個瀏覽器視窗，以開始編輯指定的產品，其中包含一個項目，並儲存其變更。</span><span class="sxs-lookup"><span data-stu-id="e64d5-217">With two browser windows open, start by editing a given product with one, and then saving its changes.</span></span> <span data-ttu-id="e64d5-218">在儲存之後所做的變更一種瀏覽器中，按一下 [刪除] 按鈕中的其他相同的產品。</span><span class="sxs-lookup"><span data-stu-id="e64d5-218">After saving the changes in the one browser, click the Delete button for the same product in the other.</span></span> <span data-ttu-id="e64d5-219">由於原始值不要中匹配`DELETE`陳述式的`WHERE`子句，delete 以無訊息模式失敗。</span><span class="sxs-lookup"><span data-stu-id="e64d5-219">Since the original values don t match up in the `DELETE` statement s `WHERE` clause, the delete silently fails.</span></span>


<span data-ttu-id="e64d5-220">從第二個瀏覽器視窗之後，按一下方格中的 [更新] 按鈕回到前編輯模式中，但其變更將會遺失使用者 s 檢視方塊。</span><span class="sxs-lookup"><span data-stu-id="e64d5-220">From the end user s perspective in the second browser window, after clicking the Update button the grid returns to the pre-editing mode, but their changes were lost.</span></span> <span data-ttu-id="e64d5-221">不過，那里 s 其變更 professionals t 黏貼沒有視覺回應。</span><span class="sxs-lookup"><span data-stu-id="e64d5-221">However, there s no visual feedback that their changes didn t stick.</span></span> <span data-ttu-id="e64d5-222">在理想情況下，如果使用者 s 會失去變更的並行存取違規，我們 d 通知，而且或許保留方格編輯模式。</span><span class="sxs-lookup"><span data-stu-id="e64d5-222">Ideally, if a user s changes are lost to a concurrency violation, we d notify them and, perhaps, keep the grid in edit mode.</span></span> <span data-ttu-id="e64d5-223">可讓 s 看看如何完成這項作業。</span><span class="sxs-lookup"><span data-stu-id="e64d5-223">Let s look at how to accomplish this.</span></span>

## <a name="step-3-determining-when-a-concurrency-violation-has-occurred"></a><span data-ttu-id="e64d5-224">步驟 3： 決定發生並行存取違規時</span><span class="sxs-lookup"><span data-stu-id="e64d5-224">Step 3: Determining When a Concurrency Violation Has Occurred</span></span>

<span data-ttu-id="e64d5-225">並行違規拒絕其中一個已做的變更，因為會是很好的並行存取違規發生時警示使用者。</span><span class="sxs-lookup"><span data-stu-id="e64d5-225">Since a concurrency violation rejects the changes one has made, it would be nice to alert the user when a concurrency violation has occurred.</span></span> <span data-ttu-id="e64d5-226">若要提醒使用者，讓的標籤 Web 控制項加入頁面頂端的名為`ConcurrencyViolationMessage`其`Text`屬性會顯示下列訊息： 您嘗試更新或刪除已由其他使用者同時更新一筆記錄。</span><span class="sxs-lookup"><span data-stu-id="e64d5-226">To alert the user, let s add a Label Web control to the top of the page named `ConcurrencyViolationMessage` whose `Text` property displays the following message: You have attempted to update or delete a record that was simultaneously updated by another user.</span></span> <span data-ttu-id="e64d5-227">請檢閱其他使用者的變更再取消復原您的更新或刪除。</span><span class="sxs-lookup"><span data-stu-id="e64d5-227">Please review the other user's changes and then redo your update or delete.</span></span> <span data-ttu-id="e64d5-228">設定標籤控制項 s`CssClass`警告，也就是 CSS 類別屬性中定義`Styles.css`會以紅色、 斜體、 粗體和大字型顯示的文字。</span><span class="sxs-lookup"><span data-stu-id="e64d5-228">Set the Label control s `CssClass` property to Warning, which is a CSS class defined in `Styles.css` that displays text in a red, italic, bold, and large font.</span></span> <span data-ttu-id="e64d5-229">最後，設定標籤 s`Visible`和`EnableViewState`屬性`False`。</span><span class="sxs-lookup"><span data-stu-id="e64d5-229">Finally, set the Label s `Visible` and `EnableViewState` properties to `False`.</span></span> <span data-ttu-id="e64d5-230">這樣會隱藏除了其中我們明確設定的回傳標籤其`Visible`屬性`True`。</span><span class="sxs-lookup"><span data-stu-id="e64d5-230">This will hide the Label except for only those postbacks where we explicitly set its `Visible` property to `True`.</span></span>


<span data-ttu-id="e64d5-231">[![將標籤控制項加入至頁面，顯示警告](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-231">[![Add a Label Control to the Page to Display the Warning](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image8.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image13.png)</span></span>

<span data-ttu-id="e64d5-232">**圖 8**： 將標籤控制項加入至頁面，顯示警告 ([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-232">**Figure 8**: Add a Label Control to the Page to Display the Warning ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image14.png))</span></span>


<span data-ttu-id="e64d5-233">當執行更新或刪除，GridView s`RowUpdated`和`RowDeleted`事件處理常式之後執行要求的更新或刪除其資料來源控制項所引發。</span><span class="sxs-lookup"><span data-stu-id="e64d5-233">When performing an update or delete, the GridView s `RowUpdated` and `RowDeleted` event handlers fire after its data source control has performed the requested update or delete.</span></span> <span data-ttu-id="e64d5-234">我們可以判斷多少資料列受到這些事件處理常式進行此作業。</span><span class="sxs-lookup"><span data-stu-id="e64d5-234">We can determine how many rows were affected by the operation from these event handlers.</span></span> <span data-ttu-id="e64d5-235">零個資料列受到影響，如果我們想要顯示`ConcurrencyViolationMessage`標籤。</span><span class="sxs-lookup"><span data-stu-id="e64d5-235">If zero rows were affected, we want to display the `ConcurrencyViolationMessage` Label.</span></span>

<span data-ttu-id="e64d5-236">建立兩個事件處理常式`RowUpdated`和`RowDeleted`事件並加入下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="e64d5-236">Create an event handler for both the `RowUpdated` and `RowDeleted` events and add the following code:</span></span>


[!code-vb[Main](implementing-optimistic-concurrency-with-the-sqldatasource-vb/samples/sample11.vb)]

<span data-ttu-id="e64d5-237">這兩個事件處理常式檢查`e.AffectedRows`屬性和它等於 0，如果設定`ConcurrencyViolationMessage`標籤 s`Visible`屬性`True`。</span><span class="sxs-lookup"><span data-stu-id="e64d5-237">In both event handlers we check the `e.AffectedRows` property and, if it equals 0, set the `ConcurrencyViolationMessage` Label s `Visible` property to `True`.</span></span> <span data-ttu-id="e64d5-238">在`RowUpdated`事件處理常式中，我們也指示停留在編輯模式，藉由設定 GridView`KeepInEditMode`屬性設定為 true。</span><span class="sxs-lookup"><span data-stu-id="e64d5-238">In the `RowUpdated` event handler, we also instruct the GridView to stay in edit mode by setting the `KeepInEditMode` property to true.</span></span> <span data-ttu-id="e64d5-239">在此情況下，我們需要重新繫結至資料格，讓其他使用者的資料載入至編輯介面。</span><span class="sxs-lookup"><span data-stu-id="e64d5-239">In doing so, we need to rebind the data to the grid so that the other user s data is loaded into the editing interface.</span></span> <span data-ttu-id="e64d5-240">這會透過呼叫 GridView 的`DataBind()`方法。</span><span class="sxs-lookup"><span data-stu-id="e64d5-240">This is accomplished by calling the GridView s `DataBind()` method.</span></span>

<span data-ttu-id="e64d5-241">如圖 9 所示，使用這些兩個事件處理常式中，每次發生並行存取違規時，會顯示非常值得注意的訊息。</span><span class="sxs-lookup"><span data-stu-id="e64d5-241">As Figure 9 shows, with these two event handlers, a very noticeable message is displayed whenever a concurrency violation occurs.</span></span>


<span data-ttu-id="e64d5-242">[![遇到並行違規時顯示一則訊息](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="e64d5-242">[![A Message is Displayed in the Face of a Concurrency Violation](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image9.gif)](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image15.png)</span></span>

<span data-ttu-id="e64d5-243">**圖 9**： 遇到並行違規時，就會顯示訊息 ([按一下以檢視完整大小的影像](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image16.png))</span><span class="sxs-lookup"><span data-stu-id="e64d5-243">**Figure 9**: A Message is Displayed in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-with-the-sqldatasource-vb/_static/image16.png))</span></span>


## <a name="summary"></a><span data-ttu-id="e64d5-244">總結</span><span class="sxs-lookup"><span data-stu-id="e64d5-244">Summary</span></span>

<span data-ttu-id="e64d5-245">建立 web 應用程式時，多個並行使用者編輯相同的資料，請務必考慮並行控制選項。</span><span class="sxs-lookup"><span data-stu-id="e64d5-245">When creating a web application where multiple, concurrent users may be editing the same data, it is important to consider concurrency control options.</span></span> <span data-ttu-id="e64d5-246">根據預設，ASP.NET Web 控制項的資料和資料來源控制項不會採用任何並行存取控制。</span><span class="sxs-lookup"><span data-stu-id="e64d5-246">By default, the ASP.NET data Web controls and data source controls do not employ any concurrency control.</span></span> <span data-ttu-id="e64d5-247">當我們在本教學課程中所見，實作開放式並行存取控制與 SqlDataSource 會相當快速及簡單。</span><span class="sxs-lookup"><span data-stu-id="e64d5-247">As we saw in this tutorial, implementing optimistic concurrency control with the SqlDataSource is relatively quick and easy.</span></span> <span data-ttu-id="e64d5-248">SqlDataSource 會處理大部分的 legwork，針對您加入夾帶`WHERE`子句來自動產生`UPDATE`和`DELETE`但有陳述式會在處理中的少數微妙`NULL`值資料行中所述正確地處理`NULL`值 > 一節。</span><span class="sxs-lookup"><span data-stu-id="e64d5-248">The SqlDataSource handles most of the legwork for your adding augmented `WHERE` clauses to the autogenerated `UPDATE` and `DELETE` statements but there are a few subtleties in handling `NULL` value columns, as discussed in the Correctly Handling `NULL` Values section.</span></span>

<span data-ttu-id="e64d5-249">本教學課程結束時，我們檢驗 SqlDataSource。</span><span class="sxs-lookup"><span data-stu-id="e64d5-249">This tutorial concludes our examination of the SqlDataSource.</span></span> <span data-ttu-id="e64d5-250">我們其餘的教學課程會傳回處理使用 ObjectDataSource 和階層式的架構資料。</span><span class="sxs-lookup"><span data-stu-id="e64d5-250">Our remaining tutorials will return to working with data using the ObjectDataSource and tiered architecture.</span></span>

<span data-ttu-id="e64d5-251">祝您程式設計 ！</span><span class="sxs-lookup"><span data-stu-id="e64d5-251">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="e64d5-252">關於作者</span><span class="sxs-lookup"><span data-stu-id="e64d5-252">About the Author</span></span>

<span data-ttu-id="e64d5-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七個 ASP/ASP.NET 書籍和的創辦[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已從 1998 年使用 Microsoft Web 技術。</span><span class="sxs-lookup"><span data-stu-id="e64d5-253">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="e64d5-254">Scott 可做為獨立顧問、 訓練和寫入器。</span><span class="sxs-lookup"><span data-stu-id="e64d5-254">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="e64d5-255">他最新的活頁簿[ *Sam 教導您自己 ASP.NET 2.0 24 小時內*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="e64d5-255">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="e64d5-256">他可以在達到[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或透過他的部落格，這可以在找到[http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="e64d5-256">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

>[!div class="step-by-step"]
[<span data-ttu-id="e64d5-257">上一步</span><span class="sxs-lookup"><span data-stu-id="e64d5-257">Previous</span></span>](inserting-updating-and-deleting-data-with-the-sqldatasource-vb.md)
