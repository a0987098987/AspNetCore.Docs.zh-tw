---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: 專案 Katana 概觀 |Microsoft 文件
author: howarddierking
description: ASP.NET 架構之已超過十年，並在平台啟用無數網站和服務的開發。 為 Web 應用程式...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/30/2013
ms.topic: article
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
ms.technology: ''
ms.prod: .net-framework
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 3c2bcbbc6e506af759f6d77af17d015278cc0bdf
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2018
ms.locfileid: "30878759"
---
<a name="an-overview-of-project-katana"></a><span data-ttu-id="00b9c-104">專案 Katana 的概觀</span><span class="sxs-lookup"><span data-stu-id="00b9c-104">An Overview of Project Katana</span></span>
====================
<span data-ttu-id="00b9c-105">由[Howard Dierking](https://github.com/howarddierking)</span><span class="sxs-lookup"><span data-stu-id="00b9c-105">by [Howard Dierking](https://github.com/howarddierking)</span></span>

> <span data-ttu-id="00b9c-106">ASP.NET 架構之已超過十年，並在平台啟用無數網站和服務的開發。</span><span class="sxs-lookup"><span data-stu-id="00b9c-106">The ASP.NET Framework has been around for over ten years, and the platform has enabled the development of countless Web sites and services.</span></span> <span data-ttu-id="00b9c-107">Web 應用程式開發策略有發展，因為架構已經能夠持續發展與 ASP.NET MVC 和 ASP.NET Web API 等技術的步驟。</span><span class="sxs-lookup"><span data-stu-id="00b9c-107">As Web application development strategies have evolved, the framework has been able to evolve in step with technologies like ASP.NET MVC and ASP.NET Web API.</span></span> <span data-ttu-id="00b9c-108">做 Web 應用程式開發雲端運算世界演化其下一個步驟，專案[Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)提供基礎的元件，以 ASP.NET 應用程式，讓他們能夠為彈性、 可攜性，輕量型的並提供更佳的效能-專案、 將另一種方式[Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)雲端最佳化您的 ASP.NET 應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-108">As Web application development takes its next evolutionary step into the world of cloud computing, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) provides the underlying set of components to ASP.NET applications, enabling them to be flexible, portable, lightweight, and provide better performance – put another way, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud optimizes your ASP.NET applications.</span></span>


## <a name="why-katana--why-now"></a><span data-ttu-id="00b9c-109">為什麼 Katana – 為何現在嗎？</span><span class="sxs-lookup"><span data-stu-id="00b9c-109">Why Katana – Why Now?</span></span>

 <span data-ttu-id="00b9c-110">不論是否其中一個討論開發人員 framework 或使用者產品，務必了解建立基礎的升級過程中的與產品包含了解產品所建立。</span><span class="sxs-lookup"><span data-stu-id="00b9c-110">Regardless whether one is discussing a developer framework or end-user product, it's important to understand the underlying motivations for creating the product – and part of that includes knowing who the product was created for.</span></span> <span data-ttu-id="00b9c-111">請注意兩個客戶最初建立 ASP.NET。</span><span class="sxs-lookup"><span data-stu-id="00b9c-111">ASP.NET was originally created with two customers in mind.</span></span>   
  
<span data-ttu-id="00b9c-112">**第一個群組的客戶是傳統 ASP 開發人員。**</span><span class="sxs-lookup"><span data-stu-id="00b9c-112">**The first group of customers was classic ASP developers.**</span></span> <span data-ttu-id="00b9c-113">同時，ASP 就是一種主要的技術，用於建立網站和應用程式動態的資料導向 interweaving 標記和伺服器端指令碼。</span><span class="sxs-lookup"><span data-stu-id="00b9c-113">At the time, ASP was one of the primary technologies for creating dynamic, data-driven Web sites and applications by interweaving markup and server-side script.</span></span> <span data-ttu-id="00b9c-114">ASP 執行階段提供抽象的基礎 HTTP 通訊協定和 Web 伺服器的核心層面，並且提供存取至其他服務這類工作階段和應用程式的狀態管理，快取，等等之物件的一組伺服器端指令碼。雖然強大、 傳統 ASP 應用程式變得容易管理，因為它們成長的大小和複雜度。</span><span class="sxs-lookup"><span data-stu-id="00b9c-114">The ASP runtime supplied server-side script with a set of objects that abstracted core aspects of the underlying HTTP protocol and Web server and provided access to additional services such session and application state management, cache, etc. While powerful, classic ASP applications became a challenge to manage as they grew in size and complexity.</span></span> <span data-ttu-id="00b9c-115">這是結構的主要是結構的因為缺少的指令碼結合所產生的程式碼和標記的交錯情形的程式碼的重複的環境中找到。</span><span class="sxs-lookup"><span data-stu-id="00b9c-115">This was largely due to the lack of structure found in scripting environments coupled with the duplication of code resulting from the interleaving of code and markup.</span></span> <span data-ttu-id="00b9c-116">為了處理某些其挑戰時利用傳統 ASP 的優勢，ASP.NET 利用語言提供的物件導向的.NET framework 同時也保留的伺服器端程式設計模型的程式碼組織哪些傳統 asp 開發人員已成長習慣。</span><span class="sxs-lookup"><span data-stu-id="00b9c-116">In order to capitalize on the strengths of classic ASP while addressing some of its challenges, ASP.NET took advantage of the code organization provided by the object-oriented languages of the .NET Framework while also preserving the server-side programming model to which classic ASP developers had grown accustomed.</span></span>

<span data-ttu-id="00b9c-117">**適用於 ASP.NET 的目標客戶的第二個群組是 Windows 商務應用程式開發人員。**</span><span class="sxs-lookup"><span data-stu-id="00b9c-117">**The second group of target customers for ASP.NET was Windows business application developers.**</span></span> <span data-ttu-id="00b9c-118">不同於傳統 ASP 開發人員已習慣寫入 HTML 標記和程式碼，以產生更多的 HTML 標記，WinForms （如同之前 VB6 開發人員） 的開發人員已習慣於設計階段體驗包含畫布與一組豐富的使用者控制項的介面。</span><span class="sxs-lookup"><span data-stu-id="00b9c-118">Unlike classic ASP developers, who were accustomed to writing HTML markup and the code to generate more HTML markup, WinForms developers (like the VB6 developers before them) were accustomed to a design time experience that included a canvas and a rich set of user interface controls.</span></span> <span data-ttu-id="00b9c-119">第一個版本的 ASP.NET – 也稱為 「 Web 表單 」 提供類似的設計階段經驗以及使用者介面元件的伺服器端事件模型和基礎結構功能 （例如 ViewState) 的一組以建立無縫式的開發人員體驗用戶端和伺服器端程式設計之間</span><span class="sxs-lookup"><span data-stu-id="00b9c-119">The first version of ASP.NET – also known as "Web Forms" provided a similar design time experience along with a server-side event model for user interface components and a set of infrastructure features (such as ViewState) to create a seamless developer experience between client and server side programming.</span></span> <span data-ttu-id="00b9c-120">Web Form 有效 hid Web 的無狀態的本質，在已熟悉 WinForms 開發人員可設定狀態的事件模型。</span><span class="sxs-lookup"><span data-stu-id="00b9c-120">Web Forms effectively hid the Web's stateless nature under a stateful event model that was familiar to WinForms developers.</span></span>

### <a name="challenges-raised-by-the-historical-model"></a><span data-ttu-id="00b9c-121">歷程記錄模型所引發的挑戰</span><span class="sxs-lookup"><span data-stu-id="00b9c-121">Challenges Raised by the Historical Model</span></span>

<span data-ttu-id="00b9c-122">**最後的結果是成熟、 具豐富功能的執行階段和開發人員的程式設計模型。**</span><span class="sxs-lookup"><span data-stu-id="00b9c-122">**The net result was a mature, feature-rich runtime and developer programming model.**</span></span> <span data-ttu-id="00b9c-123">不過，與功能豐富的來源值得注意的一些挑戰。</span><span class="sxs-lookup"><span data-stu-id="00b9c-123">However, with that feature-richness came a couple notable challenges.</span></span> <span data-ttu-id="00b9c-124">首先，架構已**龐大**，與不同邏輯單位所緊密結合在相同的 System.Web.dll 組件 （例如 Web form 架構的核心 HTTP 物件） 的功能。</span><span class="sxs-lookup"><span data-stu-id="00b9c-124">Firstly, the framework was **monolithic**, with logically disparate units of functionality being tightly coupled in the same System.Web.dll assembly (for example, the core HTTP objects with the Web forms framework).</span></span> <span data-ttu-id="00b9c-125">其次，ASP.NET 隨附較大的.NET Framework，這表示，它的一部分**版本之間的時間為順序年而定。**</span><span class="sxs-lookup"><span data-stu-id="00b9c-125">Secondly, ASP.NET was included as a part of the larger .NET Framework, which meant that the **time between releases was on the order of years.**</span></span> <span data-ttu-id="00b9c-126">這並不容易，ASP.NET 跟上的所有變更中快速發展 Web 程式開發的情況。</span><span class="sxs-lookup"><span data-stu-id="00b9c-126">This made it difficult for ASP.NET to keep pace with all of the changes happening in rapidly evolving Web development.</span></span> <span data-ttu-id="00b9c-127">最後，System.Web.dll 本身已結合至特定的 Web 裝載選項幾個不同的方式： 網際網路資訊服務 (IIS)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-127">Finally, System.Web.dll itself was coupled in a few different ways to a specific Web hosting option: Internet Information Services (IIS).</span></span>

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a><span data-ttu-id="00b9c-128">演化的步驟執行： ASP.NET MVC 與 ASP.NET Web API</span><span class="sxs-lookup"><span data-stu-id="00b9c-128">Evolutionary steps: ASP.NET MVC and ASP.NET Web API</span></span>

<span data-ttu-id="00b9c-129">與 Web 程式開發中發生大量變更 ！</span><span class="sxs-lookup"><span data-stu-id="00b9c-129">And lots of change was happening in Web development!</span></span> <span data-ttu-id="00b9c-130">Web 應用程式已逐漸正在所開發的一系列的小型，已取得焦點的元件，而不是大型的架構。</span><span class="sxs-lookup"><span data-stu-id="00b9c-130">Web applications were increasingly being developed as a series of small, focused components rather than large frameworks.</span></span> <span data-ttu-id="00b9c-131">元件，以及與所發行的頻率數目已增加速度過快。</span><span class="sxs-lookup"><span data-stu-id="00b9c-131">The number of components as well as the frequency with which they were released was increasing at an ever faster rate.</span></span> <span data-ttu-id="00b9c-132">很顯然與 Web 步調保留到需要架構，因此更大且更具豐富功能，而取得較小、 低耦合且更受關注**ASP.NET 小組花費幾個演化的步驟，以啟用 ASP.NET 以一系列隨插即用的 Web 元件，而不是單一架構**。</span><span class="sxs-lookup"><span data-stu-id="00b9c-132">It was clear that keeping pace with the Web would require frameworks to get smaller, decoupled and more focused rather than larger and more feature-rich, therefore the **ASP.NET team took several evolutionary steps to enable ASP.NET as a family of pluggable Web components rather than a single framework**.</span></span>

<span data-ttu-id="00b9c-133">其中一個最早變更是搭配滑軌安裝在 Web 開發架構，例如 Ruby 由於已知的模型檢視控制器 (MVC) 設計模式的普及率升高。</span><span class="sxs-lookup"><span data-stu-id="00b9c-133">One of the early changes was the rise in popularity of the well-known model-view-controller (MVC) design pattern thanks to Web development frameworks like Ruby on Rails.</span></span> <span data-ttu-id="00b9c-134">這種樣式的建置 Web 應用程式提供開發人員應用程式的標記，同時仍然保留的標記和商務邏輯，這是一個適用於 ASP.NET 的初始賣點分隔較大的控制權。</span><span class="sxs-lookup"><span data-stu-id="00b9c-134">This style of building Web applications gave the developer greater control over her application's markup while still preserving the separation of markup and business logic, which was one of the initial selling points for ASP.NET.</span></span> <span data-ttu-id="00b9c-135">為了要符合需求的這種樣式的 Web 應用程式開發，Microsoft 花費得以將其自身更適合未來， **out of band 開發 ASP.NET MVC** （並不包括.NET Framework 中）。</span><span class="sxs-lookup"><span data-stu-id="00b9c-135">To meet the demand for this style of Web application development, Microsoft took the opportunity to position itself better for the future by **developing ASP.NET MVC out of band** (and not including it in the .NET Framework).</span></span> <span data-ttu-id="00b9c-136">ASP.NET MVC 已發行以獨立下載項目。</span><span class="sxs-lookup"><span data-stu-id="00b9c-136">ASP.NET MVC was released as an independent download.</span></span> <span data-ttu-id="00b9c-137">這會讓工程團隊的彈性來傳遞更新，便是先前可能比更頻繁。</span><span class="sxs-lookup"><span data-stu-id="00b9c-137">This gave the engineering team the flexibility to deliver updates much more frequently than had been previously possible.</span></span>

<span data-ttu-id="00b9c-138">Web 應用程式開發中的另一個主要 shift 已從動態的伺服器產生的網頁 shift 鍵，以使用動態產生通訊的用戶端指令碼頁面區段的靜態初始標記**與後端 Web 應用程式開發介面透過AJAX 要求**。</span><span class="sxs-lookup"><span data-stu-id="00b9c-138">Another major shift in Web application development was the shift from dynamic, server-generated Web pages to static initial markup with dynamic sections of the page generated from client-side script communicating **with backend Web APIs through AJAX requests**.</span></span> <span data-ttu-id="00b9c-139">架構的轉換有助於駭人的 Web Api 和 ASP.NET Web API framework 的開發。</span><span class="sxs-lookup"><span data-stu-id="00b9c-139">This architectural shift helped propel the rise of Web APIs, and the development of the ASP.NET Web API framework.</span></span> <span data-ttu-id="00b9c-140">如果 ASP.NET MVC 是 ASP.NET Web API 的版本會提供另一個有機會進一步做更模組化架構發展 ASP.NET。</span><span class="sxs-lookup"><span data-stu-id="00b9c-140">As in the case of ASP.NET MVC, the release of ASP.NET Web API provided another opportunity to evolve ASP.NET further as a more modular framework.</span></span> <span data-ttu-id="00b9c-141">工程團隊已利用機會和**建置 ASP.NET Web API 時，它有沒有相依性 System.Web.dll 中找到的核心架構型別的任何**。</span><span class="sxs-lookup"><span data-stu-id="00b9c-141">The engineering team took advantage of the opportunity and **built ASP.NET Web API such that it had no dependencies on any of the core framework types found in System.Web.dll**.</span></span> <span data-ttu-id="00b9c-142">此功能啟用兩件事： 首先，它表示 ASP.NET Web API 可能完全獨立的方式發展 （和快速重複，因為它透過 NuGet 傳遞時，它可以繼續）。</span><span class="sxs-lookup"><span data-stu-id="00b9c-142">This enabled two things: first, it meant that ASP.NET Web API could evolve in a completely self-contained manner (and it could continue to iterate quickly because it is delivered via NuGet).</span></span> <span data-ttu-id="00b9c-143">第二，因為有個 System.Web.dll，沒有外部相依性，因此，沒有任何相依性到 IIS，ASP.NET Web API 包含自訂的主控件 （例如主控台應用程式、 Windows 服務等） 中執行的功能</span><span class="sxs-lookup"><span data-stu-id="00b9c-143">Second, because there were no external dependencies to System.Web.dll, and therefore, no dependencies to IIS, ASP.NET Web API included the capability to run in a custom host (for example, a console application, Windows service, etc.)</span></span>

### <a name="the-future-a-nimble-framework"></a><span data-ttu-id="00b9c-144">未來： 靈活架構</span><span class="sxs-lookup"><span data-stu-id="00b9c-144">The Future: A Nimble Framework</span></span>

<span data-ttu-id="00b9c-145">分離互相 framework 元件並再釋放它們需由 NuGet，架構無法立即**更獨立且更快速地逐一查看**。</span><span class="sxs-lookup"><span data-stu-id="00b9c-145">By decoupling framework components from one another and then releasing them on NuGet, frameworks could now **iterate more independently and more quickly**.</span></span> <span data-ttu-id="00b9c-146">此外的功能和彈性的 Web API 的自我裝載功能證實深具吸引力的開發人員想**小型、 輕量級主機**其服務。</span><span class="sxs-lookup"><span data-stu-id="00b9c-146">Additionally, the power and flexibility of Web API's self-hosting capability proved very attractive to developers who wanted a **small, lightweight host** for their services.</span></span> <span data-ttu-id="00b9c-147">已證實該吸引，事實上，其他架構也會想要這項功能，而且這提出新的挑戰，也就是說，每個架構已在它自己的主控件程序中執行它自己的基底位址上，並且需要管理 （啟動、 停止等） 獨立。</span><span class="sxs-lookup"><span data-stu-id="00b9c-147">It proved so attractive, in fact, that other frameworks also wanted this capability, and this surfaced a new challenge in that each framework ran in its own host process on its own base address and needed to be managed (started, stopped, etc.) independently.</span></span> <span data-ttu-id="00b9c-148">現代的 Web 應用程式通常會支援靜態檔案服務、 產生動態頁面、 Web API 和更最近即時-單次/推播通知。</span><span class="sxs-lookup"><span data-stu-id="00b9c-148">A modern Web application generally supports static file serving, dynamic page generation, Web API, and more recently real-time/push notifications.</span></span> <span data-ttu-id="00b9c-149">每個服務，應執行並分開管理，必須要有不只是實際。</span><span class="sxs-lookup"><span data-stu-id="00b9c-149">Expecting that each of these services should be run and managed independently was simply not realistic.</span></span>

<span data-ttu-id="00b9c-150">情況所需的單一裝載抽象的會讓開發人員撰寫的應用程式，從各種不同的元件和架構，然後執行該應用程式支援的主機上。</span><span class="sxs-lookup"><span data-stu-id="00b9c-150">What was needed was a single hosting abstraction that would enable a developer to compose an application from a variety of different components and frameworks, and then run that application on a supporting host.</span></span>

## <a name="the-open-web-interface-for-net-owin"></a><span data-ttu-id="00b9c-151">開啟 Web 介面 for.NET (OWIN)</span><span class="sxs-lookup"><span data-stu-id="00b9c-151">The Open Web Interface for .NET (OWIN)</span></span>

 <span data-ttu-id="00b9c-152">啟發的優點達成[機架](http://rack.github.io/)拼音社群中，.NET 社群的數個成員設定來建立網頁伺服器和 framework 元件之間的抽象概念。</span><span class="sxs-lookup"><span data-stu-id="00b9c-152">Inspired by the benefits achieved by [Rack](http://rack.github.io/) in the Ruby community, several members of the .NET community set out to create an abstraction between Web servers and framework components.</span></span> <span data-ttu-id="00b9c-153">OWIN 抽象的兩個設計目標是很簡單，與所花費的最少的可能相依性的其他 framework 型別。</span><span class="sxs-lookup"><span data-stu-id="00b9c-153">Two design goals for the OWIN abstraction were that it was simple and that it took the fewest possible dependencies on other framework types.</span></span> <span data-ttu-id="00b9c-154">這兩個目標協助確保：</span><span class="sxs-lookup"><span data-stu-id="00b9c-154">These two goals help ensure:</span></span>

- <span data-ttu-id="00b9c-155">新的元件可以更輕鬆地開發並取用。</span><span class="sxs-lookup"><span data-stu-id="00b9c-155">New components could be more easily developed and consumed.</span></span>
- <span data-ttu-id="00b9c-156">應用程式可以更輕鬆地移植主機與潛在整個平台/作業系統之間。</span><span class="sxs-lookup"><span data-stu-id="00b9c-156">Applications could be more easily ported between hosts and potentially entire platforms/operating systems.</span></span>

<span data-ttu-id="00b9c-157">產生的抽象概念是由兩個核心項目所組成。</span><span class="sxs-lookup"><span data-stu-id="00b9c-157">The resulting abstraction consists of two core elements.</span></span> <span data-ttu-id="00b9c-158">第一個是環境目錄。</span><span class="sxs-lookup"><span data-stu-id="00b9c-158">The first is the environment dictionary.</span></span> <span data-ttu-id="00b9c-159">這個資料結構會負責處理 HTTP 要求和回應，以及任何相關伺服器狀態所需的狀態的所有儲存。</span><span class="sxs-lookup"><span data-stu-id="00b9c-159">This data structure is responsible for storing all of the state necessary for processing an HTTP request and response, as well as any relevant server state.</span></span> <span data-ttu-id="00b9c-160">環境字典定義，如下所示：</span><span class="sxs-lookup"><span data-stu-id="00b9c-160">The environment dictionary is defined as follows:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

<span data-ttu-id="00b9c-161">OWIN 相容的網頁伺服器會負責填入資料的內文資料流和 HTTP 要求和回應標頭集合如環境字典。</span><span class="sxs-lookup"><span data-stu-id="00b9c-161">An OWIN-compatible Web server is responsible for populating the environment dictionary with data such as the body streams and header collections for an HTTP request and response.</span></span> <span data-ttu-id="00b9c-162">然後會擴展或更新的字典，包含額外的值，並寫入回應主體資料流的應用程式或架構元件的責任。</span><span class="sxs-lookup"><span data-stu-id="00b9c-162">It is then the responsibility of the application or framework components to populate or update the dictionary with additional values and write to the response body stream.</span></span>

<span data-ttu-id="00b9c-163">除了指定環境目錄的類型，OWIN 規格定義核心字典的索引鍵值組的清單。</span><span class="sxs-lookup"><span data-stu-id="00b9c-163">In addition to specifying the type for the environment dictionary, the OWIN specification defines a list of core dictionary key value pairs.</span></span> <span data-ttu-id="00b9c-164">例如下, 表顯示 HTTP 要求所需的字典索引鍵：</span><span class="sxs-lookup"><span data-stu-id="00b9c-164">For example, the following table shows the required dictionary keys for an HTTP request:</span></span>

| <span data-ttu-id="00b9c-165">索引鍵名稱</span><span class="sxs-lookup"><span data-stu-id="00b9c-165">Key Name</span></span> | <span data-ttu-id="00b9c-166">值描述</span><span class="sxs-lookup"><span data-stu-id="00b9c-166">Value Description</span></span> |
| --- | --- |
| `"owin.RequestBody"` | <span data-ttu-id="00b9c-167">包含要求主體中，如果有任何資料流。</span><span class="sxs-lookup"><span data-stu-id="00b9c-167">A Stream with the request body, if any.</span></span> <span data-ttu-id="00b9c-168">Stream.Null 可能做為預留位置，如果沒有要求主體。</span><span class="sxs-lookup"><span data-stu-id="00b9c-168">Stream.Null MAY be used as a placeholder if there is no request body.</span></span> <span data-ttu-id="00b9c-169">請參閱[要求本文](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-169">See [Request Body](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics).</span></span> |
| `"owin.RequestHeaders"` | <span data-ttu-id="00b9c-170">`IDictionary<string, string[]>`要求標頭。</span><span class="sxs-lookup"><span data-stu-id="00b9c-170">An `IDictionary<string, string[]>` of request headers.</span></span> <span data-ttu-id="00b9c-171">請參閱[標頭](http://owin.org/html/owin.html#3-3-headers)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-171">See [Headers](http://owin.org/html/owin.html#3-3-headers).</span></span> |
| `"owin.RequestMethod"` | <span data-ttu-id="00b9c-172">A`string`包含要求的 HTTP 要求方法 (例如`"GET"`， `"POST"`)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-172">A `string` containing the HTTP request method of the request (e.g., `"GET"`, `"POST"`).</span></span> |
| `"owin.RequestPath"` | <span data-ttu-id="00b9c-173">A`string`包含要求路徑。</span><span class="sxs-lookup"><span data-stu-id="00b9c-173">A `string` containing the request path.</span></span> <span data-ttu-id="00b9c-174">路徑必須相對於 「 根 」 的應用程式委派。請參閱[路徑](http://owin.org/html/owin.html#5-3-paths)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-174">The path MUST be relative to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestPathBase"` | <span data-ttu-id="00b9c-175">A`string`包含對應的應用程式委派; 「 根 」 的要求路徑的一部分，請參閱[路徑](http://owin.org/html/owin.html#5-3-paths)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-175">A `string` containing the portion of the request path corresponding to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestProtocol"` | <span data-ttu-id="00b9c-176">A`string`包含通訊協定名稱和版本 (例如`"HTTP/1.0"`或`"HTTP/1.1"`)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-176">A `string` containing the protocol name and version (e.g. `"HTTP/1.0"` or `"HTTP/1.1"`).</span></span> |
| `"owin.RequestQueryString"` | <span data-ttu-id="00b9c-177">A`string`包含查詢字串元件 HTTP 要求的 URI，而不前置的"？"(例如`"foo=bar&baz=quux"`)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-177">A `string` containing the query string component of the HTTP request URI, without the leading "?" (e.g., `"foo=bar&baz=quux"`).</span></span> <span data-ttu-id="00b9c-178">值可能是空字串。</span><span class="sxs-lookup"><span data-stu-id="00b9c-178">The value may be an empty string.</span></span> |
| `"owin.RequestScheme"` | <span data-ttu-id="00b9c-179">A`string`包含用於要求的 URI 配置 (例如`"http"`， `"https"`); 請參閱[URI 配置](http://owin.org/html/owin.html#5-1-uri-scheme)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-179">A `string` containing the URI scheme used for the request (e.g., `"http"`, `"https"`); see [URI Scheme](http://owin.org/html/owin.html#5-1-uri-scheme).</span></span> |

<span data-ttu-id="00b9c-180">OWIN 的第二個項目是應用程式的委派。</span><span class="sxs-lookup"><span data-stu-id="00b9c-180">The second key element of OWIN is the application delegate.</span></span> <span data-ttu-id="00b9c-181">這是函式簽章會做為 OWIN 應用程式中的所有元件之間的主要介面。</span><span class="sxs-lookup"><span data-stu-id="00b9c-181">This is a function signature which serves as the primary interface between all components in an OWIN application.</span></span> <span data-ttu-id="00b9c-182">應用程式委派的定義如下所示：</span><span class="sxs-lookup"><span data-stu-id="00b9c-182">The definition for the application delegate is as follows:</span></span>

`Func<IDictionary<string, object>, Task>;`

<span data-ttu-id="00b9c-183">應用程式委派則只是其中函式接受環境目錄，做為輸入，並傳回工作的 Func 委派類型的實作。</span><span class="sxs-lookup"><span data-stu-id="00b9c-183">The application delegate then is simply an implementation of the Func delegate type where the function accepts the environment dictionary as input and returns a Task.</span></span> <span data-ttu-id="00b9c-184">此設計有適用於開發人員的幾個含意：</span><span class="sxs-lookup"><span data-stu-id="00b9c-184">This design has several implications for developers:</span></span>

- <span data-ttu-id="00b9c-185">有極少數的類型相依性才能撰寫 OWIN 元件。</span><span class="sxs-lookup"><span data-stu-id="00b9c-185">There are a very small number of type dependencies required in order to write OWIN components.</span></span> <span data-ttu-id="00b9c-186">這樣可大幅增加 OWIN 開發人員的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="00b9c-186">This greatly increases the accessibility of OWIN to developers.</span></span>
- <span data-ttu-id="00b9c-187">非同步設計可讓您能夠有效率地使用它的運算資源，特別是在多個 I/O 密集作業的處理資料的抽象。</span><span class="sxs-lookup"><span data-stu-id="00b9c-187">The asynchronous design enables the abstraction to be efficient with its handling of computing resources, particularly in more I/O intensive operations.</span></span>
- <span data-ttu-id="00b9c-188">因為應用程式委派是不可部分完成的執行單位，而且環境目錄做為參數的委派上執行，因為 OWIN 元件可以輕鬆地鏈結在一起以建立複雜的 HTTP 處理管線。</span><span class="sxs-lookup"><span data-stu-id="00b9c-188">Because the application delegate is an atomic unit of execution and because the environment dictionary is carried as a parameter on the delegate, OWIN components can be easily chained together to create complex HTTP processing pipelines.</span></span>

<span data-ttu-id="00b9c-189">從實作觀點來看，OWIN 是一種規格 ([http://owin.org/html/owin.html](http://owin.org/html/owin.html))。</span><span class="sxs-lookup"><span data-stu-id="00b9c-189">From an implementation perspective, OWIN is a specification ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)).</span></span> <span data-ttu-id="00b9c-190">其目的是為下一個 Web 架構，但規格而不是 Web 架構和 Web 伺服器互動的方式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-190">Its goal is not to be the next Web framework, but rather a specification for how Web frameworks and Web servers interact.</span></span>

<span data-ttu-id="00b9c-191">如果您已經調查[OWIN](http://owin.org/)或[Katana](https://github.com/aspnet/AspNetKatana/wiki)，您可能也會注意到[Owin NuGet 封裝](http://nuget.org/packages/Owin)和 Owin.dll。</span><span class="sxs-lookup"><span data-stu-id="00b9c-191">If you've investigated [OWIN](http://owin.org/) or [Katana](https://github.com/aspnet/AspNetKatana/wiki), you may also have noticed the [Owin NuGet package](http://nuget.org/packages/Owin) and Owin.dll.</span></span> <span data-ttu-id="00b9c-192">此程式庫包含單一介面， [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)，」 會正式制定以及制定中所述的啟動順序[區段 4](http://owin.org/html/owin.html#4-application-startup)的 OWIN 規格。</span><span class="sxs-lookup"><span data-stu-id="00b9c-192">This library contains a single interface, [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), which formalizes and codifies the startup sequence described in [section 4](http://owin.org/html/owin.html#4-application-startup) of the OWIN specification.</span></span> <span data-ttu-id="00b9c-193">而不需以組建 OWIN 伺服器[IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)介面提供具體的參考點，且 Katana 專案元件會使用它。</span><span class="sxs-lookup"><span data-stu-id="00b9c-193">While not required in order to build OWIN servers, the [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) interface provides a concrete reference point, and it is used by the Katana project components.</span></span>

## <a name="project-katana"></a><span data-ttu-id="00b9c-194">專案 Katana</span><span class="sxs-lookup"><span data-stu-id="00b9c-194">Project Katana</span></span>

<span data-ttu-id="00b9c-195">而同時[OWIN](http://owin.org/html/owin.html)規格和*Owin.dll*為社群所擁有和社群執行開放原始碼努力[Katana](https://github.com/aspnet/AspNetKatana/wiki)專案表示 OWIN 集合針對，同時仍開放原始碼，建立與 Microsoft 所發行的元件。</span><span class="sxs-lookup"><span data-stu-id="00b9c-195">Whereas both the [OWIN](http://owin.org/html/owin.html) specification and *Owin.dll* are community owned and community run open source efforts, the [Katana](https://github.com/aspnet/AspNetKatana/wiki) project represents the set of OWIN components that, while still open source, are built and released by Microsoft.</span></span> <span data-ttu-id="00b9c-196">這些元件可包含基礎結構元件，例如主機和伺服器，以及功能的元件，例如驗證元件和架構繫結，例如[SignalR](../../../signalr/index.md)和[ASP.NET 網頁應用程式開發介面](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-196">These components include both infrastructure components, such as hosts and servers, as well as functional components, such as authentication components and bindings to frameworks such as [SignalR](../../../signalr/index.md) and [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md).</span></span> <span data-ttu-id="00b9c-197">專案具有下列三個高階的目標：</span><span class="sxs-lookup"><span data-stu-id="00b9c-197">The project has the following three high level goals:</span></span> 

- <span data-ttu-id="00b9c-198">**可攜式**– 元件應該要能夠輕鬆地取代成新的元件可以使用。</span><span class="sxs-lookup"><span data-stu-id="00b9c-198">**Portable** – Components should be able to be easily substituted for new components as they become available.</span></span> <span data-ttu-id="00b9c-199">這包括所有類型的元件，從伺服器和主機的架構。</span><span class="sxs-lookup"><span data-stu-id="00b9c-199">This includes all types of components, from the framework to the server and host.</span></span> <span data-ttu-id="00b9c-200">此目標的是，第三方架構可以順暢地執行 Microsoft 伺服器上時 Microsoft 架構可能會執行協力廠商伺服器與主機上。</span><span class="sxs-lookup"><span data-stu-id="00b9c-200">The implication of this goal is that third party frameworks can seamlessly run on Microsoft servers while Microsoft frameworks can potentially run on third party servers and hosts.</span></span>
- <span data-ttu-id="00b9c-201">**模組化/彈性**– Katana 專案元件不同於許多架構包括各種功能，預設會開啟，應該是小型和焦點，提供控制應用程式開發人員決定要哪些元件在應用程式中使用。</span><span class="sxs-lookup"><span data-stu-id="00b9c-201">**Modular/flexible**– Unlike many frameworks which include a myriad of features that are turned on by default, Katana project components should be small and focused, giving control over to the application developer in determining which components to use in her application.</span></span>
- <span data-ttu-id="00b9c-202">**輕量型/高效能/可擴充**– 傳統架構的概念分成小型、 一組元件會明確新增應用程式，開發人員所產生的 Katana 應用程式可以使用較少的電腦已取得焦點資源，如此一來，比處理更多的負載，與其他類型的伺服器和架構。</span><span class="sxs-lookup"><span data-stu-id="00b9c-202">**Lightweight/performant/scalable** – By breaking the traditional notion of a framework into a set of small, focused components which are added explicitly by the application developer, a resulting Katana application can consume fewer computing resources, and as a result, handle more load, than with other types of servers and frameworks.</span></span> <span data-ttu-id="00b9c-203">如需求的應用程式需要更多的功能，從基礎結構，那些可以新增至 OWIN 管線中，但那應該是部分應用程式開發人員明確決策。</span><span class="sxs-lookup"><span data-stu-id="00b9c-203">As the requirements of the application demand more features from the underlying infrastructure, those can be added to the OWIN pipeline, but that should be an explicit decision on the part of the application developer.</span></span> <span data-ttu-id="00b9c-204">此外，較低層級元件的替代表示，當它們變成可用，新的高效能伺服器可以順暢地導入以改善 OWIN 應用程式的效能，而不會中斷這些應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-204">Additionally, the substitutability of lower level components means that as they become available, new high performance servers can seamlessly be introduced to improve the performance of OWIN applications without breaking those applications.</span></span>

## <a name="getting-started-with-katana-components"></a><span data-ttu-id="00b9c-205">開始使用 Katana 元件</span><span class="sxs-lookup"><span data-stu-id="00b9c-205">Getting Started with Katana Components</span></span>

<span data-ttu-id="00b9c-206">第一次引進，某層面的[Node.js](http://nodejs.org/)立即吸引人的注意的架構是的簡化的其中一個無法撰寫及執行 Web 伺服器。</span><span class="sxs-lookup"><span data-stu-id="00b9c-206">When it was first introduced, one aspect of the [Node.js](http://nodejs.org/) framework that immediately drew people's attention was the simplicity with which one could author and run a Web server.</span></span> <span data-ttu-id="00b9c-207">如果 Katana 目標所包覆 light 的[Node.js](http://nodejs.org/)，其中可能會依所說 Katana 帶來許多好處進行摘要[Node.js](http://nodejs.org/) （及與它類似的架構） 而不未強制開發人員擲出她知道開發 ASP.NET Web 應用程式相關的一切。</span><span class="sxs-lookup"><span data-stu-id="00b9c-207">If Katana goals were framed in light of [Node.js](http://nodejs.org/), one might summarize them by saying that Katana brings many of the benefits of [Node.js](http://nodejs.org/) (and frameworks like it) without forcing the developer to throw out everything she knows about developing ASP.NET Web applications.</span></span> <span data-ttu-id="00b9c-208">此陳述式來保存，則為 true，開始使用 Katana 專案應該同樣簡單性質，為了[Node.js](http://nodejs.org/)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-208">For this statement to hold true, getting started with the Katana project should be equally simple in nature to [Node.js](http://nodejs.org/).</span></span>

## <a name="creating-hello-world"></a><span data-ttu-id="00b9c-209">建立"Hello World ！"</span><span class="sxs-lookup"><span data-stu-id="00b9c-209">Creating "Hello World!"</span></span>

<span data-ttu-id="00b9c-210">JavaScript 和.NET 開發之間的明顯差異是編譯器的目前狀態 （或不存在）。</span><span class="sxs-lookup"><span data-stu-id="00b9c-210">One notable difference between JavaScript and .NET development is the presence (or absence) of a compiler.</span></span> <span data-ttu-id="00b9c-211">因此，簡單 Katana 伺服器的起始點是 Visual Studio 專案。</span><span class="sxs-lookup"><span data-stu-id="00b9c-211">As such, the starting point for a simple Katana server is a Visual Studio project.</span></span> <span data-ttu-id="00b9c-212">不過，我們可以開始使用最小的專案類型： 空的 ASP.NET Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-212">However, we can start with the most minimal of project types: the Empty ASP.NET Web Application.</span></span>

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

<span data-ttu-id="00b9c-213">接下來，我們將會安裝[Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)專案將 NuGet 封裝。</span><span class="sxs-lookup"><span data-stu-id="00b9c-213">Next, we will install the [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet package into the project.</span></span> <span data-ttu-id="00b9c-214">此封裝提供在 ASP.NET 要求管線中執行的 OWIN 伺服器。</span><span class="sxs-lookup"><span data-stu-id="00b9c-214">This package provides an OWIN server that runs in the ASP.NET request pipeline.</span></span> <span data-ttu-id="00b9c-215">您可以找到上[NuGet gallery](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) ，可以使用 Visual Studio 封裝管理員 對話方塊或 [封裝管理員] 主控台使用下列命令安裝：</span><span class="sxs-lookup"><span data-stu-id="00b9c-215">It can be found on the [NuGet gallery](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) and can be installed using either the Visual Studio package manager dialog or the package manager console with the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

<span data-ttu-id="00b9c-216">安裝`Microsoft.Owin.Host.SystemWeb`封裝將會安裝為相依性的幾個額外的封裝。</span><span class="sxs-lookup"><span data-stu-id="00b9c-216">Installing the `Microsoft.Owin.Host.SystemWeb` package will install a few additional packages as dependencies.</span></span> <span data-ttu-id="00b9c-217">這些相依性的其中一個是`Microsoft.Owin`，程式庫，並且提供數個協助程式類型和方法來開發 OWIN 應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-217">One of those dependencies is `Microsoft.Owin`, a library which provides several helper types and methods for developing OWIN applications.</span></span> <span data-ttu-id="00b9c-218">若要快速地撰寫下列"hello world"伺服器，我們可以使用這些型別。</span><span class="sxs-lookup"><span data-stu-id="00b9c-218">We can use those types to quickly write the following "hello world" server.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

<span data-ttu-id="00b9c-219">這個非常簡單的 Web 伺服器現在可以執行使用 Visual Studio **F5**命令，並包含偵錯的完整支援。</span><span class="sxs-lookup"><span data-stu-id="00b9c-219">This very simple Web server can now be run using Visual Studio's **F5** command and includes full support for debugging.</span></span>

## <a name="switching-hosts"></a><span data-ttu-id="00b9c-220">切換主機</span><span class="sxs-lookup"><span data-stu-id="00b9c-220">Switching hosts</span></span>

<span data-ttu-id="00b9c-221">根據預設，上述的"hello world"範例執行 IIS 的內容中使用 System.Web ASP.NET 要求管線中。</span><span class="sxs-lookup"><span data-stu-id="00b9c-221">By default, the previous "hello world" example runs in the ASP.NET request pipeline, which uses System.Web in the context of IIS.</span></span> <span data-ttu-id="00b9c-222">這可以單獨使用時新增極大的值因為它可讓我們受益於彈性與撰寫性 OWIN 管線的管理功能和整體成熟度的 IIS。</span><span class="sxs-lookup"><span data-stu-id="00b9c-222">This can by itself add tremendous value as it enables us to benefit from the flexibility and composability of an OWIN pipeline with the management capabilities and overall maturity of IIS.</span></span> <span data-ttu-id="00b9c-223">不過，可能不需要 IIS 的好處，而且想要為較小、 更精簡的主機。</span><span class="sxs-lookup"><span data-stu-id="00b9c-223">However, there may be cases where the benefits provided by IIS are not required and the desire is for a smaller, more lightweight host.</span></span> <span data-ttu-id="00b9c-224">所需，然後執行 IIS 和 System.Web 之外，我們簡單的 Web 伺服器？</span><span class="sxs-lookup"><span data-stu-id="00b9c-224">What is needed, then, to run our simple Web server outside of IIS and System.Web?</span></span>

<span data-ttu-id="00b9c-225">為了說明的可攜性的目標，從命令列的主應用程式的 Web 伺服器主機移動需要直接將新的伺服器和主機相依性加入至專案的輸出資料夾，然後啟動主機。</span><span class="sxs-lookup"><span data-stu-id="00b9c-225">To illustrate the portability goal, moving from a Web-server host to a command line host requires simply adding the new server and host dependencies to project's output folder and then starting the host.</span></span> <span data-ttu-id="00b9c-226">在此範例中，我們將會裝載我們稱為 Katana 主應用程式中的 Web 伺服器`OwinHost.exe`且將會使用 Katana HttpListener 架構的伺服器。</span><span class="sxs-lookup"><span data-stu-id="00b9c-226">In this example, we'll host our Web server in a Katana host called `OwinHost.exe` and will use the Katana HttpListener-based server.</span></span> <span data-ttu-id="00b9c-227">同樣地其他 Katana 元件，這些都能取得從 NuGet 使用下列命令：</span><span class="sxs-lookup"><span data-stu-id="00b9c-227">Similarly to the other Katana components, these will be acquired from NuGet using the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

<span data-ttu-id="00b9c-228">我們可以從命令列，然後瀏覽至專案根資料夾，並只需執行`OwinHost.exe`（其已安裝在其個別的 NuGet 套件的 [工具] 資料夾）。</span><span class="sxs-lookup"><span data-stu-id="00b9c-228">From the command line, we can then navigate to the project root folder and simply run the `OwinHost.exe` (which was installed in the tools folder of its respective NuGet package).</span></span> <span data-ttu-id="00b9c-229">根據預設，`OwinHost.exe`設定要尋找的 HttpListener 伺服器，因此不需要任何額外的設定。</span><span class="sxs-lookup"><span data-stu-id="00b9c-229">By default, `OwinHost.exe` is configured to look for the HttpListener-based server and so no additional configuration is needed.</span></span> <span data-ttu-id="00b9c-230">在網頁瀏覽器中瀏覽`http://localhost:5000/`顯示現在透過主控台執行的應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-230">Navigating in a Web browser to `http://localhost:5000/` shows the application now running through the console.</span></span>

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a><span data-ttu-id="00b9c-231">Katana 架構</span><span class="sxs-lookup"><span data-stu-id="00b9c-231">Katana Architecture</span></span>

 <span data-ttu-id="00b9c-232">Katana 元件架構將分割成四個邏輯層，應用程式，如底下所述：*主機、 伺服器、 中介軟體，* 和*應用程式*。</span><span class="sxs-lookup"><span data-stu-id="00b9c-232">The Katana component architecture divides an application into four logical layers, as depicted below: *host, server, middleware,* and *application*.</span></span> <span data-ttu-id="00b9c-233">元件架構被考量的方式，這些層級實作可以輕鬆地取代，在許多情況下，而不需要重新編譯的應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-233">The component architecture is factored in such a way that implementations of these layers can be easily substituted, in many cases, without requiring recompilation of the application.</span></span>   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a><span data-ttu-id="00b9c-234">主機</span><span class="sxs-lookup"><span data-stu-id="00b9c-234">Host</span></span>

 <span data-ttu-id="00b9c-235">主機負責：</span><span class="sxs-lookup"><span data-stu-id="00b9c-235">The host is responsible for:</span></span>

- <span data-ttu-id="00b9c-236">管理基礎程序。</span><span class="sxs-lookup"><span data-stu-id="00b9c-236">Managing the underlying process.</span></span>
- <span data-ttu-id="00b9c-237">會處理選取的伺服器，以及哪些要求透過 OWIN 管線建構會導致工作流程整合，以完成。</span><span class="sxs-lookup"><span data-stu-id="00b9c-237">Orchestrating the workflow that results in the selection of a server and the construction of an OWIN pipeline through which requests will be handled.</span></span>

  <span data-ttu-id="00b9c-238">目前，有 3 Katana 基礎的應用程式的主要裝載選項：</span><span class="sxs-lookup"><span data-stu-id="00b9c-238">At present, there are 3 primary hosting options for Katana-based applications:</span></span>  
  
<span data-ttu-id="00b9c-239">**ASP.NET**： 使用標準的 HttpModule 和 HttpHandler 型別，OWIN 管線可以在 IIS 上執行的 ASP.NET 要求流程的一部分。</span><span class="sxs-lookup"><span data-stu-id="00b9c-239">**IIS/ASP.NET**: Using the standard HttpModule and HttpHandler types, OWIN pipelines can run on IIS as a part of an ASP.NET request flow.</span></span> <span data-ttu-id="00b9c-240">Microsoft.AspNet.Host.SystemWeb NuGet 封裝安裝到 Web 應用程式專案時，會啟用 ASP.NET 裝載支援。</span><span class="sxs-lookup"><span data-stu-id="00b9c-240">ASP.NET hosting support is enabled by installing the Microsoft.AspNet.Host.SystemWeb NuGet package into a Web application project.</span></span> <span data-ttu-id="00b9c-241">此外，因為 IIS 做為主機和伺服器，OWIN 伺服器/主控件區別 」 混為一談是在此 NuGet 封裝中，這表示如果使用的 SystemWeb 主機，開發人員無法替換替代伺服器實作。</span><span class="sxs-lookup"><span data-stu-id="00b9c-241">Additionally, because IIS acts as both a host and a server, the OWIN server/host distinction is conflated in this NuGet package, meaning that if using the SystemWeb host, a developer cannot substitute an alternate server implementation.</span></span>  
  
<span data-ttu-id="00b9c-242">**自訂主機**: Katana 元件套件可讓開發人員主應用程式在自己的自訂程序，不論是主控台應用程式、 Windows 服務和其他內容。這項功能提供 Web API 的自我裝載功能類似。</span><span class="sxs-lookup"><span data-stu-id="00b9c-242">**Custom Host**: The Katana component suite gives a developer the ability to host applications in her own custom process, whether that is a console application, Windows service, etc. This capability looks similar to the self-host capability provided by Web API.</span></span> <span data-ttu-id="00b9c-243">下列範例會示範自訂主機的 Web API 的程式碼：</span><span class="sxs-lookup"><span data-stu-id="00b9c-243">The following example shows a custom host of Web API code:</span></span>  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

<span data-ttu-id="00b9c-244">自我裝載 Katana 應用程式安裝程式會類似：</span><span class="sxs-lookup"><span data-stu-id="00b9c-244">The self-host setup for a Katana application is similar:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

<span data-ttu-id="00b9c-245">之間的 Web API 和 Katana 自我裝載範例有一個值得注意的差異是缺少 Katana 自我裝載範例的 Web API 組態程式碼。</span><span class="sxs-lookup"><span data-stu-id="00b9c-245">One notable difference between the Web API and Katana self-host examples is that the Web API configuration code is missing from the Katana self-host example.</span></span> <span data-ttu-id="00b9c-246">若要啟用可攜性和撰寫，Katana 分隔啟動伺服器設定要求處理管線的程式碼的程式碼。</span><span class="sxs-lookup"><span data-stu-id="00b9c-246">In order to enable both portability and composability, Katana separates the code that starts the server from the code that configures the request processing pipeline.</span></span> <span data-ttu-id="00b9c-247">設定 Web API 的程式碼然後包含在啟動時，此外 WebApplication.Start 中的類型參數指定的類別。</span><span class="sxs-lookup"><span data-stu-id="00b9c-247">The code that configures Web API, then is contained in the class Startup, which is additionally specified as the type parameter in WebApplication.Start.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

<span data-ttu-id="00b9c-248">啟動類別將在本文稍後的更詳細地討論。</span><span class="sxs-lookup"><span data-stu-id="00b9c-248">The startup class will be discussed in greater detail later in the article.</span></span> <span data-ttu-id="00b9c-249">不過，需要啟動 Katana 自我裝載的處理程序看起來極為類似您在 ASP.NET Web API 的自我裝載應用程式可能現今使用的程式碼的程式碼。</span><span class="sxs-lookup"><span data-stu-id="00b9c-249">However, the code required to start a Katana self-host process looks strikingly similar to the code that you may be using today in ASP.NET Web API self-host applications.</span></span>

<span data-ttu-id="00b9c-250">**OwinHost.exe**： 許多部分會想要撰寫自訂的程序，來執行 Katana Web 應用程式，而希望只要啟動預先建置的可執行檔可以啟動伺服器，並執行其應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-250">**OwinHost.exe**: While some will want to write a custom process to run Katana Web applications, many would prefer to simply launch a pre-built executable that can start a server and run their application.</span></span> <span data-ttu-id="00b9c-251">針對此案例，包括 Katana 元件套件`OwinHost.exe`。</span><span class="sxs-lookup"><span data-stu-id="00b9c-251">For this scenario, the Katana component suite includes `OwinHost.exe`.</span></span> <span data-ttu-id="00b9c-252">當從專案的根目錄內執行，此可執行檔將會啟動 （它預設會使用 HttpListener 伺服器） 的伺服器，並使用慣例來尋找並執行使用者啟動的類別。</span><span class="sxs-lookup"><span data-stu-id="00b9c-252">When run from within a project's root directory, this executable will start a server (it uses the HttpListener server by default) and use conventions to find and run the user's startup class.</span></span> <span data-ttu-id="00b9c-253">對於更細微的控制，可執行檔會提供幾個其他命令列參數。</span><span class="sxs-lookup"><span data-stu-id="00b9c-253">For more granular control, the executable provides a number of additional command line parameters.</span></span>

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a><span data-ttu-id="00b9c-254">伺服器</span><span class="sxs-lookup"><span data-stu-id="00b9c-254">Server</span></span>

 <span data-ttu-id="00b9c-255">主機負責啟動和維護應用程式執行所在，伺服器的責任的程序時若要開啟網路通訊端，接聽要求，透過 OWIN 元件的管線傳送它們所指定 （做為您的使用者嗎可能已注意到，此管線在應用程式開發人員的啟動類別中指定）。</span><span class="sxs-lookup"><span data-stu-id="00b9c-255">While the host is responsible for starting and maintaining process within which the application runs, the responsibility of the server is to open a network socket, listen for requests, and send them through the pipeline of OWIN components specified by the user (as you may have already noticed, this pipeline is specified in the application developer's Startup class).</span></span> <span data-ttu-id="00b9c-256">目前，Katana 專案包含兩個伺服器實作：</span><span class="sxs-lookup"><span data-stu-id="00b9c-256">Currently, the Katana project includes two server implementations:</span></span> 

- <span data-ttu-id="00b9c-257">**Microsoft.Owin.Host.SystemWeb**： 如先前所述，IIS 與 ASP.NET 管線搭配做為主機和伺服器。</span><span class="sxs-lookup"><span data-stu-id="00b9c-257">**Microsoft.Owin.Host.SystemWeb**: As previously mentioned, IIS in concert with the ASP.NET pipeline acts as both a host and a server.</span></span> <span data-ttu-id="00b9c-258">因此，當選擇這個裝載選項，IIS 管理主機層級的考量，如處理序啟用和接聽 HTTP 要求。</span><span class="sxs-lookup"><span data-stu-id="00b9c-258">Therefore, when choosing this hosting option, IIS both manages host-level concerns such as process activation and listens for HTTP requests.</span></span> <span data-ttu-id="00b9c-259">ASP.NET Web 應用程式，並再將要求傳送至 ASP.NET 管線。</span><span class="sxs-lookup"><span data-stu-id="00b9c-259">For ASP.NET Web applications, it then sends the requests into the ASP.NET pipeline.</span></span> <span data-ttu-id="00b9c-260">Katana SystemWeb 主機登錄 ASP.NET HttpModule HttpHandler 攔截要求，因為它們透過 HTTP 管線流動，並將它們傳送到指定使用者的 OWIN 管線。</span><span class="sxs-lookup"><span data-stu-id="00b9c-260">The Katana SystemWeb host registers an ASP.NET HttpModule and HttpHandler to intercept requests as they flow through the HTTP pipeline and send them through the user-specified OWIN pipeline.</span></span>
- <span data-ttu-id="00b9c-261">**Microsoft.Owin.Host.HttpListener**： 如其名稱所指示，此 Katana 伺服器會使用.NET Framework 的 HttpListener 類別若要開啟通訊端，並將要求傳送至開發人員指定的 OWIN 管線。</span><span class="sxs-lookup"><span data-stu-id="00b9c-261">**Microsoft.Owin.Host.HttpListener**: As its name indicates, this Katana server uses the .NET Framework's HttpListener class to open a socket and send requests into a developer-specified OWIN pipeline.</span></span> <span data-ttu-id="00b9c-262">這是目前 Katana 自我裝載的 API 和 OwinHost.exe 預設伺服器選取項目。</span><span class="sxs-lookup"><span data-stu-id="00b9c-262">This is currently the default server selection for both the Katana self-host API and OwinHost.exe.</span></span>

## <a name="middlewareframework"></a><span data-ttu-id="00b9c-263">中介軟體/架構</span><span class="sxs-lookup"><span data-stu-id="00b9c-263">Middleware/framework</span></span>

 <span data-ttu-id="00b9c-264">如先前所述，當伺服器接受的要求從用戶端，它會負責通過管線，開發人員的啟始程式碼所指定的 OWIN 元件。</span><span class="sxs-lookup"><span data-stu-id="00b9c-264">As previously mentioned, when the server accepts a request from a client, it is responsible for passing it through a pipeline of OWIN components, which are specified by the developer's startup code.</span></span> <span data-ttu-id="00b9c-265">這些管線元件稱為中介軟體。</span><span class="sxs-lookup"><span data-stu-id="00b9c-265">These pipeline components are known as middleware.</span></span>  
 <span data-ttu-id="00b9c-266">在非常基本的層級的 OWIN 中介軟體元件只需要使其可呼叫實作 OWIN 應用程式委派。</span><span class="sxs-lookup"><span data-stu-id="00b9c-266">At a very basic level, an OWIN middleware component simply needs to implement the OWIN application delegate so that it is callable.</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

<span data-ttu-id="00b9c-267">不過，為了簡化開發和中介軟體元件的組合，Katana 會支援中介軟體元件的少數幾個慣例和協助程式類型。</span><span class="sxs-lookup"><span data-stu-id="00b9c-267">However, in order to simplify the development and composition of middleware components, Katana supports a handful of conventions and helper types for middleware components.</span></span> <span data-ttu-id="00b9c-268">最常見的這些是`OwinMiddleware`類別。</span><span class="sxs-lookup"><span data-stu-id="00b9c-268">The most common of these is the `OwinMiddleware` class.</span></span> <span data-ttu-id="00b9c-269">使用這個類別來建置自訂的中介軟體元件看起來會如下所示：</span><span class="sxs-lookup"><span data-stu-id="00b9c-269">A custom middleware component built using this class would look similar to the following:</span></span> 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 <span data-ttu-id="00b9c-270">此類別衍生自`OwinMiddleware`，實作做為其引數，其中接受管線中的下一個中介軟體的執行個體，然後將它傳遞給基底建構函式的建構函式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-270">This class derives from `OwinMiddleware`, implements a constructor that accepts an instance of the next middleware in the pipeline as one of its arguments, and then passes it to the base constructor.</span></span> <span data-ttu-id="00b9c-271">之後的下一個中介軟體參數，用來設定中介軟體的其他引數也會宣告為建構函式參數。</span><span class="sxs-lookup"><span data-stu-id="00b9c-271">Additional arguments used to configure the middleware are also declared as constructor parameters after the next middleware parameter.</span></span>   
  
<span data-ttu-id="00b9c-272">中介軟體會執行在執行階段，透過覆寫`Invoke`方法。</span><span class="sxs-lookup"><span data-stu-id="00b9c-272">At runtime, the middleware is executed via the overridden `Invoke` method.</span></span> <span data-ttu-id="00b9c-273">這個方法會採用單一引數的型別`OwinContext`。</span><span class="sxs-lookup"><span data-stu-id="00b9c-273">This method takes a single argument of type `OwinContext`.</span></span> <span data-ttu-id="00b9c-274">這個內容物件由`Microsoft.Owin`NuGet 封裝稍早所述，並提供要求、 回應和環境的字典，以及一些額外的 helper 類型的強型別存取。</span><span class="sxs-lookup"><span data-stu-id="00b9c-274">This context object is provided by the `Microsoft.Owin` NuGet package described earlier and provides strongly-typed access to the request, response and environment dictionary, along with a few additional helper types.</span></span>   
  
<span data-ttu-id="00b9c-275">中介軟體類別可以輕鬆地加入至 OWIN 管線中的應用程式啟動程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="00b9c-275">The middleware class can be easily added to the OWIN pipeline in the application startup code as follows:</span></span>   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

<span data-ttu-id="00b9c-276">由於 Katana 基礎結構只建立管線的 OWIN 中介軟體元件，而且元件只需要以支援參與管線的應用程式委派中, 介軟體元件的範圍可以從簡單的複雜性記錄器將整個架構，像 ASP.NET，Web API 或[SignalR](../../../signalr/index.md)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-276">Because the Katana infrastructure simply builds up a pipeline of OWIN middleware components, and because the components simply need to support the application delegate to participate in the pipeline, middleware components can range in complexity from simple loggers to entire frameworks like ASP.NET, Web API, or [SignalR](../../../signalr/index.md).</span></span> <span data-ttu-id="00b9c-277">例如，將 ASP.NET Web API 新增至先前的 OWIN 管線需要加入下列啟動程式碼：</span><span class="sxs-lookup"><span data-stu-id="00b9c-277">For example, adding ASP.NET Web API to the previous OWIN pipeline requires adding the following startup code:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

<span data-ttu-id="00b9c-278">Katana 基礎結構會建置到設定方法的 IAppBuilder 物件已加入的順序為基礎的中介軟體元件的管線。</span><span class="sxs-lookup"><span data-stu-id="00b9c-278">The Katana infrastructure will build the pipeline of middleware components based on the order in which they were added to the IAppBuilder object in the Configuration method.</span></span> <span data-ttu-id="00b9c-279">然後，在本例中，LoggerMiddleware 可以處理流程會通過管線，無論最終如何處理這些要求的所有要求。</span><span class="sxs-lookup"><span data-stu-id="00b9c-279">In our example, then, LoggerMiddleware can handle all requests that flow through the pipeline, regardless of how those requests are ultimately handled.</span></span> <span data-ttu-id="00b9c-280">這可讓在的中介軟體元件 （例如驗證元件） 可以處理包含多個元件和架構 （例如 ASP.NET Web API、 SignalR 和靜態檔案伺服器） 的管線要求的強大案例。</span><span class="sxs-lookup"><span data-stu-id="00b9c-280">This enables powerful scenarios where a middleware component (e.g. an authentication component) can process requests for a pipeline that includes multiple components and frameworks (e.g. ASP.NET Web API, SignalR, and a static file server).</span></span>
 
## <a name="applications"></a><span data-ttu-id="00b9c-281">應用程式</span><span class="sxs-lookup"><span data-stu-id="00b9c-281">Applications</span></span>

<span data-ttu-id="00b9c-282">如先前範例所示，OWIN 和 Katana 專案應該不被視為新應用程式的程式設計模型，但而不是以分離應用程式撰寫模型和伺服器與裝載基礎結構架構的抽象概念。</span><span class="sxs-lookup"><span data-stu-id="00b9c-282">As illustrated by the previous examples, OWIN and the Katana project should not be thought of as a new application programming model, but rather as an abstraction to decouple application programming models and frameworks from server and hosting infrastructure.</span></span> <span data-ttu-id="00b9c-283">比方說，當建置 Web API 應用程式，開發人員架構會繼續使用 ASP.NET Web API framework，無論使用元件從 Katana 專案 OWIN 管線中執行應用程式中。</span><span class="sxs-lookup"><span data-stu-id="00b9c-283">For example, when building Web API applications, the developer framework will continue to use the ASP.NET Web API framework, irrespective of whether or not the application runs in an OWIN pipeline using components from the Katana project.</span></span> <span data-ttu-id="00b9c-284">會看到應用程式開發人員 OWIN 相關的程式碼的位置將應用程式啟動程式碼中，開發人員撰寫 OWIN 管線的位置。</span><span class="sxs-lookup"><span data-stu-id="00b9c-284">The one place where OWIN-related code will be visible to the application developer will be the application startup code, where the developer composes the OWIN pipeline.</span></span> <span data-ttu-id="00b9c-285">在啟動程式碼中，開發人員會登錄一系列的 UseXx 陳述式，通常是一個針對每個中介軟體元件會處理傳入的要求。</span><span class="sxs-lookup"><span data-stu-id="00b9c-285">In the startup code, the developer will register a series of UseXx statements, generally one for each middleware component that will process incoming requests.</span></span> <span data-ttu-id="00b9c-286">這項體驗將會有註冊目前 System.Web 世界中的 HTTP 模組相同的效果。</span><span class="sxs-lookup"><span data-stu-id="00b9c-286">This experience will have the same effect as registering HTTP modules in the current System.Web world.</span></span> <span data-ttu-id="00b9c-287">一般而言，較大架構中的介軟體，例如 ASP.NET Web API 或[SignalR](../../../signalr/index.md)會註冊在管線結尾處。</span><span class="sxs-lookup"><span data-stu-id="00b9c-287">Typically, a larger framework middleware, such as ASP.NET Web API or [SignalR](../../../signalr/index.md) will be registered at the end of the pipeline.</span></span> <span data-ttu-id="00b9c-288">跨領域中介軟體元件，例如驗證或快取中，通常註冊朝向管線的開頭，使它們將會處理所有架構及稍後在管線中的已註冊元件的要求。</span><span class="sxs-lookup"><span data-stu-id="00b9c-288">Cross-cutting middleware components, such as those for authentication or caching, are generally registered towards the beginning of the pipeline so that they will process requests for all of the frameworks and components registered later in the pipeline.</span></span> <span data-ttu-id="00b9c-289">這項分隔的中介軟體元件彼此，並從基本的基礎結構元件可讓在不同時發展，同時確保整體系統會保持穩定的元件。</span><span class="sxs-lookup"><span data-stu-id="00b9c-289">This separation of the middleware components from each other and from the underlying infrastructure components enables the components to evolve at different velocities while ensuring that the overall system remains stable.</span></span>

## <a name="components--nuget-packages"></a><span data-ttu-id="00b9c-290">元件 – NuGet 封裝</span><span class="sxs-lookup"><span data-stu-id="00b9c-290">Components – NuGet Packages</span></span>

<span data-ttu-id="00b9c-291">如同許多的目前媒體櫃和架構，Katana 專案元件都會以一組 NuGet 封裝來提供。</span><span class="sxs-lookup"><span data-stu-id="00b9c-291">Like many current libraries and frameworks, the Katana project components are delivered as a set of NuGet packages.</span></span> <span data-ttu-id="00b9c-292">如需近期版本 2.0，Katana 封裝相依性圖形看起來如下。</span><span class="sxs-lookup"><span data-stu-id="00b9c-292">For the upcoming version 2.0, the Katana package dependency graph looks as follows.</span></span> <span data-ttu-id="00b9c-293">（按一下放大的影像）。</span><span class="sxs-lookup"><span data-stu-id="00b9c-293">(Click on image for larger view.)</span></span>

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

<span data-ttu-id="00b9c-294">Katana 專案中的幾乎每個封裝而定，直接或間接地 Owin 封裝。</span><span class="sxs-lookup"><span data-stu-id="00b9c-294">Nearly every package in the Katana project depends, directly or indirectly, on the Owin package.</span></span> <span data-ttu-id="00b9c-295">您可能記得這是包含提供 OWIN 規格的第 4 節中所述的應用程式啟動順序的具象實作的 IAppBuilder 介面的套件。</span><span class="sxs-lookup"><span data-stu-id="00b9c-295">You may remember that this is the package that contains the IAppBuilder interface, which provides a concrete implementation of the application startup sequence described in section 4 of the OWIN specification.</span></span> <span data-ttu-id="00b9c-296">此外，許多封裝相依 Microsoft.Owin，提供一組協助程式類型使用的 HTTP 要求和回應。</span><span class="sxs-lookup"><span data-stu-id="00b9c-296">Additionally, many of the packages depend on Microsoft.Owin, which provides a set of helper types for working with HTTP requests and responses.</span></span> <span data-ttu-id="00b9c-297">封裝的其餘部分可以歸類為裝載基礎結構的封裝 （伺服器或主機） 或中介軟體。</span><span class="sxs-lookup"><span data-stu-id="00b9c-297">The remainder of the package can be classified as either hosting infrastructure packages (servers or hosts) or middleware.</span></span> <span data-ttu-id="00b9c-298">封裝和 Katana 專案外部的相依性會顯示為橙色。</span><span class="sxs-lookup"><span data-stu-id="00b9c-298">Packages and dependencies that are external to the Katana project are displayed in orange.</span></span>

<span data-ttu-id="00b9c-299">Katana 2.0 裝載基礎結構包括 SystemWeb 與 HttpListener 為基礎的伺服器、 執行 OWIN 應用程式使用 OwinHost.exe，OwinHost 封裝及 Microsoft.Owin.Hosting 套件的是自我裝載中的 OWIN 應用程式自訂主應用程式 （例如主控台應用程式、 Windows 服務等）</span><span class="sxs-lookup"><span data-stu-id="00b9c-299">The hosting infrastructure for Katana 2.0 includes both the SystemWeb and HttpListener-based servers, the OwinHost package for running OWIN applications using OwinHost.exe, and the Microsoft.Owin.Hosting package for self-hosting OWIN applications in a custom host (e.g. console application, Windows service, etc.)</span></span>

<span data-ttu-id="00b9c-300">Katana 2.0 中介軟體元件主要焦點放在提供不同的驗證方式。</span><span class="sxs-lookup"><span data-stu-id="00b9c-300">For Katana 2.0, the middleware components are primarily focused on providing different means of authentication.</span></span> <span data-ttu-id="00b9c-301">提供一個診斷的其他中介軟體元件，可讓開始與錯誤頁面的支援。</span><span class="sxs-lookup"><span data-stu-id="00b9c-301">One additional middleware component for diagnostics is provided, which enables support for a start and error page.</span></span> <span data-ttu-id="00b9c-302">OWIN 隨著成既定的裝載抽象概念中, 介軟體元件，這兩個那些由 Microsoft 和協力廠商所開發的生態系統也會成長數字。</span><span class="sxs-lookup"><span data-stu-id="00b9c-302">As OWIN grows into the de facto hosting abstraction, the ecosystem of middleware components, both those developed by Microsoft and third parties, will also grow in number.</span></span>

## <a name="conclusion"></a><span data-ttu-id="00b9c-303">結論</span><span class="sxs-lookup"><span data-stu-id="00b9c-303">Conclusion</span></span>

 <span data-ttu-id="00b9c-304">從開始，Katana 專案的目標尚未建立，並藉此強制開發人員若要了解另一個 Web 架構。</span><span class="sxs-lookup"><span data-stu-id="00b9c-304">From its beginning, the Katana project's goal has not been to create and thereby force developers to learn yet another Web framework.</span></span> <span data-ttu-id="00b9c-305">相反地，其目標是要建立的抽象概念，讓.NET Web 應用程式開發人員選項比先前一直。</span><span class="sxs-lookup"><span data-stu-id="00b9c-305">Rather, the goal has been to create an abstraction to give .NET Web application developers more choice than has previously been possible.</span></span> <span data-ttu-id="00b9c-306">透過邏輯層級中的典型的 Web 應用程式堆疊成一組可取代的元件，Katana 專案可讓元件在整個堆疊在任何速率最適合這些元件改善。</span><span class="sxs-lookup"><span data-stu-id="00b9c-306">By breaking up the logical layers of a typical Web application stack into a set of replaceable components, the Katana project enables components throughout the stack to improve at whatever rate makes sense for those components.</span></span> <span data-ttu-id="00b9c-307">藉由建置簡單的 OWIN 抽象周圍的所有元件，Katana 可讓架構建置的應用程式在其上能夠移植到各種不同的伺服器與主機不同。</span><span class="sxs-lookup"><span data-stu-id="00b9c-307">By building all components around the simple OWIN abstraction, Katana enables frameworks and the applications built on top of them to be portable across a variety of different servers and hosts.</span></span> <span data-ttu-id="00b9c-308">藉由將開發人員放入堆疊的控制項，Katana 可確保，開發人員會使最終選擇如何輕量型或她 Web 堆疊應該是如何豐富的功能。</span><span class="sxs-lookup"><span data-stu-id="00b9c-308">By putting the developer in control of the stack, Katana ensures that the developer makes the ultimate choice about how lightweight or how feature-rich her Web stack should be.</span></span>  
  

## <a name="for-more-information-about-katana"></a><span data-ttu-id="00b9c-309">如需有關 Katana</span><span class="sxs-lookup"><span data-stu-id="00b9c-309">For more information about Katana</span></span>

- <span data-ttu-id="00b9c-310">GitHub 上的 Katana 專案： [ https://github.com/aspnet/AspNetKatana/ ](https://github.com/aspnet/AspNetKatana/)。</span><span class="sxs-lookup"><span data-stu-id="00b9c-310">The Katana project on GitHub: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/).</span></span>
- <span data-ttu-id="00b9c-311">影片： [Katana 專案-適用於 ASP.NET 的 OWIN](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)，由 Howard Dierking。</span><span class="sxs-lookup"><span data-stu-id="00b9c-311">Video: [The Katana Project - OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), by Howard Dierking.</span></span>

## <a name="acknowledgements"></a><span data-ttu-id="00b9c-312">謝誌</span><span class="sxs-lookup"><span data-stu-id="00b9c-312">Acknowledgements</span></span>

- <span data-ttu-id="00b9c-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT) ) Rick 是將焦點放在 Azure 和 MVC microsoft 資深程式寫入器。</span><span class="sxs-lookup"><span data-stu-id="00b9c-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Rick is a senior programming writer for Microsoft focusing on Azure and MVC.</span></span>
- <span data-ttu-id="00b9c-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [ @shanselman ](https://twitter.com/shanselman) )</span><span class="sxs-lookup"><span data-stu-id="00b9c-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [@shanselman](https://twitter.com/shanselman) )</span></span>
- <span data-ttu-id="00b9c-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [ @jongalloway ](https://twitter.com/jongalloway) )</span><span class="sxs-lookup"><span data-stu-id="00b9c-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [@jongalloway](https://twitter.com/jongalloway) )</span></span>
