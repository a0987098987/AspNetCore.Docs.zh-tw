---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
title: 以佇列為主的工作模式 （使用 Azure 建置真實世界的雲端應用程式） |Microsoft Docs
author: MikeWasson
description: 建置真實世界雲端應用程式與 Azure 的電子書是以 Scott Guthrie 所開發的簡報為依據。 它說明 13 模式與做法，他可以...
ms.author: riande
ms.date: 06/12/2014
ms.assetid: cc1ad51b-40c3-4c68-8620-9aaa0fd1f6cf
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
msc.type: authoredcontent
ms.openlocfilehash: 03b6950104b6f293271d9f9a0feed4071e9b1174
ms.sourcegitcommit: 7b4e3936feacb1a8fcea7802aab3e2ea9c8af5b4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/04/2018
ms.locfileid: "48577908"
---
<a name="queue-centric-work-pattern-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="03904-104">以佇列為主的工作模式 （使用 Azure 建置真實世界的雲端應用程式）</span><span class="sxs-lookup"><span data-stu-id="03904-104">Queue-Centric Work Pattern (Building Real-World Cloud Apps with Azure)</span></span>
====================
<span data-ttu-id="03904-105">藉由[Mike Wasson](https://github.com/MikeWasson)， [Rick Anderson]((https://twitter.com/RickAndMSFT))， [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="03904-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson]((https://twitter.com/RickAndMSFT)), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="03904-106">[下載修正此問題的專案](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下載電子書](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="03904-106">[Download Fix It Project](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="03904-107">**建置真實世界雲端應用程式與 Azure**電子書以 Scott Guthrie 所開發的簡報為依據。</span><span class="sxs-lookup"><span data-stu-id="03904-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="03904-108">它說明 13 的模式，並可協助您的作法是成功開發適用於雲端的 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="03904-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="03904-109">電子書的相關資訊，請參閱[第 1 章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="03904-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>


<span data-ttu-id="03904-110">稍早，我們所見，使用多個服務可能會導致 「 複合 」 的 SLA，應用程式的有效 SLA 所在*產品*的個別的 Sla。</span><span class="sxs-lookup"><span data-stu-id="03904-110">Earlier, we saw that using multiple services can result in a "composite" SLA, where the app's effective SLA is the *product* of the individual SLAs.</span></span> <span data-ttu-id="03904-111">比方說，它修正應用程式所使用的網站、 儲存體和 SQL Database。</span><span class="sxs-lookup"><span data-stu-id="03904-111">For example, the Fix It app uses Web Sites, Storage, and SQL Database.</span></span> <span data-ttu-id="03904-112">如果這些服務的任何一個失敗，應用程式會傳回錯誤給使用者。</span><span class="sxs-lookup"><span data-stu-id="03904-112">If any one of these services fails, the app will return an error to the user.</span></span>

<span data-ttu-id="03904-113">快取是以處理暫時性失敗的唯讀內容的好方法。</span><span class="sxs-lookup"><span data-stu-id="03904-113">Caching is a good way to handle transient failures for read-only content.</span></span> <span data-ttu-id="03904-114">但是，如果您的應用程式需要執行工作？</span><span class="sxs-lookup"><span data-stu-id="03904-114">But what if your application needs to do work?</span></span> <span data-ttu-id="03904-115">比方說，當使用者提交新修正它的工作，應用程式不能只將工作放入快取。</span><span class="sxs-lookup"><span data-stu-id="03904-115">For example, when the user submits a new Fix It task, the app can't just put the task into the cache.</span></span> <span data-ttu-id="03904-116">必須為持續性資料存放區中，修正它工作寫入，因此它可以處理應用程式。</span><span class="sxs-lookup"><span data-stu-id="03904-116">The app needs to write the Fix It task into a persistent data store, so it can be processed.</span></span>

<span data-ttu-id="03904-117">這是以佇列為主的工作模式之處。</span><span class="sxs-lookup"><span data-stu-id="03904-117">That's where the queue-centric work pattern comes in.</span></span> <span data-ttu-id="03904-118">此模式可讓 web 層和後端服務之間的鬆散結合。</span><span class="sxs-lookup"><span data-stu-id="03904-118">This pattern enables loose coupling between a web tier and a backend service.</span></span>

<span data-ttu-id="03904-119">以下是模式的運作方式。</span><span class="sxs-lookup"><span data-stu-id="03904-119">Here's how the pattern works.</span></span> <span data-ttu-id="03904-120">當應用程式取得要求時，它會將工作項目放入佇列，並立即傳回回應。</span><span class="sxs-lookup"><span data-stu-id="03904-120">When the application gets a request, it puts a work item onto a queue and immediately returns the response.</span></span> <span data-ttu-id="03904-121">然後個別的後端程序會從佇列的工作項目，並完成工作。</span><span class="sxs-lookup"><span data-stu-id="03904-121">Then a separate backend process pulls work items from the queue and does the work.</span></span>

<span data-ttu-id="03904-122">以佇列為主的工作模式適合用來：</span><span class="sxs-lookup"><span data-stu-id="03904-122">The queue-centric work pattern is useful for:</span></span>

- <span data-ttu-id="03904-123">很多時間 （高延遲） 的工作。</span><span class="sxs-lookup"><span data-stu-id="03904-123">Work that is time consuming (high latency).</span></span>
- <span data-ttu-id="03904-124">需要外部的服務可能不一定有足夠的工作。</span><span class="sxs-lookup"><span data-stu-id="03904-124">Work that requires an external service that might not always be available.</span></span>
- <span data-ttu-id="03904-125">也就是使用大量資源 (高 CPU)。</span><span class="sxs-lookup"><span data-stu-id="03904-125">Work that is resource-intensive (high CPU).</span></span>
- <span data-ttu-id="03904-126">調節 （受限於突然負載高載） 的速率而獲益的工作。</span><span class="sxs-lookup"><span data-stu-id="03904-126">Work that would benefit from rate leveling (subject to sudden load bursts).</span></span>

## <a name="reduced-latency"></a><span data-ttu-id="03904-127">較低的延遲</span><span class="sxs-lookup"><span data-stu-id="03904-127">Reduced Latency</span></span>

<span data-ttu-id="03904-128">佇列是的每當您執行耗時的工作很有用。</span><span class="sxs-lookup"><span data-stu-id="03904-128">Queues are useful any time you are doing time-consuming work.</span></span> <span data-ttu-id="03904-129">如果工作需要幾秒鐘或更久，而不會封鎖使用者，將工作項目放入佇列。</span><span class="sxs-lookup"><span data-stu-id="03904-129">If a task takes a few seconds or longer, instead of blocking the end user, put the work item into a queue.</span></span> <span data-ttu-id="03904-130">「 我們正努力，"會告訴使用者，然後使用佇列接聽程式來處理在背景工作。</span><span class="sxs-lookup"><span data-stu-id="03904-130">Tell the user "We're working on it," and then use a queue listener to process the task in the background.</span></span>

<span data-ttu-id="03904-131">比方說，當您購買項目在線上零售店，網站會確認您的訂單立即。</span><span class="sxs-lookup"><span data-stu-id="03904-131">For example, when you purchase something at an online retailer, the web site confirms your order immediately.</span></span> <span data-ttu-id="03904-132">但這並不表示您的資料已在 「 卡車 」 傳遞。</span><span class="sxs-lookup"><span data-stu-id="03904-132">But that doesn't mean your stuff is already in a truck being delivered.</span></span> <span data-ttu-id="03904-133">他們將工作放在佇列中，以及在背景中進行信用查核，準備您的項目進行傳送，和這些等。</span><span class="sxs-lookup"><span data-stu-id="03904-133">They put a task in a queue, and in the background they are doing the credit check, preparing your items for shipping, and so forth.</span></span>

<span data-ttu-id="03904-134">短暫延遲的情況下，總計的端對端時間可能較長的使用佇列，相較於以同步方式執行該工作。</span><span class="sxs-lookup"><span data-stu-id="03904-134">For scenarios with short latency, the total end-to-end time might be longer using a queue, compared with doing the task synchronously.</span></span> <span data-ttu-id="03904-135">但即使如此，其他優點會勝的缺點。</span><span class="sxs-lookup"><span data-stu-id="03904-135">But even then, the other benefits can outweigh that disadvantage.</span></span>

## <a name="increased-reliability"></a><span data-ttu-id="03904-136">增加的可靠性</span><span class="sxs-lookup"><span data-stu-id="03904-136">Increased Reliability</span></span>

<span data-ttu-id="03904-137">修正它，我們探討了目前的版本，在 web 前端會緊密結合的 SQL Database 後端。</span><span class="sxs-lookup"><span data-stu-id="03904-137">In the version of Fix It that we've been looking at so far, the web front-end is tightly coupled with the SQL Database back-end.</span></span> <span data-ttu-id="03904-138">如果 SQL database 服務無法使用時，使用者會收到錯誤。</span><span class="sxs-lookup"><span data-stu-id="03904-138">If the SQL database service is unavailable, the user gets an error.</span></span> <span data-ttu-id="03904-139">如果重試無法運作 （也就是失敗是多個暫時性），您可以執行的唯一會顯示錯誤，並要求使用者稍後再試。</span><span class="sxs-lookup"><span data-stu-id="03904-139">If retries don't work (that is, the failure is more than transient), the only thing you can do is show an error and ask the user to try again later.</span></span>

![圖表顯示的 web 前端失敗的 SQL Database 後端的失敗時](queue-centric-work-pattern/_static/image1.png)

<span data-ttu-id="03904-141">當使用者提交 Fix It 工作，請使用佇列，應用程式可以將訊息寫入佇列。</span><span class="sxs-lookup"><span data-stu-id="03904-141">Using queues, when a user submits a Fix It task, the app writes a message to the queue.</span></span> <span data-ttu-id="03904-142">訊息承載[JSON](http://json.org/)工作的表示法。</span><span class="sxs-lookup"><span data-stu-id="03904-142">The message payload is a [JSON](http://json.org/) representation of the task.</span></span> <span data-ttu-id="03904-143">只要將訊息寫入至佇列，應用程式就會傳回，並立即向使用者顯示成功訊息。</span><span class="sxs-lookup"><span data-stu-id="03904-143">As soon as the message is written to the queue, the app returns and immediately shows a success message to the user.</span></span>

<span data-ttu-id="03904-144">如果任何後端服務 – 例如，SQL database 或佇列接聽程式--離線，使用者仍然可以提交新修正它的工作。</span><span class="sxs-lookup"><span data-stu-id="03904-144">If any of the backend services – such as the SQL database or the queue listener -- go offline, users can still submit new Fix It tasks.</span></span> <span data-ttu-id="03904-145">後端服務再度變成可用之前，只是排入佇列的訊息。</span><span class="sxs-lookup"><span data-stu-id="03904-145">The messages will just queue up until the backend services are available again.</span></span> <span data-ttu-id="03904-146">此時後, 端服務會趕上進度待辦項目。</span><span class="sxs-lookup"><span data-stu-id="03904-146">At that point, the backend services will catch up on the backlog.</span></span>

![此圖顯示 web 前端繼續函式 SQL Database 錯誤時](queue-centric-work-pattern/_static/image2.png)

<span data-ttu-id="03904-148">此外，現在您可以新增更多的後端邏輯而不需擔心前端的恢復功能。</span><span class="sxs-lookup"><span data-stu-id="03904-148">Moreover, now you can add more backend logic without worrying about the resiliency of the front end.</span></span> <span data-ttu-id="03904-149">比方說，您可能要將電子郵件或 SMS 訊息傳送至擁有者，只要指派新修正它。</span><span class="sxs-lookup"><span data-stu-id="03904-149">For example, you might want to send an email or SMS message to the owner whenever a new Fix It is assigned.</span></span> <span data-ttu-id="03904-150">如果電子郵件或 SMS 服務變成無法使用，可處理所有項目，然後再將訊息放入個別的佇列，以傳送電子郵件/簡訊。</span><span class="sxs-lookup"><span data-stu-id="03904-150">If the email or SMS service becomes unavailable, you can process everything else, and then put a message into a separate queue for sending email/SMS messages.</span></span>

<span data-ttu-id="03904-151">以前，我們有效的 SLA 是 Web Apps&times;儲存體&times;SQL Database = 99.7%。</span><span class="sxs-lookup"><span data-stu-id="03904-151">Previously, our effective SLA was Web Apps &times; Storage &times; SQL Database = 99.7%.</span></span> <span data-ttu-id="03904-152">(請參閱[設計存留失敗](design-to-survive-failures.md)。)</span><span class="sxs-lookup"><span data-stu-id="03904-152">(See [Design to Survive Failures](design-to-survive-failures.md).)</span></span>

<span data-ttu-id="03904-153">當我們變更應用程式使用佇列時，web 前端僅取決於 Web 應用程式和儲存體，複合 99.8%的 SLA。</span><span class="sxs-lookup"><span data-stu-id="03904-153">When we change the app to use a queue, the web front end depends only on Web Apps and Storage, for a composite SLA of 99.8%.</span></span> <span data-ttu-id="03904-154">（請注意，佇列是 Azure 儲存體服務的一部分，因此它們會包含在相同的 SLA，做為 blob 儲存體）。</span><span class="sxs-lookup"><span data-stu-id="03904-154">(Note that queues are part of the Azure storage service, so they are included in the same SLA as blob storage.)</span></span>

<span data-ttu-id="03904-155">如果您需要更棒的是比 99.8%，則您可以在兩個不同區域中建立兩個佇列。</span><span class="sxs-lookup"><span data-stu-id="03904-155">If you need even better than 99.8%, you can create two queues in two different regions.</span></span> <span data-ttu-id="03904-156">將做為主要伺服器上，而另一個指定為次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="03904-156">Designate one as the primary, and the other as the secondary.</span></span> <span data-ttu-id="03904-157">在您的應用程式中，容錯移轉至次要佇列如果主要佇列無法使用。</span><span class="sxs-lookup"><span data-stu-id="03904-157">In your app, fail over to the secondary queue if the primary queue is not available.</span></span> <span data-ttu-id="03904-158">這兩個變成無法使用一次的機會就非常渺小。</span><span class="sxs-lookup"><span data-stu-id="03904-158">The chance of both being unavailable at the same time is very small.</span></span>

## <a name="rate-leveling-and-independent-scaling"></a><span data-ttu-id="03904-159">速率調節，以及獨立調整</span><span class="sxs-lookup"><span data-stu-id="03904-159">Rate Leveling and Independent Scaling</span></span>

<span data-ttu-id="03904-160">佇列也可用於所謂*速率調節*或是*負載調節*。</span><span class="sxs-lookup"><span data-stu-id="03904-160">Queues are also useful for something called *rate leveling* or *load leveling*.</span></span>

<span data-ttu-id="03904-161">Web 應用程式很容易在流量突然暴增。</span><span class="sxs-lookup"><span data-stu-id="03904-161">Web apps are often susceptible to sudden bursts in traffic.</span></span> <span data-ttu-id="03904-162">雖然您可以使用自動調整，自動將 web 伺服器，以處理增加的網路流量，自動調整可能無法回應速度不夠快處理突然尖峰負載。</span><span class="sxs-lookup"><span data-stu-id="03904-162">While you can use autoscaling to automatically add web servers to handle increased web traffic, autoscaling might not be able to react quickly enough to handle abrupt spikes in load.</span></span> <span data-ttu-id="03904-163">如果 web 伺服器可以卸載某些工作，他們只需要藉由將訊息寫入佇列，它們能夠處理更多流量。</span><span class="sxs-lookup"><span data-stu-id="03904-163">If the web servers can offload some of the work they have to do by writing a message to a queue, they can handle more traffic.</span></span> <span data-ttu-id="03904-164">後端服務可以接著從佇列讀取訊息並加以處理。</span><span class="sxs-lookup"><span data-stu-id="03904-164">A backend service can then read messages from the queue and process them.</span></span> <span data-ttu-id="03904-165">佇列的深度會放大或縮小的傳入的負載互異。</span><span class="sxs-lookup"><span data-stu-id="03904-165">The depth of the queue will grow or shrink as the incoming load varies.</span></span>

<span data-ttu-id="03904-166">大部分的耗時工作卸載給後端服務，web 層可以更輕鬆地回應突然出現流量尖峰。</span><span class="sxs-lookup"><span data-stu-id="03904-166">With much of its time-consuming work off-loaded to a backend service, the web tier can more easily respond to sudden spikes in traffic.</span></span> <span data-ttu-id="03904-167">和您節省成本，因為較少的 web 伺服器可以處理任何指定的數量的流量。</span><span class="sxs-lookup"><span data-stu-id="03904-167">And you save money because any given amount of traffic can be handled by fewer web servers.</span></span>

<span data-ttu-id="03904-168">您可以在 web 層和後端服務會分別調整。</span><span class="sxs-lookup"><span data-stu-id="03904-168">You can scale the web tier and backend service independently.</span></span> <span data-ttu-id="03904-169">例如，您可能需要三部 web 伺服器，但只有一個伺服器處理佇列訊息。</span><span class="sxs-lookup"><span data-stu-id="03904-169">For example, you might need three web servers but only one server processing queue messages.</span></span> <span data-ttu-id="03904-170">或者，如果您在背景中執行運算密集工作，您可能需要更多的後端伺服器。</span><span class="sxs-lookup"><span data-stu-id="03904-170">Or if you're running a compute-intensive task in the background, you might need more backend servers.</span></span>

![](queue-centric-work-pattern/_static/image3.png)

<span data-ttu-id="03904-171">自動調整運作方式與後端服務以及 web 層。</span><span class="sxs-lookup"><span data-stu-id="03904-171">Autoscaling works with backend services as well as with the web tier.</span></span> <span data-ttu-id="03904-172">您可以相應增加或相應減少處理的工作在佇列中後, 端 Vm 的 CPU 使用量為基礎的 Vm 數目。</span><span class="sxs-lookup"><span data-stu-id="03904-172">You can scale up or scale down the number of VMs that are processing the tasks in the queue, based on the CPU usage of the backend VMs.</span></span> <span data-ttu-id="03904-173">或者，您可以在佇列中有多少項目為基礎的自動調整。</span><span class="sxs-lookup"><span data-stu-id="03904-173">Or, you can autoscale based on how many items are in a queue.</span></span> <span data-ttu-id="03904-174">比方說，您可以告訴自動調整功能再嘗試將佇列中保留最多 10 個項目。</span><span class="sxs-lookup"><span data-stu-id="03904-174">For example, you can tell autoscale to try to keep no more than 10 items in the queue.</span></span> <span data-ttu-id="03904-175">如果佇列有 10 個以上的項目，會將 Vm 新增自動調整規模。</span><span class="sxs-lookup"><span data-stu-id="03904-175">If the queue has more than 10 items, autoscale will add VMs.</span></span> <span data-ttu-id="03904-176">跟上時自動調整規模將會卸除額外的 Vm。</span><span class="sxs-lookup"><span data-stu-id="03904-176">When they catch up, autoscale will tear down the extra VMs.</span></span>

## <a name="adding-queues-to-the-fix-it-application"></a><span data-ttu-id="03904-177">將它排入佇列的修正程式的應用程式</span><span class="sxs-lookup"><span data-stu-id="03904-177">Adding Queues to the Fix It Application</span></span>

<span data-ttu-id="03904-178">若要實作的佇列模式，我們需要修正其應用程式進行兩項變更。</span><span class="sxs-lookup"><span data-stu-id="03904-178">To implement the queue pattern, we need to make two changes to the Fix It app.</span></span>

- <span data-ttu-id="03904-179">當使用者提交新修正它的工作時，請將工作放在佇列中，而不是寫入至資料庫。</span><span class="sxs-lookup"><span data-stu-id="03904-179">When a user submits a new Fix It task, put the task in the queue, instead of writing it to the database.</span></span>
- <span data-ttu-id="03904-180">建立後端服務，以處理佇列中的訊息。</span><span class="sxs-lookup"><span data-stu-id="03904-180">Create a back-end service that processes messages in the queue.</span></span>

<span data-ttu-id="03904-181">我們將使用佇列[Azure 佇列儲存體服務](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/)。</span><span class="sxs-lookup"><span data-stu-id="03904-181">For the queue, we'll use the [Azure Queue Storage Service](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/).</span></span> <span data-ttu-id="03904-182">另一個選項是使用[Azure 服務匯流排](https://docs.microsoft.com/azure/service-bus/)。</span><span class="sxs-lookup"><span data-stu-id="03904-182">Another option is to use [Azure Service Bus](https://docs.microsoft.com/azure/service-bus/).</span></span>

<span data-ttu-id="03904-183">若要決定要使用的佇列服務，請考慮您的應用程式需要的方式傳送和接收佇列中的訊息：</span><span class="sxs-lookup"><span data-stu-id="03904-183">To decide which queue service to use, consider how your app needs to send and receive the messages in the queue:</span></span>

- <span data-ttu-id="03904-184">如果您合作的產生者和競爭取用者，請考慮使用 Azure 佇列儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="03904-184">If you have cooperating producers and competing consumers, consider using Azure Queue Storage Service.</span></span> <span data-ttu-id="03904-185">「 Cooperating 生產者 」 表示多個處理序會將訊息新增至佇列。</span><span class="sxs-lookup"><span data-stu-id="03904-185">"Cooperating producers" means multiple processes are adding messages to a queue.</span></span> <span data-ttu-id="03904-186">「 競爭取用者 」 表示多個處理序提取訊息從佇列處理它們，但任何指定的訊息只能處理一個 「 取用者。 」</span><span class="sxs-lookup"><span data-stu-id="03904-186">"Competing consumers" means multiple processes are pulling messages off the queue to process them, but any given message can only be processed by one "consumer."</span></span> <span data-ttu-id="03904-187">如果您需要更多的輸送量比可以使用單一佇列，請使用其他的佇列和/或其他儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="03904-187">If you need more throughput than you can get with a single queue, use additional queues and/or additional storage accounts.</span></span>
- <span data-ttu-id="03904-188">如果您需要[發佈/訂閱模型](http://en.wikipedia.org/wiki/Publish/subscribe)，請考慮使用 Azure 服務匯流排佇列。</span><span class="sxs-lookup"><span data-stu-id="03904-188">If you need a [publish/subscribe model](http://en.wikipedia.org/wiki/Publish/subscribe), consider using Azure Service Bus Queues.</span></span>

<span data-ttu-id="03904-189">修正其應用程式符合合作的產生者和競爭取用者模型。</span><span class="sxs-lookup"><span data-stu-id="03904-189">The Fix It app fits the cooperating producers and competing consumers model.</span></span>

<span data-ttu-id="03904-190">另一個考量是應用程式的可用性。</span><span class="sxs-lookup"><span data-stu-id="03904-190">Another consideration is application availability.</span></span> <span data-ttu-id="03904-191">佇列儲存體服務屬於相同的服務，我們會使用 blob 儲存體，因此使用它不會影響我們的 SLA。</span><span class="sxs-lookup"><span data-stu-id="03904-191">The Queue Storage Service is part of the same service that we're using for blob storage, so using it has no effect on our SLA.</span></span> <span data-ttu-id="03904-192">Azure 服務匯流排是個別的服務，以它自己的 SLA。</span><span class="sxs-lookup"><span data-stu-id="03904-192">Azure Service Bus is a separate service with its own SLA.</span></span> <span data-ttu-id="03904-193">如果我們使用服務匯流排佇列時，我們必須納入其他的 SLA 百分比，以及複合 SLA 會降低。</span><span class="sxs-lookup"><span data-stu-id="03904-193">If we used Service Bus Queues, we would have to factor in an additional SLA percentage, and our composite SLA would be lower.</span></span> <span data-ttu-id="03904-194">當您選擇的佇列服務時，請確定您了解您選擇對應用程式可用性的影響。</span><span class="sxs-lookup"><span data-stu-id="03904-194">When you're choosing a queue service, make sure you understand the impact of your choice on application availability.</span></span> <span data-ttu-id="03904-195">如需詳細資訊，請參閱 <<c0> [ 資源](#resources)一節。</span><span class="sxs-lookup"><span data-stu-id="03904-195">For more information, see the [Resources](#resources) section.</span></span>

## <a name="creating-queue-messages"></a><span data-ttu-id="03904-196">建立佇列訊息</span><span class="sxs-lookup"><span data-stu-id="03904-196">Creating Queue Messages</span></span>

<span data-ttu-id="03904-197">若要將 Fix It 」 工作放在佇列上，web 前端，請執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="03904-197">To put a Fix It task on the queue, the web front end performs the following steps:</span></span>

1. <span data-ttu-id="03904-198">建立[CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx)執行個體。</span><span class="sxs-lookup"><span data-stu-id="03904-198">Create a [CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx) instance.</span></span> <span data-ttu-id="03904-199">`CloudQueueClient`執行個體用來執行對佇列服務的要求。</span><span class="sxs-lookup"><span data-stu-id="03904-199">The `CloudQueueClient` instance is used to execute requests against the Queue Service.</span></span>
2. <span data-ttu-id="03904-200">如果尚不存在，請建立佇列。</span><span class="sxs-lookup"><span data-stu-id="03904-200">Create the queue, if it doesn't exist yet.</span></span>
3. <span data-ttu-id="03904-201">將序列化 Fix It 工作。</span><span class="sxs-lookup"><span data-stu-id="03904-201">Serialize the Fix It task.</span></span>
4. <span data-ttu-id="03904-202">呼叫[CloudQueue.AddMessageAsync](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx)將訊息放到佇列。</span><span class="sxs-lookup"><span data-stu-id="03904-202">Call [CloudQueue.AddMessageAsync](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx) to put the message onto the queue.</span></span>

<span data-ttu-id="03904-203">我們會進行這項工作的建構函式和`SendMessageAsync`的新方法`FixItQueueManager`類別。</span><span class="sxs-lookup"><span data-stu-id="03904-203">We'll do this work in the constructor and `SendMessageAsync` method of a new `FixItQueueManager` class.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample1.cs?highlight=11-12,16,18-25)]

<span data-ttu-id="03904-204">我們將使用以下[Json.NET](https://github.com/JamesNK/Newtonsoft.Json)序列化為 JSON 格式 fixit 的程式庫。</span><span class="sxs-lookup"><span data-stu-id="03904-204">Here we are using the [Json.NET](https://github.com/JamesNK/Newtonsoft.Json) library to serialize the fixit to JSON format.</span></span> <span data-ttu-id="03904-205">您可以使用任何您偏好的序列化方法。</span><span class="sxs-lookup"><span data-stu-id="03904-205">You can use whatever serialization approach you prefer.</span></span> <span data-ttu-id="03904-206">JSON 具有的優點是人類看得懂，同時不比 XML 簡潔。</span><span class="sxs-lookup"><span data-stu-id="03904-206">JSON has the advantage of being human-readable, while being less verbose than XML.</span></span>

<span data-ttu-id="03904-207">生產環境品質的程式碼會新增錯誤處理邏輯，暫停如果資料庫變成無法使用、 更簡潔地處理復原、 在應用程式啟動時，建立佇列及管理 「[有害 」 訊息](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx)。</span><span class="sxs-lookup"><span data-stu-id="03904-207">Production-quality code would add error handling logic, pause if the database became unavailable, handle recovery more cleanly, create the queue on application start-up, and manage "[poison" messages](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx).</span></span> <span data-ttu-id="03904-208">（有害訊息是因為某些原因無法處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="03904-208">(A poison message is a message that cannot be processed for some reason.</span></span> <span data-ttu-id="03904-209">您不想要放入佇列，其中背景工作角色會持續嘗試進行處理、 失敗、 再試一次、 失敗，等等的有害訊息。）</span><span class="sxs-lookup"><span data-stu-id="03904-209">You don't want poison messages to sit in the queue, where the worker role will continually try to process them, fail, try again, fail, and so on.)</span></span>

<span data-ttu-id="03904-210">在前端的 MVC 應用程式中，我們需要更新建立新工作的程式碼。</span><span class="sxs-lookup"><span data-stu-id="03904-210">In the front-end MVC application, we need to update the code that creates a new task.</span></span> <span data-ttu-id="03904-211">而不是將工作放入存放庫中，呼叫`SendMessageAsync`如上所示的方法。</span><span class="sxs-lookup"><span data-stu-id="03904-211">Instead of putting the task into the repository, call the `SendMessageAsync` method shown above.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample2.cs?highlight=10)]

## <a name="processing-queue-messages"></a><span data-ttu-id="03904-212">處理佇列訊息</span><span class="sxs-lookup"><span data-stu-id="03904-212">Processing Queue Messages</span></span>

<span data-ttu-id="03904-213">若要處理佇列中的訊息，我們將建立後端服務。</span><span class="sxs-lookup"><span data-stu-id="03904-213">To process messages in the queue, we'll create a backend service.</span></span> <span data-ttu-id="03904-214">後端服務會執行一個無限迴圈，執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="03904-214">The backend service will run an infinite loop that performs the following steps:</span></span>

1. <span data-ttu-id="03904-215">從佇列取得下一個訊息。</span><span class="sxs-lookup"><span data-stu-id="03904-215">Get the next message from the queue.</span></span>
2. <span data-ttu-id="03904-216">修正它工作將訊息還原序列化。</span><span class="sxs-lookup"><span data-stu-id="03904-216">Deserialize the message to a Fix It task.</span></span>
3. <span data-ttu-id="03904-217">寫入資料庫中的 It 工作。</span><span class="sxs-lookup"><span data-stu-id="03904-217">Write the Fix It task to the database.</span></span>

<span data-ttu-id="03904-218">若要裝載的後端服務，我們將建立 Azure 雲端服務，其中包含*背景工作角色*。</span><span class="sxs-lookup"><span data-stu-id="03904-218">To host the backend service, we'll create an Azure Cloud Service that contains a *worker role*.</span></span> <span data-ttu-id="03904-219">背景工作角色可以執行後端處理的一或多個 Vm 所組成。</span><span class="sxs-lookup"><span data-stu-id="03904-219">A worker role consists of one or more VMs that can do backend processing.</span></span> <span data-ttu-id="03904-220">在這些 Vm 中執行的程式碼會提取從佇列中可用的訊息。</span><span class="sxs-lookup"><span data-stu-id="03904-220">The code that runs in these VMs will pull messages from the queue as they become available.</span></span> <span data-ttu-id="03904-221">對於每個訊息中，我們會還原序列化的 JSON 承載，並修正它工作實體的執行個體寫入至資料庫，使用我們稍早在 web 層中使用的相同儲存機制。</span><span class="sxs-lookup"><span data-stu-id="03904-221">For each message, we'll deserialize the JSON payload and write an instance of the Fix It Task entity to the database, using the same repository that we used earlier in the web tier.</span></span>

<span data-ttu-id="03904-222">下列步驟示範如何新增背景工作角色專案，以具有標準的 web 專案的方案。</span><span class="sxs-lookup"><span data-stu-id="03904-222">The following steps show how to add a worker role project to a solution that has a standard web project.</span></span> <span data-ttu-id="03904-223">已修正它在專案中，您可以下載完成這些步驟。</span><span class="sxs-lookup"><span data-stu-id="03904-223">These steps have already been done in the Fix It project that you can download.</span></span>

<span data-ttu-id="03904-224">第一次將雲端服務專案新增至 Visual Studio 方案中。</span><span class="sxs-lookup"><span data-stu-id="03904-224">First add a Cloud Service project to the Visual Studio solution.</span></span> <span data-ttu-id="03904-225">以滑鼠右鍵按一下方案，然後選取**新增**，然後**新的專案**。</span><span class="sxs-lookup"><span data-stu-id="03904-225">Right-click the solution and select **Add**, then **New Project**.</span></span> <span data-ttu-id="03904-226">在左窗格中，依序展開**Visual C#** ，然後選取**雲端**。</span><span class="sxs-lookup"><span data-stu-id="03904-226">In the left pane, expand **Visual C#** and select **Cloud**.</span></span>

[![](queue-centric-work-pattern/_static/image5.png)](queue-centric-work-pattern/_static/image4.png)

<span data-ttu-id="03904-227">在 [**新的 Azure 雲端服務**] 對話方塊中，展開**Visual C#** 在左窗格中的節點。</span><span class="sxs-lookup"><span data-stu-id="03904-227">In the **New Azure Cloud Service** dialog, expand the **Visual C#** node on the left pane.</span></span> <span data-ttu-id="03904-228">選取 **背景工作角色**，然後按一下向右箭號圖示。</span><span class="sxs-lookup"><span data-stu-id="03904-228">Select **Worker Role** and click the right-arrow icon.</span></span>

![](queue-centric-work-pattern/_static/image6.png)

<span data-ttu-id="03904-229">(請注意，您也可以加入*web 角色*。</span><span class="sxs-lookup"><span data-stu-id="03904-229">(Notice that you can also add a *web role*.</span></span> <span data-ttu-id="03904-230">我們可以執行修正它在相同的雲端服務，而不是執行它在 Azure 網站前端。</span><span class="sxs-lookup"><span data-stu-id="03904-230">We could run the Fix It front-end in the same Cloud Service instead of running it in an Azure Web Site.</span></span> <span data-ttu-id="03904-231">具有一些優點，讓您更輕鬆地協調前端與後端之間的連線。</span><span class="sxs-lookup"><span data-stu-id="03904-231">That has some advantages in making connections between front-end and back-end easier to coordinate.</span></span> <span data-ttu-id="03904-232">不過，為了簡化這段示範影片，正在將前端放在 Azure App Service Web 應用程式，並只執行雲端服務中的 後端。）</span><span class="sxs-lookup"><span data-stu-id="03904-232">However, to keep this demo simple, we're keeping the front-end in an Azure App Service Web App and only running the back-end in a Cloud Service.)</span></span>

<span data-ttu-id="03904-233">將預設名稱被指派給背景工作角色。</span><span class="sxs-lookup"><span data-stu-id="03904-233">A default name is assigned to the worker role.</span></span> <span data-ttu-id="03904-234">若要變更名稱，滑鼠停留在背景工作角色，在右窗格中，然後按一下鉛筆圖示。</span><span class="sxs-lookup"><span data-stu-id="03904-234">To change the name, hover the mouse over the worker role in the right pane, then click the pencil icon.</span></span>

![](queue-centric-work-pattern/_static/image7.png)

<span data-ttu-id="03904-235">按一下 **確定**來完成對話方塊。</span><span class="sxs-lookup"><span data-stu-id="03904-235">Click **OK** to complete the dialog.</span></span> <span data-ttu-id="03904-236">這會將兩個專案加入至 Visual Studio 方案中。</span><span class="sxs-lookup"><span data-stu-id="03904-236">This adds two projects to the Visual Studio solution.</span></span>

- <span data-ttu-id="03904-237">Azure 專案定義雲端服務，包括組態資訊。</span><span class="sxs-lookup"><span data-stu-id="03904-237">an Azure project that defines the cloud service, including configuration information.</span></span>
- <span data-ttu-id="03904-238">定義背景工作角色的背景工作角色專案。</span><span class="sxs-lookup"><span data-stu-id="03904-238">A worker role project that defines the worker role.</span></span>

![](queue-centric-work-pattern/_static/image8.png)

<span data-ttu-id="03904-239">如需詳細資訊，請參閱[使用 Visual Studio 建立 Azure 專案。](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)</span><span class="sxs-lookup"><span data-stu-id="03904-239">For more information, see [Creating an Azure Project with Visual Studio.](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)</span></span>

<span data-ttu-id="03904-240">在背景工作角色中，我們輪詢訊息藉由呼叫`ProcessMessageAsync`方法的`FixItQueueManager`上文所述的類別。</span><span class="sxs-lookup"><span data-stu-id="03904-240">Inside the worker role, we poll for messages by calling the `ProcessMessageAsync` method of the `FixItQueueManager` class that we saw earlier.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample3.cs?highlight=25)]

<span data-ttu-id="03904-241">`ProcessMessagesAsync`方法會檢查是否有訊息等待。</span><span class="sxs-lookup"><span data-stu-id="03904-241">The `ProcessMessagesAsync` method checks if there's a message waiting.</span></span> <span data-ttu-id="03904-242">如果有的話，它將訊息還原序列化成`FixItTask`實體，並將實體儲存在資料庫中。</span><span class="sxs-lookup"><span data-stu-id="03904-242">If there is one, it deserializes the message into a `FixItTask` entity and saves the entity in the database.</span></span> <span data-ttu-id="03904-243">它會循環直到佇列是空的。</span><span class="sxs-lookup"><span data-stu-id="03904-243">It loops until the queue is empty.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample4.cs)]

<span data-ttu-id="03904-244">輪詢的佇列訊息時，會產生小型的交易收費，所以在沒有訊息等待處理，背景工作角色`RunAsync`方法會等候一秒再輪詢一次呼叫`Task.Delay(1000)`。</span><span class="sxs-lookup"><span data-stu-id="03904-244">Polling for queue messages incurs a small transaction charge, so when there's no message waiting to be processed, the worker role's `RunAsync` method waits a second before polling again by calling `Task.Delay(1000)`.</span></span>

<span data-ttu-id="03904-245">在 web 專案中，新增非同步程式碼可以自動改善效能，因為 IIS 管理有限的執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="03904-245">In a web project, adding asynchronous code can automatically improve performance because IIS manages a limited thread pool.</span></span> <span data-ttu-id="03904-246">不在背景工作角色專案中的案例。</span><span class="sxs-lookup"><span data-stu-id="03904-246">That is not the case in a worker role project.</span></span> <span data-ttu-id="03904-247">若要改善延展性的背景工作角色，您可以撰寫多執行緒程式碼，或使用非同步程式碼來實作[平行程式設計](https://msdn.microsoft.com/library/ff963553.aspx)。</span><span class="sxs-lookup"><span data-stu-id="03904-247">To improve scalability of the worker role, you can write multi-threaded code or use asynchronous code to implement [parallel programming](https://msdn.microsoft.com/library/ff963553.aspx).</span></span> <span data-ttu-id="03904-248">此範例不會實作平行程式設計，但示範如何讓程式碼非同步，因此您可以實作平行程式設計。</span><span class="sxs-lookup"><span data-stu-id="03904-248">The sample doesn't implement parallel programming but shows how to make the code asynchronous so you can implement parallel programming.</span></span>

## <a name="summary"></a><span data-ttu-id="03904-249">總結</span><span class="sxs-lookup"><span data-stu-id="03904-249">Summary</span></span>

<span data-ttu-id="03904-250">在這一章中，您已了解如何改善應用程式回應速度、 可靠性和延展性，藉由實作以佇列為主的工作模式。</span><span class="sxs-lookup"><span data-stu-id="03904-250">In this chapter you've seen how to improve application responsiveness, reliability, and scalability by implementing the queue-centric work pattern.</span></span>

<span data-ttu-id="03904-251">這是本電子書，涵蓋 13 模式的最後一個，但當然還有許多其他的模式和作法，可協助您建置成功的雲端應用程式。</span><span class="sxs-lookup"><span data-stu-id="03904-251">This is the last of the 13 patterns covered in this e-book, but there are of course many other patterns and practices that can help you build successful cloud apps.</span></span> <span data-ttu-id="03904-252">[最後一章](more-patterns-and-guidance.md)的主題未涵蓋的這些 13 的模式，提供資源的連結。</span><span class="sxs-lookup"><span data-stu-id="03904-252">The [final chapter](more-patterns-and-guidance.md) provides links to resources for topics that haven't been covered in these 13 patterns.</span></span>

<a id="resources"></a>
## <a name="resources"></a><span data-ttu-id="03904-253">資源</span><span class="sxs-lookup"><span data-stu-id="03904-253">Resources</span></span>

<span data-ttu-id="03904-254">如需有關佇列的詳細資訊，請參閱下列資源。</span><span class="sxs-lookup"><span data-stu-id="03904-254">For more information about queues, see the following resources.</span></span>

<span data-ttu-id="03904-255">文件：</span><span class="sxs-lookup"><span data-stu-id="03904-255">Documentation:</span></span>

- <span data-ttu-id="03904-256">[Microsoft Azure 儲存體佇列第 1 部分： 開始使用](http://justazure.com/microsoft-azure-storage-queues-part-1-getting-started/)。</span><span class="sxs-lookup"><span data-stu-id="03904-256">[Microsoft Azure Storage Queues Part 1: Getting Started](http://justazure.com/microsoft-azure-storage-queues-part-1-getting-started/).</span></span> <span data-ttu-id="03904-257">Roman Schacherl 文章。</span><span class="sxs-lookup"><span data-stu-id="03904-257">Article by Roman Schacherl.</span></span>
- <span data-ttu-id="03904-258">[執行背景工作](https://msdn.microsoft.com/library/ff803365.aspx)，第 5 章[應用程式移至雲端，也就是第 3 版](https://msdn.microsoft.com/library/ff728592.aspx)從 Microsoft Patterns and Practices。</span><span class="sxs-lookup"><span data-stu-id="03904-258">[Executing Background Tasks](https://msdn.microsoft.com/library/ff803365.aspx), chapter 5 of [Moving Applications to the Cloud, 3rd Edition](https://msdn.microsoft.com/library/ff728592.aspx) from Microsoft Patterns and Practices.</span></span> <span data-ttu-id="03904-259">(特別是，一節[「 使用 Azure 儲存體佇列 」](https://msdn.microsoft.com/library/ff803365.aspx#sec7)。)</span><span class="sxs-lookup"><span data-stu-id="03904-259">(In particular, the section ["Using Azure Storage Queues"](https://msdn.microsoft.com/library/ff803365.aspx#sec7).)</span></span>
- <span data-ttu-id="03904-260">[最大化延展性和成本的效益的 Azure 上的佇列架構傳訊解決方案的最佳作法](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx)。</span><span class="sxs-lookup"><span data-stu-id="03904-260">[Best Practices for Maximizing Scalability and Cost Effectiveness of Queue-Based Messaging Solutions on Azure](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx).</span></span> <span data-ttu-id="03904-261">由 Valery Mizonov 詘躩裛。</span><span class="sxs-lookup"><span data-stu-id="03904-261">White paper by Valery Mizonov.</span></span>
- <span data-ttu-id="03904-262">[比較 Azure 佇列和服務匯流排佇列](https://msdn.microsoft.com/magazine/jj159884.aspx)。</span><span class="sxs-lookup"><span data-stu-id="03904-262">[Comparing Azure Queues and Service Bus Queues](https://msdn.microsoft.com/magazine/jj159884.aspx).</span></span> <span data-ttu-id="03904-263">MSDN Magazine 文章會提供可協助您選擇要使用的佇列服務的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="03904-263">MSDN Magazine article, provides additional information that can help you choose which queue service to use.</span></span> <span data-ttu-id="03904-264">本文章提及服務匯流排是相依於 ACS 進行驗證，表示無法使用 ACS 時，SB 佇列可能會無法使用。</span><span class="sxs-lookup"><span data-stu-id="03904-264">The article mentions that Service Bus is dependent on ACS for authentication, which means your SB queues would be unavailable when ACS is unavailable.</span></span> <span data-ttu-id="03904-265">不過，因為發行項所撰寫，SB 已變更為可讓您使用[SAS 權杖](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx)作為 ACS 的替代方案。</span><span class="sxs-lookup"><span data-stu-id="03904-265">However, since the article was written, SB was changed to enable you to use [SAS tokens](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx) as an alternative to ACS.</span></span>
- <span data-ttu-id="03904-266">[Microsoft Patterns and Practices-Azure 指引](https://msdn.microsoft.com/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="03904-266">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/library/dn568099.aspx).</span></span> <span data-ttu-id="03904-267">請參閱非同步傳訊入門 」、 「 管道和篩選條件模式 」、 「 補償交易模式 」、 「 競爭取用者模式、 「 CQRS 模式。</span><span class="sxs-lookup"><span data-stu-id="03904-267">See Asynchronous Messaging primer, Pipes and Filters pattern, Compensating Transaction pattern, Competing Consumers pattern, CQRS pattern.</span></span>
- <span data-ttu-id="03904-268">[CQRS 旅程](https://msdn.microsoft.com/library/jj554200)。</span><span class="sxs-lookup"><span data-stu-id="03904-268">[CQRS Journey](https://msdn.microsoft.com/library/jj554200).</span></span> <span data-ttu-id="03904-269">由 Microsoft Patterns and Practices CQRS 相關的電子書。</span><span class="sxs-lookup"><span data-stu-id="03904-269">E-book about CQRS by Microsoft Patterns and Practices.</span></span>

<span data-ttu-id="03904-270">影片：</span><span class="sxs-lookup"><span data-stu-id="03904-270">Video:</span></span>

- <span data-ttu-id="03904-271">[FailSafe︰ 建置可擴充、 彈性的雲端服務](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="03904-271">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="03904-272">Ulrich Homann、 Marc Mercuri 和 Mark Simms、 包含九部部分影片系列。</span><span class="sxs-lookup"><span data-stu-id="03904-272">Nine-part video series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="03904-273">提供高階的概念和架構原則非常可存取且有趣的方式，取自 Microsoft 客戶諮詢團隊 (CAT) 體驗，與實際客戶的劇本。</span><span class="sxs-lookup"><span data-stu-id="03904-273">Presents high-level concepts and architectural principles in a very accessible and interesting way, with stories drawn from Microsoft Customer Advisory Team (CAT) experience with actual customers.</span></span> <span data-ttu-id="03904-274">Azure 儲存體服務和佇列的簡介，請參閱第 5 集開始 35:13。</span><span class="sxs-lookup"><span data-stu-id="03904-274">For an introduction to the Azure Storage service and queues, see episode 5 starting at 35:13.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="03904-275">[上一頁](distributed-caching.md)
> [下一頁](more-patterns-and-guidance.md)</span><span class="sxs-lookup"><span data-stu-id="03904-275">[Previous](distributed-caching.md)
[Next](more-patterns-and-guidance.md)</span></span>
