---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: 全域錯誤處理中 ASP.NET Web API 2 |Microsoft Docs
author: davidmatson
description: ''
ms.author: riande
ms.date: 02/03/2014
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 3e371760d2b34eb2be492e6ebbb33a5f9f7eff10
ms.sourcegitcommit: 7b4e3936feacb1a8fcea7802aab3e2ea9c8af5b4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/04/2018
ms.locfileid: "48577167"
---
<a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="dc372-102">全域錯誤處理 ASP.NET Web API 2 中</span><span class="sxs-lookup"><span data-stu-id="dc372-102">Global Error Handling in ASP.NET Web API 2</span></span>
====================
<span data-ttu-id="dc372-103">藉由[David Matson](https://github.com/davidmatson)， [Rick Anderson]((https://twitter.com/RickAndMSFT))</span><span class="sxs-lookup"><span data-stu-id="dc372-103">by [David Matson](https://github.com/davidmatson), [Rick Anderson]((https://twitter.com/RickAndMSFT))</span></span>

<span data-ttu-id="dc372-104">立即記錄或全域處理錯誤的 Web API 中沒有任何簡單的方法。</span><span class="sxs-lookup"><span data-stu-id="dc372-104">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="dc372-105">可以透過處理一些未處理的例外狀況[例外狀況篩選條件](exception-handling.md)，但有一些無法處理例外狀況篩選條件的案例。</span><span class="sxs-lookup"><span data-stu-id="dc372-105">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="dc372-106">例如: </span><span class="sxs-lookup"><span data-stu-id="dc372-106">For example:</span></span>

1. <span data-ttu-id="dc372-107">從控制器建構函式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-107">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="dc372-108">從訊息處理常式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-108">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="dc372-109">在路由期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-109">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="dc372-110">在 回應內容序列化期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-110">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="dc372-111">我們想要提供簡單、 一致的方式記錄並處理 （如果可能的話） 這些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-111">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="dc372-112">有兩個主要的案例來處理例外狀況，我們就能夠傳送錯誤回應，並所有我們可以在其中執行的案例是記錄例外狀況的情況。</span><span class="sxs-lookup"><span data-stu-id="dc372-112">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="dc372-113">後者的情況下一個範例是當發生例外狀況的中間資料流處理回應的內容;在此情況下就無法再傳送新的回應訊息，因為狀態碼、 標頭和部分內容已經透過網路，因此我們只是中止連線。</span><span class="sxs-lookup"><span data-stu-id="dc372-113">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="dc372-114">即使無法處理的例外狀況，以產生新的回應訊息，我們仍支援記錄例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-114">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="dc372-115">在我們可以在其中偵測到錯誤的情況下，我們可以傳回適當的錯誤回應，如下列所示：</span><span class="sxs-lookup"><span data-stu-id="dc372-115">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="dc372-116">現有的選項</span><span class="sxs-lookup"><span data-stu-id="dc372-116">Existing Options</span></span>

<span data-ttu-id="dc372-117">除了[例外狀況篩選條件](exception-handling.md)，[訊息處理常式](../advanced/http-message-handlers.md)可以立即用來觀察所有 500 層級的回應，但這些回應處理相當困難，因為它們缺少原始錯誤的相關內容。</span><span class="sxs-lookup"><span data-stu-id="dc372-117">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="dc372-118">訊息處理常式也有一些限制與所能處理的案例相關的例外狀況篩選條件的限制相同。雖然 Web API 有擷取錯誤狀況的追蹤基礎結構追蹤基礎結構供診斷之用，未設計或適用於生產環境中執行。</span><span class="sxs-lookup"><span data-stu-id="dc372-118">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="dc372-119">全域例外狀況處理和記錄應該可以在實際執行期間執行，並插入現有的監視解決方案的服務 (例如[ELMAH](https://code.google.com/p/elmah/) )。</span><span class="sxs-lookup"><span data-stu-id="dc372-119">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="dc372-120">解決方案概觀</span><span class="sxs-lookup"><span data-stu-id="dc372-120">Solution Overview</span></span>

 <span data-ttu-id="dc372-121">我們提供兩個新的使用者可取代服務， [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md)和 IExceptionHandler，記錄並處理未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-121">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="dc372-122">服務有非常類似，但有兩個主要的差異：</span><span class="sxs-lookup"><span data-stu-id="dc372-122">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="dc372-123">我們支援多個例外狀況記錄器，但只有單一例外狀況處理常式註冊。</span><span class="sxs-lookup"><span data-stu-id="dc372-123">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="dc372-124">例外狀況記錄器一律取得呼叫，即使我們即將中止連接。</span><span class="sxs-lookup"><span data-stu-id="dc372-124">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="dc372-125">只有當我們仍然可以選擇要傳送的回應訊息時，取得呼叫例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="dc372-125">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="dc372-126">這兩項服務提供存取權包含來自其中偵測到例外狀況，點的相關資訊的例外狀況內容特別[HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx)，則[HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)，則會擲回例外狀況和例外狀況來源 （下面的詳細資料）。</span><span class="sxs-lookup"><span data-stu-id="dc372-126">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="dc372-127">設計原則</span><span class="sxs-lookup"><span data-stu-id="dc372-127">Design Principles</span></span>

1. <span data-ttu-id="dc372-128">**沒有重大變更**因為次要版本，其中一個影響解決方案的重要限制是，不會有任何重大變更，請輸入合約或行為，要加入這項功能。</span><span class="sxs-lookup"><span data-stu-id="dc372-128">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="dc372-129">這個條件約束會排除某些清除工作，我們想要完成根據現有開啟到 500 個回應的例外狀況的 catch 區塊。</span><span class="sxs-lookup"><span data-stu-id="dc372-129">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="dc372-130">這個額外的清除作業是我們可能要考慮在下一個主要版本。</span><span class="sxs-lookup"><span data-stu-id="dc372-130">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="dc372-131">如果這是一定要您請它在投票[ASP.NET Web API 使用者心聲](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)。</span><span class="sxs-lookup"><span data-stu-id="dc372-131">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="dc372-132">**維護與 Web API 的一致性建構**Web API 的篩選條件管線是適合用來處理跨領域關注套用的邏輯在特定動作、 控制器特定或全域範圍的彈性。</span><span class="sxs-lookup"><span data-stu-id="dc372-132">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="dc372-133">篩選條件，包括例外狀況篩選條件，一律具有動作和控制器內容，即使在已註冊在全域範圍。</span><span class="sxs-lookup"><span data-stu-id="dc372-133">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="dc372-134">合約最適合篩選，但這不表示例外狀況篩選條件，甚至是全域範圍的項目，不適合用於處理其中任何動作或控制器內容的情況下，例如例外狀況訊息處理常式，從某些例外狀況存在。</span><span class="sxs-lookup"><span data-stu-id="dc372-134">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="dc372-135">如果我們想要使用之例外狀況處理的篩選器所提供的彈性範圍，我們仍需要例外狀況篩選條件。</span><span class="sxs-lookup"><span data-stu-id="dc372-135">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="dc372-136">但是，如果我們需要處理例外狀況的控制器內容之外，我們還需要不同的建構 （項目不含的控制器內容和動作內容條件約束） 的完整全域錯誤處理。</span><span class="sxs-lookup"><span data-stu-id="dc372-136">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="dc372-137">使用時機</span><span class="sxs-lookup"><span data-stu-id="dc372-137">When to Use</span></span>

- <span data-ttu-id="dc372-138">例外狀況記錄器是解決方案，可看到 Web API 所攔截到的所有未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-138">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="dc372-139">例外狀況處理常式是自訂 Web API 所攔截到的未處理例外狀況的所有可能回應的解決方案。</span><span class="sxs-lookup"><span data-stu-id="dc372-139">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="dc372-140">例外狀況篩選條件是最簡單的解決方案，來處理相關的特定動作或控制器子集未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-140">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="dc372-141">服務詳細資料</span><span class="sxs-lookup"><span data-stu-id="dc372-141">Service Details</span></span>

 <span data-ttu-id="dc372-142">例外狀況記錄器和處理常式服務介面是簡單的非同步方法採取個別的內容：</span><span class="sxs-lookup"><span data-stu-id="dc372-142">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="dc372-143">我們也會提供針對這兩種介面的基底類別。</span><span class="sxs-lookup"><span data-stu-id="dc372-143">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="dc372-144">覆寫核心 （同步或非同步） 方法是所有所需的記錄，或在建議的處理時間。</span><span class="sxs-lookup"><span data-stu-id="dc372-144">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="dc372-145">如需記錄，`ExceptionLogger`基底類別可確保的核心記錄方法只呼叫一次每個例外狀況 （即使它之後會傳播進一步呼叫堆疊和攔截到一次）。</span><span class="sxs-lookup"><span data-stu-id="dc372-145">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="dc372-146">`ExceptionHandler`基底類別會呼叫處理方法，只針對上方的呼叫堆疊，並忽略舊版巢狀例外狀況 catch 區塊的核心。</span><span class="sxs-lookup"><span data-stu-id="dc372-146">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="dc372-147">（這些基底類別的簡化的版本是下面的 「 附錄 」 中）。兩者`IExceptionLogger`並`IExceptionHandler`接收透過例外狀況的相關資訊`ExceptionContext`。</span><span class="sxs-lookup"><span data-stu-id="dc372-147">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="dc372-148">時，架構會呼叫例外狀況記錄器或例外狀況處理常式，它一律會提供`Exception`和`Request`。</span><span class="sxs-lookup"><span data-stu-id="dc372-148">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="dc372-149">除了單元測試中，它也總是能提供`RequestContext`。</span><span class="sxs-lookup"><span data-stu-id="dc372-149">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="dc372-150">它很少會提供`ControllerContext`和`ActionContext`（僅限時的例外狀況篩選條件，以呼叫 catch 區塊中）。</span><span class="sxs-lookup"><span data-stu-id="dc372-150">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="dc372-151">它很少會提供`Response`（只在 IIS 有時候時中間嘗試寫入回應）。</span><span class="sxs-lookup"><span data-stu-id="dc372-151">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="dc372-152">請注意，因為其中部分屬性可能`null`負責檢查取用者`null`才能存取例外狀況類別的成員。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="dc372-152">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="dc372-153">這字串，表示哪一個 catch 區塊中看到例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-153">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="dc372-154">Catch 區塊字串如下所示：</span><span class="sxs-lookup"><span data-stu-id="dc372-154">The catch block strings are as follows:</span></span>

- <span data-ttu-id="dc372-155">HttpServer （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="dc372-155">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="dc372-156">HttpControllerDispatcher （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="dc372-156">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="dc372-157">HttpBatchHandler （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="dc372-157">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="dc372-158">IExceptionFilter （ApiController 的處理的例外狀況篩選條件管線中 ExecuteAsync）</span><span class="sxs-lookup"><span data-stu-id="dc372-158">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="dc372-159">OWIN 主機：</span><span class="sxs-lookup"><span data-stu-id="dc372-159">OWIN host:</span></span>

    - <span data-ttu-id="dc372-160">HttpMessageHandlerAdapter.BufferResponseContentAsync （適用於緩衝處理輸出）</span><span class="sxs-lookup"><span data-stu-id="dc372-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="dc372-161">HttpMessageHandlerAdapter.CopyResponseContentAsync （適用於資料流輸出）</span><span class="sxs-lookup"><span data-stu-id="dc372-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="dc372-162">Web 主機：</span><span class="sxs-lookup"><span data-stu-id="dc372-162">Web host:</span></span>

    - <span data-ttu-id="dc372-163">HttpControllerHandler.WriteBufferedResponseContentAsync （適用於緩衝處理輸出）</span><span class="sxs-lookup"><span data-stu-id="dc372-163">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="dc372-164">HttpControllerHandler.WriteStreamedResponseContentAsync （適用於資料流輸出）</span><span class="sxs-lookup"><span data-stu-id="dc372-164">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="dc372-165">HttpControllerHandler.WriteErrorResponseContentAsync （適用於在緩衝的輸出模式下的錯誤復原的失敗）</span><span class="sxs-lookup"><span data-stu-id="dc372-165">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="dc372-166">也可透過靜態唯讀屬性的 catch 區塊的字串清單。</span><span class="sxs-lookup"><span data-stu-id="dc372-166">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="dc372-167">（core catch 區塊字串位於靜態 ExceptionCatchBlocks; 其餘部分會出現一個靜態類別上每個 OWIN 和 web 主機）。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="dc372-167">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="dc372-168">可協助您遵循建議的模式處理例外狀況只能在呼叫堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="dc372-168">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="dc372-169">而不是開啟到 500 個回應任何地方的巢狀的 catch 區塊，就會發生的例外狀況，例外狀況處理常式可以讓例外狀況傳播，直到它們即將看到主應用程式。</span><span class="sxs-lookup"><span data-stu-id="dc372-169">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="dc372-170">除了`ExceptionContext`，記錄器會取得一項資訊透過完整`ExceptionLoggerContext`:</span><span class="sxs-lookup"><span data-stu-id="dc372-170">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="dc372-171">第二個屬性， `CanBeHandled`，允許記錄器以識別無法處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-171">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="dc372-172">當即將中止連接和可以傳送任何新的回應訊息中，記錄器就會呼叫但處理常式會***不***呼叫，而且記錄器可以識別這種情況下，從這個屬性。</span><span class="sxs-lookup"><span data-stu-id="dc372-172">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="dc372-173">在進行其他`ExceptionContext`，處理常式會取得一個屬性可以設定完整`ExceptionHandlerContext`處理例外狀況：</span><span class="sxs-lookup"><span data-stu-id="dc372-173">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="dc372-174">例外狀況處理常式會指出它已設定來處理例外狀況`Result`的動作結果的屬性 (例如[ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx)， [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx)， [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)，或自訂的結果)。</span><span class="sxs-lookup"><span data-stu-id="dc372-174">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="dc372-175">如果`Result`屬性為 null、 例外狀況無法處理，因此會重新擲回原始的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-175">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="dc372-176">對於上方的呼叫堆疊的例外狀況，我們會採用額外的步驟，以確保回應是適用於 API 呼叫端。</span><span class="sxs-lookup"><span data-stu-id="dc372-176">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="dc372-177">如果例外狀況會傳播至主應用程式中，呼叫端會看到黃色的死亡畫面，或一些其他的主機提供通常是 HTML 回應和通常不適當的 API 錯誤回應。</span><span class="sxs-lookup"><span data-stu-id="dc372-177">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="dc372-178">在這些情況下，不是 null，而且只有自訂例外狀況處理常式明確設定結果開始回`null`（未處理的） 將例外狀況傳播到主機。</span><span class="sxs-lookup"><span data-stu-id="dc372-178">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="dc372-179">設定`Result`至`null`在此情況下可以是適用於兩個案例：</span><span class="sxs-lookup"><span data-stu-id="dc372-179">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="dc372-180">OWIN 裝載 Web API 與自訂的例外狀況處理登錄之前/外部 Web API 的中介軟體。</span><span class="sxs-lookup"><span data-stu-id="dc372-180">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="dc372-181">本機偵錯透過瀏覽器，其中的黃色死亡畫面是實際上很有幫助回應未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dc372-181">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="dc372-182">如需例外狀況記錄器和例外狀況處理常式中，我們不會有記錄器或處理常式本身會擲回例外狀況時復原。</span><span class="sxs-lookup"><span data-stu-id="dc372-182">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="dc372-183">（以外讓例外狀況傳播，請將保留在此頁面底部提供意見反應，如果您有更好的方法）。例外狀況記錄器和處理常式的合約是它們不應該讓例外狀況傳播到呼叫者;否則，例外狀況會只傳播，通常，一直到主機導致 HTML 錯誤 （例如 ASP。NET 的黃色螢幕） 傳送回用戶端 （這通常不會預期 JSON 或 XML 的 API 呼叫端的慣用的選項）。</span><span class="sxs-lookup"><span data-stu-id="dc372-183">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="dc372-184">範例</span><span class="sxs-lookup"><span data-stu-id="dc372-184">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="dc372-185">追蹤例外狀況記錄器</span><span class="sxs-lookup"><span data-stu-id="dc372-185">Tracing Exception Logger</span></span>

<span data-ttu-id="dc372-186">下面的例外狀況記錄器會將例外狀況資料傳送至已設定的追蹤來源 （包括 Visual Studio 中的偵錯輸出視窗）。</span><span class="sxs-lookup"><span data-stu-id="dc372-186">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="dc372-187">自訂錯誤訊息的例外狀況處理常式</span><span class="sxs-lookup"><span data-stu-id="dc372-187">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="dc372-188">請遵循下列產生自訂錯誤回應給用戶端，包括電子郵件地址連絡支援人員。</span><span class="sxs-lookup"><span data-stu-id="dc372-188">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="dc372-189">註冊的例外狀況篩選條件</span><span class="sxs-lookup"><span data-stu-id="dc372-189">Registering Exception Filters</span></span>

<span data-ttu-id="dc372-190">如果您使用 「 ASP.NET MVC 4 Web 應用程式 」 專案範本來建立專案時，將您的 Web API 組態程式碼內`WebApiConfig`類別，在*應用程式/（_s)* 資料夾：</span><span class="sxs-lookup"><span data-stu-id="dc372-190">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="dc372-191">附錄： 基底類別的詳細資料</span><span class="sxs-lookup"><span data-stu-id="dc372-191">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
