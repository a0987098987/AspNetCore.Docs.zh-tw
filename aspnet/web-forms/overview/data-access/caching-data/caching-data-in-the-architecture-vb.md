---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: "快取的架構 (VB) 中的資料 |Microsoft 文件"
author: rick-anderson
description: "在上一個教學課程中，我們學到如何套用展示層的快取的內容。 本教學課程中我們會了解如何利用我們的分層 architectu..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: 1aca89b022bb3bb7e4154ab575b5bb5513144cd5
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/24/2018
---
<a name="caching-data-in-the-architecture-vb"></a><span data-ttu-id="bcd14-104">快取的架構 (VB) 中的資料</span><span class="sxs-lookup"><span data-stu-id="bcd14-104">Caching Data in the Architecture (VB)</span></span>
====================
<span data-ttu-id="bcd14-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="bcd14-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="bcd14-106">[下載範例應用程式](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe)或[下載 PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="bcd14-106">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) or [Download PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span></span>

> <span data-ttu-id="bcd14-107">在上一個教學課程中，我們學到如何套用展示層的快取的內容。</span><span class="sxs-lookup"><span data-stu-id="bcd14-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="bcd14-108">在本教學課程中，我們了解如何利用我們多層式架構商務邏輯層的快取資料。</span><span class="sxs-lookup"><span data-stu-id="bcd14-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="bcd14-109">執行此作業，延伸架構，用來加入的快取的圖層。</span><span class="sxs-lookup"><span data-stu-id="bcd14-109">We do this by extending the architecture to include a Caching Layer.</span></span>


## <a name="introduction"></a><span data-ttu-id="bcd14-110">簡介</span><span class="sxs-lookup"><span data-stu-id="bcd14-110">Introduction</span></span>

<span data-ttu-id="bcd14-111">如我們所見前述教學課程中，快取 ObjectDataSource 的資料是只要設定幾個屬性。</span><span class="sxs-lookup"><span data-stu-id="bcd14-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="bcd14-112">不幸的是，適用於 ObjectDataSource，展示層緊密結合的 ASP.NET 網頁的快取原則快取。</span><span class="sxs-lookup"><span data-stu-id="bcd14-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="bcd14-113">其中一個原因而建立多層式的架構可讓這類聯繫損毀。</span><span class="sxs-lookup"><span data-stu-id="bcd14-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="bcd14-114">資料存取層，以減少資料的存取詳細資料時，商務邏輯層比方說，以減少從 ASP.NET 頁面的商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="bcd14-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="bcd14-115">此種減少方式的商務邏輯和資料存取的詳細資料的慣用的部分，因為它會讓系統更容易閱讀，更易於維護，而且更有彈性來變更。</span><span class="sxs-lookup"><span data-stu-id="bcd14-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="bcd14-116">它也可讓定義域知識和人力資源展示層不 t 上工作的開發人員必須熟悉資料庫 s 詳細資料，才能執行其工作所需要的。</span><span class="sxs-lookup"><span data-stu-id="bcd14-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="bcd14-117">從展示層的快取原則的去耦合提供相似的效益。</span><span class="sxs-lookup"><span data-stu-id="bcd14-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="bcd14-118">本教學課程中我們將會增加我們架構，用來包含*快取層*（或簡稱 CL），使其利用我們的快取原則。</span><span class="sxs-lookup"><span data-stu-id="bcd14-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="bcd14-119">快取的圖層會包含`ProductsCL`提供類似的方法中的產品資訊的存取權的類別`GetProducts()`， `GetProductsByCategoryID(categoryID)`，依此類推，叫用時，會從快取中擷取資料的第一次嘗試。</span><span class="sxs-lookup"><span data-stu-id="bcd14-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="bcd14-120">如果快取是空的這些方法會叫用適當`ProductsBLL`BLL，接著會從 DAL 取得資料中的方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="bcd14-121">`ProductsCL`方法快取擷取從 BLL 再加以傳回的資料。</span><span class="sxs-lookup"><span data-stu-id="bcd14-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="bcd14-122">如圖 1 所示，CL 會位於簡報和商務邏輯層之間。</span><span class="sxs-lookup"><span data-stu-id="bcd14-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>


![快取層 (CL) 是另一個圖層，在我們的架構](caching-data-in-the-architecture-vb/_static/image1.png)

<span data-ttu-id="bcd14-124">**圖 1**: 快取層 (CL) 是另一個圖層，在我們的架構</span><span class="sxs-lookup"><span data-stu-id="bcd14-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>


## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="bcd14-125">步驟 1： 建立快取層的類別</span><span class="sxs-lookup"><span data-stu-id="bcd14-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="bcd14-126">本教學課程中我們將使用單一類別建立非常簡單 CL`ProductsCL`具有少數幾個方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="bcd14-127">建置完成的快取層針對整個應用程式會需要建立`CategoriesCL`， `EmployeesCL`，和`SuppliersCL`類別，以及提供方法，這些快取層類別中的 BLL 中每個資料存取或修改方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="bcd14-128">如同 BLL 和 DAL，快取的圖層應該在理想情況下實作為個別的類別庫專案。不過，我們會做為類別中實作它`App_Code`資料夾。</span><span class="sxs-lookup"><span data-stu-id="bcd14-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="bcd14-129">自 DAL 和 BLL 類別的多個完全不同 CL 類別，讓 s 建立新的子資料夾中`App_Code`資料夾。</span><span class="sxs-lookup"><span data-stu-id="bcd14-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="bcd14-130">以滑鼠右鍵按一下`App_Code`資料夾在 [方案總管] 中，選擇新的資料夾，並將新的資料夾命名`CL`。</span><span class="sxs-lookup"><span data-stu-id="bcd14-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="bcd14-131">建立這個資料夾之後, 加入新的類別，名為`ProductsCL.vb`。</span><span class="sxs-lookup"><span data-stu-id="bcd14-131">After creating this folder, add to it a new class named `ProductsCL.vb`.</span></span>


![加入新的資料夾，名為 CL 和名為 ProductsCL.vb 類別](caching-data-in-the-architecture-vb/_static/image2.png)

<span data-ttu-id="bcd14-133">**圖 2**： 加入新的資料夾，名為`CL`和類別，名為`ProductsCL.vb`</span><span class="sxs-lookup"><span data-stu-id="bcd14-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.vb`</span></span>


<span data-ttu-id="bcd14-134">`ProductsCL`類別應包含相同的資料存取和修改方法，在其對應的商務邏輯層類別集 (`ProductsBLL`)。</span><span class="sxs-lookup"><span data-stu-id="bcd14-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="bcd14-135">而不是建立所有這些方法，可讓的 s 建構 CL 幾個這裡的操作有初步的模式使用。</span><span class="sxs-lookup"><span data-stu-id="bcd14-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="bcd14-136">特別是，我們會將新增`GetProducts()`和`GetProductsByCategoryID(categoryID)`步驟 3 中的方法和`UpdateProduct`步驟 4 中的多載。</span><span class="sxs-lookup"><span data-stu-id="bcd14-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="bcd14-137">您可以加入其餘`ProductsCL`方法和`CategoriesCL`， `EmployeesCL`，和`SuppliersCL`在閒暇類別。</span><span class="sxs-lookup"><span data-stu-id="bcd14-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="bcd14-138">步驟 2： 讀取和寫入資料快取</span><span class="sxs-lookup"><span data-stu-id="bcd14-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="bcd14-139">ObjectDataSource 快取內部瀏覽先前的教學課程中的功能會使用 ASP.NET 資料快取來儲存從 BLL 擷取的資料。</span><span class="sxs-lookup"><span data-stu-id="bcd14-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="bcd14-140">資料快取也可以存取以程式設計方式從 ASP.NET 網頁程式碼後置類別或 web 應用程式的架構中的類別。</span><span class="sxs-lookup"><span data-stu-id="bcd14-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="bcd14-141">若要讀取和寫入資料的快取，從 ASP.NET 頁面 s 程式碼後置類別，請使用下列模式：</span><span class="sxs-lookup"><span data-stu-id="bcd14-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

<span data-ttu-id="bcd14-142">[ `Cache`類別](https://msdn.microsoft.com/library/system.web.caching.cache.aspx)s [ `Insert`方法](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx)的數目多載。</span><span class="sxs-lookup"><span data-stu-id="bcd14-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="bcd14-143">`Cache("key") = value`和`Cache.Insert(key, value)`同義，同時將項目至快取使用未定義的到期的指定的金鑰。</span><span class="sxs-lookup"><span data-stu-id="bcd14-143">`Cache("key") = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="bcd14-144">一般而言，我們想要指定到期時將項目加入快取中，當做相依性、 以時間為基礎的到期，或兩者。</span><span class="sxs-lookup"><span data-stu-id="bcd14-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="bcd14-145">使用其中一個其他`Insert`的方法多載，以提供相依性或時間為基礎的過期資訊。</span><span class="sxs-lookup"><span data-stu-id="bcd14-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="bcd14-146">快取層需要先檢查 如果要求的資料會快取中，若是如此，s 方法會傳回它從該處。</span><span class="sxs-lookup"><span data-stu-id="bcd14-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="bcd14-147">如果要求的資料不是快取中，適當的 BLL 方法需要叫用。</span><span class="sxs-lookup"><span data-stu-id="bcd14-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="bcd14-148">其傳回的值應該快取，並將傳回，如下列順序圖表所示。</span><span class="sxs-lookup"><span data-stu-id="bcd14-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>


![快取層的方法會傳回從快取資料如果它 s 可用](caching-data-in-the-architecture-vb/_static/image3.png)

<span data-ttu-id="bcd14-150">**圖 3**: 快取層的方法會傳回從快取資料如果它 s 可用</span><span class="sxs-lookup"><span data-stu-id="bcd14-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>


<span data-ttu-id="bcd14-151">圖 3 所示的順序是在 CL 類別中使用以下模式來完成：</span><span class="sxs-lookup"><span data-stu-id="bcd14-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

<span data-ttu-id="bcd14-152">在這裡，*類型*是快取中所儲存的資料型別`Northwind.ProductsDataTable`，例如時*金鑰*是索引鍵可唯一識別快取項目。</span><span class="sxs-lookup"><span data-stu-id="bcd14-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="bcd14-153">如果具有指定的項目*金鑰*不在快取，然後*執行個體*將`Nothing`會適當 BLL 方法所擷取的資料，並且新增至快取。</span><span class="sxs-lookup"><span data-stu-id="bcd14-153">If the item with the specified *key* is not in the cache, then *instance* will be `Nothing` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="bcd14-154">依時間`Return instance`為止*執行個體*包含資料，從快取的參考，或從 BLL 提取。</span><span class="sxs-lookup"><span data-stu-id="bcd14-154">By the time `Return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="bcd14-155">請務必從快取中存取資料時，使用上述的模式。</span><span class="sxs-lookup"><span data-stu-id="bcd14-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="bcd14-156">下列的模式，其中第一眼看起來，看起來相同，包含種微妙的差異，將會介紹競爭情形。</span><span class="sxs-lookup"><span data-stu-id="bcd14-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="bcd14-157">競爭情形很難進行偵錯，因為它們偶發性顯示本身，而且難以重現。</span><span class="sxs-lookup"><span data-stu-id="bcd14-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

<span data-ttu-id="bcd14-158">一秒的差異，不正確的程式碼片段，而不將快取項目的參考儲存在本機變數，資料存取快取是直接在條件陳述式中*和*中`Return`。</span><span class="sxs-lookup"><span data-stu-id="bcd14-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `Return`.</span></span> <span data-ttu-id="bcd14-159">當到達這個程式碼時，假設，`Cache("key")`不`Nothing`前,`Return`到達陳述式時，系統會收回*金鑰*從快取。</span><span class="sxs-lookup"><span data-stu-id="bcd14-159">Imagine that when this code is reached, `Cache("key")` is not `Nothing`, but before the `Return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="bcd14-160">在此罕見的情況下，程式碼將傳回`Nothing`而不是預期類型的物件。</span><span class="sxs-lookup"><span data-stu-id="bcd14-160">In this rare case, the code will return `Nothing` rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="bcd14-161">資料快取是安全執行緒，因此您不需要進行簡單的讀取或寫入同步處理的執行緒存取。</span><span class="sxs-lookup"><span data-stu-id="bcd14-161">The data cache is thread-safe, so you don't need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="bcd14-162">不過，如果您需要執行多個作業資料必須是不可部分完成的快取中，您必須負責實作鎖定或其他一些機制來確保執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="bcd14-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="bcd14-163">請參閱[ASP.NET 快取的同步處理存取](http://www.ddj.com/184406369)如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="bcd14-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>


<span data-ttu-id="bcd14-164">項目可以透過程式設計方式從資料快取使用收回[`Remove`方法](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx)就像這樣：</span><span class="sxs-lookup"><span data-stu-id="bcd14-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="bcd14-165">步驟 3： 傳回產品資訊`ProductsCL`類別</span><span class="sxs-lookup"><span data-stu-id="bcd14-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="bcd14-166">針對本教學課程將實作兩個方法來傳回產品資訊的 s`ProductsCL`類別：`GetProducts()`和`GetProductsByCategoryID(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="bcd14-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="bcd14-167">像使用`ProductsBL`商務邏輯層中的類別`GetProducts()`CL 中的方法會傳回所有產品做為資訊`Northwind.ProductsDataTable`物件，而`GetProductsByCategoryID(categoryID)`從指定的類別目錄都傳回所有產品。</span><span class="sxs-lookup"><span data-stu-id="bcd14-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="bcd14-168">下列程式碼顯示的方法中的某一部分`ProductsCL`類別：</span><span class="sxs-lookup"><span data-stu-id="bcd14-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

<span data-ttu-id="bcd14-169">首先，請記下`DataObject`和`DataObjectMethodAttribute`屬性套用至類別和方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="bcd14-170">這些屬性會提供資訊給 ObjectDataSource 的精靈中，表示哪些類別和方法應該會出現在精靈中的 s 步驟。</span><span class="sxs-lookup"><span data-stu-id="bcd14-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="bcd14-171">由於會從 ObjectDataSource 展示層中存取的 CL 類別和方法，我會加入這些屬性，以增強的設計階段經驗。</span><span class="sxs-lookup"><span data-stu-id="bcd14-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="bcd14-172">若要回頭參考[建立商務邏輯層](../introduction/creating-a-business-logic-layer-vb.md)如需更完整的說明，這些屬性和其效果教學課程。</span><span class="sxs-lookup"><span data-stu-id="bcd14-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-vb.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="bcd14-173">在`GetProducts()`和`GetProductsByCategoryID(categoryID)`方法、 從傳回的資料`GetCacheItem(key)`方法指派給本機變數。</span><span class="sxs-lookup"><span data-stu-id="bcd14-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="bcd14-174">`GetCacheItem(key)`方法，我們將檢驗，傳回特定的項目從快取，根據指定*金鑰*。</span><span class="sxs-lookup"><span data-stu-id="bcd14-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="bcd14-175">如果沒有這類資料快取中找到，它會從對應`ProductsBLL`類別方法，並加入快取使用`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="bcd14-176">`GetCacheItem(key)`和`AddCacheItem(key, value)`方法分別介面與資料快取、 讀取和寫入值。</span><span class="sxs-lookup"><span data-stu-id="bcd14-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="bcd14-177">`GetCacheItem(key)`方法較簡單的兩個。</span><span class="sxs-lookup"><span data-stu-id="bcd14-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="bcd14-178">它只會從快取類別使用傳入的傳回值*金鑰*:</span><span class="sxs-lookup"><span data-stu-id="bcd14-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

<span data-ttu-id="bcd14-179">`GetCacheItem(key)`不會使用*金鑰*值加以提供，而是呼叫`GetCacheKey(key)`方法，這個方法會傳回*金鑰*ProductsCache-前面加上。</span><span class="sxs-lookup"><span data-stu-id="bcd14-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="bcd14-180">`MasterCacheKeyArray`，其中保留字串 ProductsCache，也會使用`AddCacheItem(key, value)`方法中，我們將會立即看到。</span><span class="sxs-lookup"><span data-stu-id="bcd14-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="bcd14-181">從 ASP.NET 頁面 s 程式碼後置類別，讓資料快取可使用存取`Page`類別 s [ `Cache`屬性](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)，並允許類似下面的語法`Cache("key") = value`，如步驟 2 所述。</span><span class="sxs-lookup"><span data-stu-id="bcd14-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache("key") = value`, as discussed in Step 2.</span></span> <span data-ttu-id="bcd14-182">架構中的類別，從資料快取可使用`HttpRuntime.Cache`或`HttpContext.Current.Cache`。</span><span class="sxs-lookup"><span data-stu-id="bcd14-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="bcd14-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)的部落格項目[HttpRuntime.Cache vs。HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache)資訊使用的輕微的效能優點`HttpRuntime`而不是`HttpContext.Current`; 因此，`ProductsCL`使用`HttpRuntime`。</span><span class="sxs-lookup"><span data-stu-id="bcd14-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="bcd14-184">如果您的架構使用實作的類別庫專案，則您必須將參考加入`System.Web`組件，才能使用[ `HttpRuntime` ](https://msdn.microsoft.com/library/system.web.httpruntime.aspx)和[ `HttpContext` ](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)類別。</span><span class="sxs-lookup"><span data-stu-id="bcd14-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>


<span data-ttu-id="bcd14-185">如果快取中，找不到項目`ProductsCL`類別的方法 BLL 從取得資料，並將它加入至快取使用`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="bcd14-186">若要加入*值*至快取中，我們可以使用下列程式碼會使用 60 秒鐘的時間到期：</span><span class="sxs-lookup"><span data-stu-id="bcd14-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

<span data-ttu-id="bcd14-187">`DateTime.Now.AddSeconds(CacheDuration)`指定以時間為基礎的到期日期 60 秒的未來 while [ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx)指出那里 s 沒有滑動期限。</span><span class="sxs-lookup"><span data-stu-id="bcd14-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="bcd14-188">雖然這`Insert`方法多載具有輸入參數的兩個絕對和滑動過期，您可以只提供兩個的其中一個。</span><span class="sxs-lookup"><span data-stu-id="bcd14-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="bcd14-189">如果您嘗試將指定的絕對時間和時間範圍內，`Insert`方法會擲回`ArgumentException`例外狀況。</span><span class="sxs-lookup"><span data-stu-id="bcd14-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="bcd14-190">這項實作`AddCacheItem(key, value)`方法目前有一些缺點。</span><span class="sxs-lookup"><span data-stu-id="bcd14-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="bcd14-191">我們將地址，並克服這些問題，在步驟 4。</span><span class="sxs-lookup"><span data-stu-id="bcd14-191">We'll address and overcome these issues in Step 4.</span></span>


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="bcd14-192">步驟 4： 失效快取時資料是透過架構，修改</span><span class="sxs-lookup"><span data-stu-id="bcd14-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="bcd14-193">資料擷取方法，以及快取的圖層必須提供相同的方法，BLL 插入、 更新和刪除資料。</span><span class="sxs-lookup"><span data-stu-id="bcd14-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="bcd14-194">CL 的資料修改方法不會修改快取的資料，但而不是呼叫 BLL s 對應資料修改方法，然後確認 快取。</span><span class="sxs-lookup"><span data-stu-id="bcd14-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="bcd14-195">因為我們在先前的教學課程中所見，這是相同 ObjectDataSource 適用於其快取的功能啟用時的行為及其`Insert`， `Update`，或`Delete`叫用方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="bcd14-196">下列`UpdateProduct`多載說明如何實作 CL 中的資料修改方法：</span><span class="sxs-lookup"><span data-stu-id="bcd14-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

<span data-ttu-id="bcd14-197">適當的資料修改商務邏輯層方法會叫用，但會傳回其回應，我們需要先確認快取。</span><span class="sxs-lookup"><span data-stu-id="bcd14-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="bcd14-198">不幸的是，快取無效，所以無法直接`ProductsCL`類別 s`GetProducts()`和`GetProductsByCategoryID(categoryID)`方法每個項目加入快取具有不同索引鍵，而`GetProductsByCategoryID(categoryID)`方法會將不同的快取項目加入每個唯一*categoryID*。</span><span class="sxs-lookup"><span data-stu-id="bcd14-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="bcd14-199">當快取無效，我們需要移除*所有*可能藉由加入的項目`ProductsCL`類別。</span><span class="sxs-lookup"><span data-stu-id="bcd14-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="bcd14-200">這可藉由建立關聯*快取相依性*加入至快取中的每個項目與`AddCacheItem(key, value)`方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="bcd14-201">一般情況下，快取相依性可以是另一個項目在快取中，檔案系統或從 Microsoft SQL Server 資料庫的資料上的檔案。</span><span class="sxs-lookup"><span data-stu-id="bcd14-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="bcd14-202">當相依性變更或移除從快取，其相關聯的快取項目會自動從快取收回。</span><span class="sxs-lookup"><span data-stu-id="bcd14-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="bcd14-203">此教學課程中，我們想要建立額外的項目會作為透過新增快取相依性的所有項目在快取中`ProductsCL`類別。</span><span class="sxs-lookup"><span data-stu-id="bcd14-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="bcd14-204">這樣一來，所有這些項目可以會從快取只要移除快取相依性。</span><span class="sxs-lookup"><span data-stu-id="bcd14-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="bcd14-205">可讓的 s 更新`AddCacheItem(key, value)`方法，透過這個方法新增至快取的每個項目都與單一快取相依性：</span><span class="sxs-lookup"><span data-stu-id="bcd14-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

<span data-ttu-id="bcd14-206">`MasterCacheKeyArray`是保存的 ProductsCache 的值的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="bcd14-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="bcd14-207">首先，快取項目加入至快取，並指派給目前的日期和時間。</span><span class="sxs-lookup"><span data-stu-id="bcd14-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="bcd14-208">如果快取項目已經存在，它會更新。</span><span class="sxs-lookup"><span data-stu-id="bcd14-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="bcd14-209">接下來，會建立快取相依性。</span><span class="sxs-lookup"><span data-stu-id="bcd14-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="bcd14-210">[ `CacheDependency`類別](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx)s 建構函式有多種多載，但在這裡使用的一個必須要有兩個`String`陣列的輸入。</span><span class="sxs-lookup"><span data-stu-id="bcd14-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `String` array inputs.</span></span> <span data-ttu-id="bcd14-211">第一個指定檔案，可做為相依性的集合。</span><span class="sxs-lookup"><span data-stu-id="bcd14-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="bcd14-212">因為我們不想使用以檔案為基礎的相依性，值為`Nothing`用於第一個輸入參數。</span><span class="sxs-lookup"><span data-stu-id="bcd14-212">Since we don t want to use any file-based dependencies, a value of `Nothing` is used for the first input parameter.</span></span> <span data-ttu-id="bcd14-213">第二個輸入的參數會指定要做為相依性的快取索引鍵集。</span><span class="sxs-lookup"><span data-stu-id="bcd14-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="bcd14-214">我們在這裡指定我們的單一相依性， `MasterCacheKeyArray`。</span><span class="sxs-lookup"><span data-stu-id="bcd14-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="bcd14-215">`CacheDependency`然後傳入`Insert`方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="bcd14-216">若要進行此項修改`AddCacheItem(key, value)`invaliding、 快取很簡單，只移除相依性。</span><span class="sxs-lookup"><span data-stu-id="bcd14-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="bcd14-217">步驟 5： 從展示層中呼叫的快取的圖層</span><span class="sxs-lookup"><span data-stu-id="bcd14-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="bcd14-218">使用資料使用的技術，我們 ve 檢查這些教學課程整個可用的快取層的類別和方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="bcd14-219">為了說明使用快取資料，您將變更儲存到`ProductsCL`類別，然後開啟`FromTheArchitecture.aspx`頁面`Caching`資料夾並加入 GridView。</span><span class="sxs-lookup"><span data-stu-id="bcd14-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="bcd14-220">從 GridView s 智慧標籤，建立新的 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="bcd14-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="bcd14-221">在精靈的 s 第一個步驟應該會看到`ProductsCL`類別做為其中一個選項，從下拉式清單。</span><span class="sxs-lookup"><span data-stu-id="bcd14-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>


<span data-ttu-id="bcd14-222">[![在 [商務物件] 下拉式清單中包含 ProductsCL 類別](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="bcd14-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span></span>

<span data-ttu-id="bcd14-223">**圖 4**:`ProductsCL`商務物件 下拉式清單中包含類別 ([按一下以檢視完整大小的影像](caching-data-in-the-architecture-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="bcd14-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image6.png))</span></span>


<span data-ttu-id="bcd14-224">選取之後`ProductsCL`，按一下 [下一步]。</span><span class="sxs-lookup"><span data-stu-id="bcd14-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="bcd14-225">下拉式清單選取索引標籤中的有兩個項目-`GetProducts()`和`GetProductsByCategoryID(categoryID)`和 [更新] 索引標籤具有唯一`UpdateProduct`多載。</span><span class="sxs-lookup"><span data-stu-id="bcd14-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="bcd14-226">選擇`GetProducts()`方法，從 [選取] 索引標籤和`UpdateProducts`方法，從 [更新] 索引標籤，然後按一下 [完成]。</span><span class="sxs-lookup"><span data-stu-id="bcd14-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>


<span data-ttu-id="bcd14-227">[![下拉式清單中列出這些 ProductsCL 類別的方法](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="bcd14-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span></span>

<span data-ttu-id="bcd14-228">**圖 5**:`ProductsCL`下拉式清單中會列出類別的方法 ([按一下以檢視完整大小的影像](caching-data-in-the-architecture-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="bcd14-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image9.png))</span></span>


<span data-ttu-id="bcd14-229">完成精靈之後，Visual Studio 會將 ObjectDataSource s`OldValuesParameterFormatString`屬性`original_{0}`並將適當的欄位加入至 GridView。</span><span class="sxs-lookup"><span data-stu-id="bcd14-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="bcd14-230">變更`OldValuesParameterFormatString`回其預設值的屬性`{0}`，並設定以支援分頁、 排序和編輯 GridView。</span><span class="sxs-lookup"><span data-stu-id="bcd14-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="bcd14-231">因為`UploadProducts`CL 所使用的多載會接受只編輯的產品的名稱和價格，限制 GridView，因此只有這些欄位是可編輯。</span><span class="sxs-lookup"><span data-stu-id="bcd14-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="bcd14-232">在前述教學課程中，我們定義包含欄位的 GridView `ProductName`， `CategoryName`，和`UnitPrice`欄位。</span><span class="sxs-lookup"><span data-stu-id="bcd14-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="bcd14-233">歡迎複寫此格式和結構，在此情況下您 GridView 和 ObjectDataSource 的 s 宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="bcd14-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

<span data-ttu-id="bcd14-234">現在我們有會使用快取層的頁面。</span><span class="sxs-lookup"><span data-stu-id="bcd14-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="bcd14-235">若要查看作用中的快取，在中設定中斷點`ProductsCL`類別 s`GetProducts()`和`UpdateProduct`方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="bcd14-236">排序和分頁才能看到資料提取從快取，請造訪網頁瀏覽器，並逐步執行程式碼中。</span><span class="sxs-lookup"><span data-stu-id="bcd14-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="bcd14-237">然後更新的記錄，並請注意，快取失效，因此，它會從 BLL 當資料已不再重新繫結至 GridView。</span><span class="sxs-lookup"><span data-stu-id="bcd14-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="bcd14-238">本文所附的下載中提供的快取層會完成。</span><span class="sxs-lookup"><span data-stu-id="bcd14-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="bcd14-239">它包含一個類別， `ProductsCL`，其中只有運動少數幾個方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="bcd14-240">此外，在單一 ASP.NET 頁面使用 CL (`~/Caching/FromTheArchitecture.aspx`) 其他所有項目仍 BLL 直接參考。</span><span class="sxs-lookup"><span data-stu-id="bcd14-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="bcd14-241">如果您計劃應用程式中使用 CL，展示層的所有呼叫應該都移至 CL，即需要，CL 的類別，並方法涵蓋這些類別和 BLL 展示層目前使用中的方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>


## <a name="summary"></a><span data-ttu-id="bcd14-242">總結</span><span class="sxs-lookup"><span data-stu-id="bcd14-242">Summary</span></span>

<span data-ttu-id="bcd14-243">雖然快取可以套用在與 ASP.NET 2.0 的 SqlDataSource 展示層和 ObjectDataSource 控制項，在理想情況下快取責任會委派至個別圖層的架構中。</span><span class="sxs-lookup"><span data-stu-id="bcd14-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="bcd14-244">在本教學課程中，我們建立快取的圖層位於展示層與商務邏輯層之間。</span><span class="sxs-lookup"><span data-stu-id="bcd14-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="bcd14-245">快取的圖層必須提供相同一組類別和 BLL 存在於和展示層從呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="bcd14-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="bcd14-246">我們在此範例與上述的教學課程已探索的快取層範例展現*反應式載入*。</span><span class="sxs-lookup"><span data-stu-id="bcd14-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="bcd14-247">以反應靈敏的載入資料至快取時才會載入提出資料要求，並從快取該資料會遺失。</span><span class="sxs-lookup"><span data-stu-id="bcd14-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="bcd14-248">資料也可以是*主動載入*至快取中，一種技術，將資料載入快取之前有實際需要的。</span><span class="sxs-lookup"><span data-stu-id="bcd14-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="bcd14-249">在下一個教學課程中我們會看到主動式載入時，我們會審視如何儲存到應用程式啟動時快取的靜態值的範例。</span><span class="sxs-lookup"><span data-stu-id="bcd14-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="bcd14-250">祝您程式設計 ！</span><span class="sxs-lookup"><span data-stu-id="bcd14-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="bcd14-251">關於作者</span><span class="sxs-lookup"><span data-stu-id="bcd14-251">About the Author</span></span>

<span data-ttu-id="bcd14-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七個 ASP/ASP.NET 書籍和的創辦[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已從 1998 年使用 Microsoft Web 技術。</span><span class="sxs-lookup"><span data-stu-id="bcd14-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="bcd14-253">Scott 可做為獨立顧問、 訓練和寫入器。</span><span class="sxs-lookup"><span data-stu-id="bcd14-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="bcd14-254">他最新的活頁簿[ *Sam 教導您自己 ASP.NET 2.0 24 小時內*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="bcd14-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="bcd14-255">他可以在達到[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或透過他的部落格，這可以在找到[http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="bcd14-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="bcd14-256">特別感謝</span><span class="sxs-lookup"><span data-stu-id="bcd14-256">Special Thanks To</span></span>

<span data-ttu-id="bcd14-257">許多有用的檢閱者已檢閱本教學課程系列。</span><span class="sxs-lookup"><span data-stu-id="bcd14-257">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="bcd14-258">在此教學課程的前導檢閱者已本文菲。</span><span class="sxs-lookup"><span data-stu-id="bcd14-258">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="bcd14-259">檢閱我即將推出的 MSDN 文件有興趣嗎？</span><span class="sxs-lookup"><span data-stu-id="bcd14-259">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="bcd14-260">如果是這樣，卸除我一行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="bcd14-260">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="bcd14-261">[上一頁](caching-data-with-the-objectdatasource-vb.md)
[下一頁](caching-data-at-application-startup-vb.md)</span><span class="sxs-lookup"><span data-stu-id="bcd14-261">[Previous](caching-data-with-the-objectdatasource-vb.md)
[Next](caching-data-at-application-startup-vb.md)</span></span>
