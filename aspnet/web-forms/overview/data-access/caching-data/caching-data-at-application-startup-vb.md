---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
title: 快取資料在應用程式啟動 (VB) |Microsoft 文件
author: rick-anderson
description: 在任何 Web 應用程式資料會經常使用，將不常使用某些資料。 我們可以改進我們的 ASP.NET 應用程式 b 效能...
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 84afe4ac-cc53-4f2e-a867-27eaf692c2df
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
msc.type: authoredcontent
ms.openlocfilehash: f8f322dae89480fc7ed5586d7f8eeb4c67d7839f
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2018
---
<a name="caching-data-at-application-startup-vb"></a><span data-ttu-id="96e5f-104">快取資料在應用程式啟動 (VB)</span><span class="sxs-lookup"><span data-stu-id="96e5f-104">Caching Data at Application Startup (VB)</span></span>
====================
<span data-ttu-id="96e5f-105">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="96e5f-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="96e5f-106">下載 PDF</span><span class="sxs-lookup"><span data-stu-id="96e5f-106">Download PDF</span></span>](caching-data-at-application-startup-vb/_static/datatutorial60vb1.pdf)

> <span data-ttu-id="96e5f-107">在任何 Web 應用程式資料會經常使用，將不常使用某些資料。</span><span class="sxs-lookup"><span data-stu-id="96e5f-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="96e5f-108">預先載入常用的資料，ant colony optimization，我們可以改進我們的 ASP.NET 應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="96e5f-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as.</span></span> <span data-ttu-id="96e5f-109">本教學課程示範主動式載入，也就是將資料載入至快取應用程式啟動時的其中一個方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>


## <a name="introduction"></a><span data-ttu-id="96e5f-110">簡介</span><span class="sxs-lookup"><span data-stu-id="96e5f-110">Introduction</span></span>

<span data-ttu-id="96e5f-111">在快取中的簡報和快取層級中的資料，查看兩個先前的教學課程。</span><span class="sxs-lookup"><span data-stu-id="96e5f-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="96e5f-112">在[快取資料與 ObjectDataSource](caching-data-with-the-objectdatasource-vb.md)，我們探討了使用 ObjectDataSource s 中的快取來展示層中的快取資料的功能。</span><span class="sxs-lookup"><span data-stu-id="96e5f-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-vb.md), we looked at using the ObjectDataSource s caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="96e5f-113">[快取資料的架構中](caching-data-in-the-architecture-vb.md)檢查新的、 不同的快取層中的快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-113">[Caching Data in the Architecture](caching-data-in-the-architecture-vb.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="96e5f-114">這兩個使用這些教學課程*反應式載入*中使用的資料快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="96e5f-115">使用反應靈敏的載入，每次要求資料時，系統會先檢查如果它快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-115">With reactive loading, each time the data is requested, the system first checks if it s in the cache.</span></span> <span data-ttu-id="96e5f-116">如果沒有，它 grabs 示範的資料從原始來源，例如資料庫，並將其儲存在快取中。</span><span class="sxs-lookup"><span data-stu-id="96e5f-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="96e5f-117">反應式載入的主要優點是容易實作。</span><span class="sxs-lookup"><span data-stu-id="96e5f-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="96e5f-118">其缺點是不平均的效能要求。</span><span class="sxs-lookup"><span data-stu-id="96e5f-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="96e5f-119">假設使用快取層前述教學課程來顯示產品資訊的頁面。</span><span class="sxs-lookup"><span data-stu-id="96e5f-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="96e5f-120">當此頁面瀏覽的第一次，或瀏覽的第一次之後已收回快取的資料，因為記憶體條件約束或具有已達到指定的到期日期時，則必須從資料庫擷取的資料。</span><span class="sxs-lookup"><span data-stu-id="96e5f-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="96e5f-121">因此，這些使用者要求將會比長可提供的使用者要求快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="96e5f-122">*主動式載入*提供替代的快取管理策略效能該會平滑化跨要求藉由載入之前快取的資料所需。</span><span class="sxs-lookup"><span data-stu-id="96e5f-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it s needed.</span></span> <span data-ttu-id="96e5f-123">一般而言，主動載入會使用某些處理程序來定期檢查，或已對基礎資料更新時，會收到通知。</span><span class="sxs-lookup"><span data-stu-id="96e5f-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="96e5f-124">此程序，然後更新要保持最新的快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="96e5f-125">主動載入為基礎的資料來自緩慢的資料庫連接、 Web 服務或其他特別緩慢的資料來源的特別有用。</span><span class="sxs-lookup"><span data-stu-id="96e5f-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="96e5f-126">但這種方法來主動載入比較難實作，因為它需要建立、 管理和部署處理程序，檢查有變更，並更新快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="96e5f-127">主動式載入，以及我們將在本教學課程中，瀏覽的類型的另一個類別會將資料載入應用程式啟動時快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="96e5f-128">這個方法是特別適用於快取靜態資料，例如資料庫查閱資料表中的記錄。</span><span class="sxs-lookup"><span data-stu-id="96e5f-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="96e5f-129">主動式與反應式載入以及專業人員及缺點，實作建議的清單之間的差異更深入探討，請參閱[管理的快取的內容](https://msdn.microsoft.com/library/ms978503.aspx)區段[快取 .NET Framework 應用程式的架構指南](https://msdn.microsoft.com/library/ms978498.aspx)。</span><span class="sxs-lookup"><span data-stu-id="96e5f-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>


## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="96e5f-130">步驟 1： 決定要在應用程式啟動時的快取的資料</span><span class="sxs-lookup"><span data-stu-id="96e5f-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="96e5f-131">我們檢查用於產生，可能會定期變更，且未採用 exorbitantly 長資料的先前兩個教學課程工作中使用反應靈敏載入快取的範例。</span><span class="sxs-lookup"><span data-stu-id="96e5f-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="96e5f-132">但如果快取的資料永遠不會變更，使用反應靈敏的載入到期多餘。</span><span class="sxs-lookup"><span data-stu-id="96e5f-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="96e5f-133">同樣地，如果所快取的資料需要非常長的時間，來產生，然後這些使用者的要求可讓您尋找快取空白必須 endure 基礎資料執行時間較長的等候擷取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="96e5f-134">請考慮快取靜態資料和資料，要花更長的時間來產生應用程式啟動時。</span><span class="sxs-lookup"><span data-stu-id="96e5f-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="96e5f-135">雖然資料庫都有許多動態，經常變更的值，大部分也會有大量的靜態資料。</span><span class="sxs-lookup"><span data-stu-id="96e5f-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="96e5f-136">比方說，幾乎所有的資料模型有一個或多個資料行包含特定值從一組固定的選項。</span><span class="sxs-lookup"><span data-stu-id="96e5f-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="96e5f-137">A`Patients`資料庫資料表可能會有`PrimaryLanguage`資料行集的值可能是英文、 西班牙文、 法文、 俄文、 日文、 等等。</span><span class="sxs-lookup"><span data-stu-id="96e5f-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="96e5f-138">有時候，實作這些類型的資料行是使用*查閱資料表*。</span><span class="sxs-lookup"><span data-stu-id="96e5f-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="96e5f-139">而不是英文或法文中的將字串儲存`Patients`，第二個資料表建立資料表的情況下，有兩個資料行的唯一識別碼和字串描述為每個可能值的記錄。</span><span class="sxs-lookup"><span data-stu-id="96e5f-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="96e5f-140">`PrimaryLanguage`中的資料行`Patients`資料表查閱資料表中儲存對應的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="96e5f-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="96e5f-141">圖 1 病患 John Doe s 主要語言是英文，俄羅斯 Ed Johnson s 時。</span><span class="sxs-lookup"><span data-stu-id="96e5f-141">In Figure 1, patient John Doe s primary language is English, while Ed Johnson s is Russian.</span></span>


![語言資料表是病患資料表查閱資料表使用](caching-data-at-application-startup-vb/_static/image1.png)

<span data-ttu-id="96e5f-143">**圖 1**:`Languages`資料表是查閱資料表由`Patients`資料表</span><span class="sxs-lookup"><span data-stu-id="96e5f-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>


<span data-ttu-id="96e5f-144">編輯或建立新的 patient 的使用者介面的可允許的語言中的記錄填入下拉式清單包括`Languages`資料表。</span><span class="sxs-lookup"><span data-stu-id="96e5f-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="96e5f-145">但不快取，這個介面是每次瀏覽系統必須查詢`Languages`資料表。</span><span class="sxs-lookup"><span data-stu-id="96e5f-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="96e5f-146">這是浪費不必要查閱資料表值的變更很少，因為如果有的話。</span><span class="sxs-lookup"><span data-stu-id="96e5f-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="96e5f-147">我們無法快取`Languages`使用相同的反應靈敏的載入技術檢查先前的教學課程中的資料。</span><span class="sxs-lookup"><span data-stu-id="96e5f-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="96e5f-148">反應式載入，不過，會使用以時間為基礎的到期，就不需要的靜態查閱資料表的資料。</span><span class="sxs-lookup"><span data-stu-id="96e5f-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="96e5f-149">而使用反應靈敏的載入快取必須是優於無快取完全，最好的方法是主動載入應用程式啟動時快取中的查閱資料表資料。</span><span class="sxs-lookup"><span data-stu-id="96e5f-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="96e5f-150">在此教學課程中我們將探討如何快取查閱資料表資料及其他靜態資訊。</span><span class="sxs-lookup"><span data-stu-id="96e5f-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="96e5f-151">步驟 2： 檢查快取資料的不同方式</span><span class="sxs-lookup"><span data-stu-id="96e5f-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="96e5f-152">可在 ASP.NET 應用程式使用多種方式，以程式設計方式快取資訊。</span><span class="sxs-lookup"><span data-stu-id="96e5f-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="96e5f-153">我們我們已經看到如何使用先前的教學課程中的資料快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="96e5f-154">或者，可以以程式設計方式快取物件使用*靜態成員*或*應用程式狀態*。</span><span class="sxs-lookup"><span data-stu-id="96e5f-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="96e5f-155">當使用類別，通常類別必須先具現化之前可以存取其成員。</span><span class="sxs-lookup"><span data-stu-id="96e5f-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="96e5f-156">例如，若要叫用中的其中一個在我們的商務邏輯層中類別的方法，我們必須先建立類別的執行個體：</span><span class="sxs-lookup"><span data-stu-id="96e5f-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample1.vb)]

<span data-ttu-id="96e5f-157">我們可以叫用之前*SomeMethod*或使用*SomeProperty*，我們必須先建立類別使用的執行個體`New`關鍵字。</span><span class="sxs-lookup"><span data-stu-id="96e5f-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `New` keyword.</span></span> <span data-ttu-id="96e5f-158">*SomeMethod*和*SomeProperty*相關聯的特定執行個體。</span><span class="sxs-lookup"><span data-stu-id="96e5f-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="96e5f-159">這些成員的存留期會繫結及其相關聯的物件的存留期。</span><span class="sxs-lookup"><span data-stu-id="96e5f-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="96e5f-160">*靜態成員*，相反地，是變數、 屬性和方法所共用*所有*類別的執行個體，因此，只要類別存留期。</span><span class="sxs-lookup"><span data-stu-id="96e5f-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="96e5f-161">靜態成員以關鍵字代表`Shared`。</span><span class="sxs-lookup"><span data-stu-id="96e5f-161">Static members are denoted by the keyword `Shared`.</span></span>

<span data-ttu-id="96e5f-162">除了靜態成員，可以快取的資料使用應用程式狀態。</span><span class="sxs-lookup"><span data-stu-id="96e5f-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="96e5f-163">每個 ASP.NET 應用程式會維護名稱/值集合 s 的所有使用者和應用程式的頁面之間共用。</span><span class="sxs-lookup"><span data-stu-id="96e5f-163">Each ASP.NET application maintains a name/value collection that s shared across all users and pages of the application.</span></span> <span data-ttu-id="96e5f-164">此集合可以使用存取[`HttpContext`類別](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)s [ `Application`屬性](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)，並使用從 ASP.NET 頁面 s 程式碼後置類別就像這樣：</span><span class="sxs-lookup"><span data-stu-id="96e5f-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page s code-behind class like so:</span></span>


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample2.vb)]

<span data-ttu-id="96e5f-165">資料快取的快取資料，提供時間和相依性基礎 expiries、 快取項目優先順序、 等等的機制提供更豐富的 API。</span><span class="sxs-lookup"><span data-stu-id="96e5f-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="96e5f-166">靜態成員和應用程式狀態，這類功能必須手動新增網頁開發人員。</span><span class="sxs-lookup"><span data-stu-id="96e5f-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="96e5f-167">當應用程式的存留期間，快取應用程式啟動時的資料，不過，資料快取的優點是毫無意義。</span><span class="sxs-lookup"><span data-stu-id="96e5f-167">When caching data at application startup for the lifetime of the application, however, the data cache s advantages are moot.</span></span> <span data-ttu-id="96e5f-168">在此教學課程中我們將探討使用所有的三種技術來快取靜態資料的程式碼。</span><span class="sxs-lookup"><span data-stu-id="96e5f-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="96e5f-169">步驟 3： 快取`Suppliers`表格資料</span><span class="sxs-lookup"><span data-stu-id="96e5f-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="96e5f-170">Northwind 資料庫資料表我們 ve 至今實作不包含任何傳統的查閱資料表。</span><span class="sxs-lookup"><span data-stu-id="96e5f-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="96e5f-171">在我們的 DAL 中實作的四個 Datatable 所有模型的資料表，其值為非靜態。</span><span class="sxs-lookup"><span data-stu-id="96e5f-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="96e5f-172">而不是花時間來 DAL 然後新類別和方法，以 BLL，加入新 DataTable 的本教學課程只讓 s 假裝，`Suppliers`資料表的資料是靜態的。</span><span class="sxs-lookup"><span data-stu-id="96e5f-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let s just pretend that the `Suppliers` table s data is static.</span></span> <span data-ttu-id="96e5f-173">因此，我們可以快取這項資料在應用程式啟動。</span><span class="sxs-lookup"><span data-stu-id="96e5f-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="96e5f-174">若要開始，建立新的類別，名為`StaticCache.cs`中`CL`資料夾。</span><span class="sxs-lookup"><span data-stu-id="96e5f-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>


![CL 資料夾中建立 StaticCache.vb 類別](caching-data-at-application-startup-vb/_static/image2.png)

<span data-ttu-id="96e5f-176">**圖 2**： 建立`StaticCache.vb`類別`CL`資料夾</span><span class="sxs-lookup"><span data-stu-id="96e5f-176">**Figure 2**: Create the `StaticCache.vb` Class in the `CL` Folder</span></span>


<span data-ttu-id="96e5f-177">我們要加入的方法，在啟動時將資料載入適當的快取存放區中，以及從這個快取中傳回資料的方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample3.vb)]

<span data-ttu-id="96e5f-178">上述程式碼會使用靜態成員變數， `suppliers`，來保存從結果`SuppliersBLL`類別 s`GetSuppliers()`方法，從呼叫`LoadStaticCache()`方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class s `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="96e5f-179">`LoadStaticCache()`方法用於應用程式的啟動期間呼叫。</span><span class="sxs-lookup"><span data-stu-id="96e5f-179">The `LoadStaticCache()` method is meant to be called during the application s start.</span></span> <span data-ttu-id="96e5f-180">這項資料在應用程式啟動時載入之後, 就可以呼叫需要搭配供應商資料的任何頁面`StaticCache`類別的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class s `GetSuppliers()` method.</span></span> <span data-ttu-id="96e5f-181">因此，為了取得供應商到資料庫的呼叫只發生一次，在應用程式啟動。</span><span class="sxs-lookup"><span data-stu-id="96e5f-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="96e5f-182">而不是做為快取存放區使用的靜態成員變數，我們原也可以另外使用應用程式狀態或讓資料快取。</span><span class="sxs-lookup"><span data-stu-id="96e5f-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="96e5f-183">下列程式碼顯示使用應用程式狀態改裝類別：</span><span class="sxs-lookup"><span data-stu-id="96e5f-183">The following code shows the class retooled to use application state:</span></span>


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample4.vb)]

<span data-ttu-id="96e5f-184">在`LoadStaticCache()`，供應商資訊儲存在應用程式變數*金鑰*。</span><span class="sxs-lookup"><span data-stu-id="96e5f-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="96e5f-185">它傳回適當的型別 (`Northwind.SuppliersDataTable`) 從`GetSuppliers()`。</span><span class="sxs-lookup"><span data-stu-id="96e5f-185">It s returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="96e5f-186">雖然可以使用 ASP.NET 網頁的程式碼後置類別中存取應用程式狀態`Application("key")`，我們必須使用的架構中`HttpContext.Current.Application("key")`以取得目前`HttpContext`。</span><span class="sxs-lookup"><span data-stu-id="96e5f-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application("key")`, in the architecture we must use `HttpContext.Current.Application("key")` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="96e5f-187">同樣地，資料快取可用做為快取存放區，如下列程式碼所示：</span><span class="sxs-lookup"><span data-stu-id="96e5f-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample5.vb)]

<span data-ttu-id="96e5f-188">若要加入任何以時間為基礎的到期資料的快取項目，請使用`System.Web.Caching.Cache.NoAbsoluteExpiration`和`System.Web.Caching.Cache.NoSlidingExpiration`做為輸入參數的值。</span><span class="sxs-lookup"><span data-stu-id="96e5f-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="96e5f-189">這個特定的多載的資料快取 s`Insert`方法已選取，因此我們無法指定*優先順序*的快取項目。</span><span class="sxs-lookup"><span data-stu-id="96e5f-189">This particular overload of the data cache s `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="96e5f-190">優先順序用來判斷哪些項目可用的記憶體不足時，從快取清除。</span><span class="sxs-lookup"><span data-stu-id="96e5f-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="96e5f-191">這裡我們使用優先順序 `NotRemovable`，後者可確保此快取項目贏了 t 清除。</span><span class="sxs-lookup"><span data-stu-id="96e5f-191">Here we use the priority `NotRemovable`, which ensures that this cache item won t be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="96e5f-192">此教學課程的下載實作`StaticCache`類別使用靜態成員變數的方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-192">This tutorial s download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="96e5f-193">使用中的類別檔案中的註解的程式碼應用程式狀態和資料快取技術。</span><span class="sxs-lookup"><span data-stu-id="96e5f-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>


## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="96e5f-194">步驟 4： 執行應用程式啟動時的程式碼</span><span class="sxs-lookup"><span data-stu-id="96e5f-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="96e5f-195">Web 應用程式初次啟動時執行程式碼，我們必須建立名為的特殊檔案`Global.asax`。</span><span class="sxs-lookup"><span data-stu-id="96e5f-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="96e5f-196">這個檔案可以包含為應用程式，工作階段的事件處理常式，並要求層級事件，而且這是這裡我們可以在其中加入會在每次應用程式啟動時執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="96e5f-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="96e5f-197">新增`Global.asax`檔案，以 web 應用程式 s 根目錄 Visual Studio 的方案總管] 中的網站專案名稱上按一下滑鼠右鍵，然後選擇 [加入新項目。</span><span class="sxs-lookup"><span data-stu-id="96e5f-197">Add the `Global.asax` file to your web application s root directory by right-clicking on the website project name in Visual Studio s Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="96e5f-198">[加入新項目] 對話方塊中，從選取的全域應用程式類別的項目類型，然後按一下 [新增] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="96e5f-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="96e5f-199">如果您已經有`Global.asax`檔案在專案中，全域項目類型不會列在 [加入新項目] 對話方塊中的應用程式類別。</span><span class="sxs-lookup"><span data-stu-id="96e5f-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>


<span data-ttu-id="96e5f-200">[![Global.asax 檔加入 Web 應用程式 s 根目錄](caching-data-at-application-startup-vb/_static/image4.png)](caching-data-at-application-startup-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="96e5f-200">[![Add the Global.asax File to Your Web Application s Root Directory](caching-data-at-application-startup-vb/_static/image4.png)](caching-data-at-application-startup-vb/_static/image3.png)</span></span>

<span data-ttu-id="96e5f-201">**圖 3**： 新增`Global.asax`檔案到您的 Web 應用程式 s 根目錄 ([按一下以檢視完整大小的影像](caching-data-at-application-startup-vb/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="96e5f-201">**Figure 3**: Add the `Global.asax` File to Your Web Application s Root Directory ([Click to view full-size image](caching-data-at-application-startup-vb/_static/image5.png))</span></span>


<span data-ttu-id="96e5f-202">預設值`Global.asax`檔案範本包含五種方法在伺服器端內`<script>`標記：</span><span class="sxs-lookup"><span data-stu-id="96e5f-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="96e5f-203">**`Application_Start`** web 應用程式第一次啟動時執行</span><span class="sxs-lookup"><span data-stu-id="96e5f-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="96e5f-204">**`Application_End`** 應用程式正在關機而關閉時執行</span><span class="sxs-lookup"><span data-stu-id="96e5f-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="96e5f-205">**`Application_Error`** 執行時處理的例外狀況到達應用程式</span><span class="sxs-lookup"><span data-stu-id="96e5f-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="96e5f-206">**`Session_Start`** 建立新的工作階段時執行</span><span class="sxs-lookup"><span data-stu-id="96e5f-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="96e5f-207">**`Session_End`** 執行工作階段已過期或已放棄時</span><span class="sxs-lookup"><span data-stu-id="96e5f-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="96e5f-208">`Application_Start` s 應用程式生命週期內一次呼叫事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="96e5f-208">The `Application_Start` event handler is called only once during an application s life cycle.</span></span> <span data-ttu-id="96e5f-209">在應用程式啟動第一次 ASP.NET 資源會從應用程式要求，會繼續執行，直到重新啟動應用程式時，這可能會藉由修改的內容`/Bin`資料夾中，修改`Global.asax`，修改在內容`App_Code`資料夾，或修改`Web.config`檔案，在其他原因。</span><span class="sxs-lookup"><span data-stu-id="96e5f-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="96e5f-210">請參閱[ASP.NET 應用程式生命週期概觀](https://msdn.microsoft.com/library/ms178473.aspx)的應用程式生命週期的更詳細討論。</span><span class="sxs-lookup"><span data-stu-id="96e5f-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="96e5f-211">如需這些教學課程我們只需要將程式碼加入`Application_Start`方法中，因此可自由移除其他。</span><span class="sxs-lookup"><span data-stu-id="96e5f-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="96e5f-212">在`Application_Start`，只需呼叫`StaticCache`類別的`LoadStaticCache()`方法，將會載入並快取供應商資訊：</span><span class="sxs-lookup"><span data-stu-id="96e5f-212">In `Application_Start`, simply call the `StaticCache` class s `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample6.aspx)]

<span data-ttu-id="96e5f-213">S 都是這麼簡單 ！</span><span class="sxs-lookup"><span data-stu-id="96e5f-213">That s all there is to it!</span></span> <span data-ttu-id="96e5f-214">在應用程式啟動時，`LoadStaticCache()`方法將會抓取 BLL，從供應商的資訊，並將它儲存在靜態成員變數 (或任何快取儲存您結束使用中`StaticCache`類別)。</span><span class="sxs-lookup"><span data-stu-id="96e5f-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="96e5f-215">若要確認這種行為，請在設定的中斷點`Application_Start`方法並執行您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="96e5f-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="96e5f-216">請注意，應用程式啟動時叫用中斷點。</span><span class="sxs-lookup"><span data-stu-id="96e5f-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="96e5f-217">後續的要求，不過，不會導致`Application_Start`方法才能執行。</span><span class="sxs-lookup"><span data-stu-id="96e5f-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>


<span data-ttu-id="96e5f-218">[![使用確認 Application_Start 事件處理常式正在執行的中斷點](caching-data-at-application-startup-vb/_static/image7.png)](caching-data-at-application-startup-vb/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="96e5f-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-vb/_static/image7.png)](caching-data-at-application-startup-vb/_static/image6.png)</span></span>

<span data-ttu-id="96e5f-219">**圖 4**： 使用驗證的中斷點，`Application_Start`事件處理常式是正在執行 ([按一下以檢視完整大小的影像](caching-data-at-application-startup-vb/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="96e5f-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-vb/_static/image8.png))</span></span>


> [!NOTE]
> <span data-ttu-id="96e5f-220">如果您不會遇到`Application_Start`您第一次開始偵錯中斷點，這是因為您的應用程式已經開始。</span><span class="sxs-lookup"><span data-stu-id="96e5f-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="96e5f-221">強制應用程式藉由修改重新啟動您`Global.asax`或`Web.config`檔，並再試一次。</span><span class="sxs-lookup"><span data-stu-id="96e5f-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="96e5f-222">您可以直接新增 （或移除） 空白行其中一個快速地重新啟動應用程式檔案的結尾。</span><span class="sxs-lookup"><span data-stu-id="96e5f-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>


## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="96e5f-223">步驟 5： 顯示快取的資料</span><span class="sxs-lookup"><span data-stu-id="96e5f-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="96e5f-224">此時`StaticCache`類別有一個版本的應用程式啟動時，可以透過存取快取的供應商資料及其`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="96e5f-225">若要使用這項資料從展示層，我們可以使用 ObjectDataSource，或以程式設計方式叫用`StaticCache`類別的`GetSuppliers()`從 ASP.NET 頁面 s 程式碼後置類別的方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class s `GetSuppliers()` method from an ASP.NET page s code-behind class.</span></span> <span data-ttu-id="96e5f-226">可讓 s 查看使用 ObjectDataSource 和 GridView 控制項以顯示快取供應商的資訊。</span><span class="sxs-lookup"><span data-stu-id="96e5f-226">Let s look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="96e5f-227">先開啟`AtApplicationStartup.aspx`頁面`Caching`資料夾。</span><span class="sxs-lookup"><span data-stu-id="96e5f-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="96e5f-228">從工具箱拖曳至設計工具，設定將 GridView 其`ID`屬性`Suppliers`。</span><span class="sxs-lookup"><span data-stu-id="96e5f-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="96e5f-229">接下來，從 GridView s 智慧標籤選擇要建立名為新 ObjectDataSource `SuppliersCachedDataSource`。</span><span class="sxs-lookup"><span data-stu-id="96e5f-229">Next, from the GridView s smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="96e5f-230">設定用於 ObjectDataSource`StaticCache`類別的`GetSuppliers()`方法。</span><span class="sxs-lookup"><span data-stu-id="96e5f-230">Configure the ObjectDataSource to use the `StaticCache` class s `GetSuppliers()` method.</span></span>


<span data-ttu-id="96e5f-231">[![設定使用 StaticCache 類別 ObjectDataSource](caching-data-at-application-startup-vb/_static/image10.png)](caching-data-at-application-startup-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="96e5f-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-vb/_static/image10.png)](caching-data-at-application-startup-vb/_static/image9.png)</span></span>

<span data-ttu-id="96e5f-232">**圖 5**： 設定用於 ObjectDataSource`StaticCache`類別 ([按一下以檢視完整大小的影像](caching-data-at-application-startup-vb/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="96e5f-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-vb/_static/image11.png))</span></span>


<span data-ttu-id="96e5f-233">[![使用 GetSuppliers() 方法來擷取快取供應商資料](caching-data-at-application-startup-vb/_static/image13.png)](caching-data-at-application-startup-vb/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="96e5f-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-vb/_static/image13.png)](caching-data-at-application-startup-vb/_static/image12.png)</span></span>

<span data-ttu-id="96e5f-234">**圖 6**： 使用`GetSuppliers()`方法來擷取快取供應商資料 ([按一下以檢視完整大小的影像](caching-data-at-application-startup-vb/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="96e5f-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-vb/_static/image14.png))</span></span>


<span data-ttu-id="96e5f-235">完成精靈之後，Visual Studio 會自動加入 BoundFields 中的資料欄位的每個`SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="96e5f-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="96e5f-236">GridView 和 ObjectDataSource s 宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="96e5f-236">Your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample7.aspx)]

<span data-ttu-id="96e5f-237">圖 7 顯示透過瀏覽器檢視時的頁面。</span><span class="sxs-lookup"><span data-stu-id="96e5f-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="96e5f-238">輸出會與相同有我們提取的資料從 BLL s`SuppliersBLL`類別，但使用`StaticCache`類別會傳回做為應用程式啟動時快取的供應商資料。</span><span class="sxs-lookup"><span data-stu-id="96e5f-238">The output is the same had we pulled the data from the BLL s `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="96e5f-239">您可以設定中斷點，`StaticCache`類別的`GetSuppliers()`方法以驗證這種行為。</span><span class="sxs-lookup"><span data-stu-id="96e5f-239">You can set breakpoints in the `StaticCache` class s `GetSuppliers()` method to verify this behavior.</span></span>


<span data-ttu-id="96e5f-240">[![快取供應商資料會顯示在 GridView](caching-data-at-application-startup-vb/_static/image16.png)](caching-data-at-application-startup-vb/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="96e5f-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-vb/_static/image16.png)](caching-data-at-application-startup-vb/_static/image15.png)</span></span>

<span data-ttu-id="96e5f-241">**圖 7**: 快取供應商資料會顯示在 GridView ([按一下以檢視完整大小的影像](caching-data-at-application-startup-vb/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="96e5f-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-vb/_static/image17.png))</span></span>


## <a name="summary"></a><span data-ttu-id="96e5f-242">總結</span><span class="sxs-lookup"><span data-stu-id="96e5f-242">Summary</span></span>

<span data-ttu-id="96e5f-243">大部分每一個資料模型包含大量的靜態資料，通常在查閱資料表的形式實作。</span><span class="sxs-lookup"><span data-stu-id="96e5f-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="96e5f-244">這項資訊是靜態的因為那里 s 沒有理由持續存取資料庫每次需要顯示這項資訊。</span><span class="sxs-lookup"><span data-stu-id="96e5f-244">Since this information is static, there s no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="96e5f-245">此外，由於其靜態的本質，快取的資料時那里 s 到期不需要。</span><span class="sxs-lookup"><span data-stu-id="96e5f-245">Furthermore, due to its static nature, when caching the data there s no need for an expiry.</span></span> <span data-ttu-id="96e5f-246">在此教學課程中我們可了解如何取得這類資料並加以快取中的資料快取，應用程式狀態，以及透過靜態成員變數。</span><span class="sxs-lookup"><span data-stu-id="96e5f-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="96e5f-247">這項資訊會快取應用程式啟動時，會保留在快取整個應用程式 s 存留期。</span><span class="sxs-lookup"><span data-stu-id="96e5f-247">This information is cached at application startup and remains in the cache throughout the application s lifetime.</span></span>

<span data-ttu-id="96e5f-248">在本教學課程和過去的兩個，我們在應用程式 s 存留期的持續期間快取資料，以及使用以時間為基礎的 expiries 查看發生。</span><span class="sxs-lookup"><span data-stu-id="96e5f-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application s lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="96e5f-249">當快取資料庫的資料，不過，以時間為基礎的到期可能不盡理想。</span><span class="sxs-lookup"><span data-stu-id="96e5f-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="96e5f-250">而不是定期快取清除，亦即是最佳的作法是基礎資料庫資料修改時，只能收回快取的項目。</span><span class="sxs-lookup"><span data-stu-id="96e5f-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="96e5f-251">可以透過 SQL 快取相依性，這在我們的下一個教學課程中，我們將檢驗使用這個最理想的。</span><span class="sxs-lookup"><span data-stu-id="96e5f-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="96e5f-252">祝您程式設計 ！</span><span class="sxs-lookup"><span data-stu-id="96e5f-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="96e5f-253">關於作者</span><span class="sxs-lookup"><span data-stu-id="96e5f-253">About the Author</span></span>

<span data-ttu-id="96e5f-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七個 ASP/ASP.NET 書籍和的創辦[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已從 1998 年使用 Microsoft Web 技術。</span><span class="sxs-lookup"><span data-stu-id="96e5f-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="96e5f-255">Scott 可做為獨立顧問、 訓練和寫入器。</span><span class="sxs-lookup"><span data-stu-id="96e5f-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="96e5f-256">他最新的活頁簿[ *Sam 教導您自己 ASP.NET 2.0 24 小時內*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="96e5f-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="96e5f-257">他可以在達到[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或透過他的部落格，這可以在找到[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="96e5f-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="96e5f-258">特別感謝</span><span class="sxs-lookup"><span data-stu-id="96e5f-258">Special Thanks To</span></span>

<span data-ttu-id="96e5f-259">許多有用的檢閱者已檢閱本教學課程系列。</span><span class="sxs-lookup"><span data-stu-id="96e5f-259">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="96e5f-260">此教學課程中的前導檢閱者已本文菲和 Zack Jones。</span><span class="sxs-lookup"><span data-stu-id="96e5f-260">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="96e5f-261">檢閱我即將推出的 MSDN 文件有興趣嗎？</span><span class="sxs-lookup"><span data-stu-id="96e5f-261">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="96e5f-262">如果是這樣，卸除我一行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="96e5f-262">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="96e5f-263">[上一頁](caching-data-in-the-architecture-vb.md)
> [下一頁](using-sql-cache-dependencies-vb.md)</span><span class="sxs-lookup"><span data-stu-id="96e5f-263">[Previous](caching-data-in-the-architecture-vb.md)
[Next](using-sql-cache-dependencies-vb.md)</span></span>
